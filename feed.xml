<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xmlns:content="http://purl.org/rss/1.0/modules/content/"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd"
  xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/">
  <channel>
    <title>Leeyee's Blog</title>
    <link>http://leeyee.github.io</link>
    <description>RSS feed for </description>
    <pubDate>Sun, 17 Jan 2016 00:00:00 +0800</pubDate>
    <item>
      <title>Spring Retry中文文档</title>
      <link>http://leeyee.github.io/blog/2016/01/17/spring-retry-simple-introduce</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#retrytemplate-&quot;&gt;9.1  RetryTemplate 重试模板方法&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#retrycontext-&quot;&gt;9.1.1 RetryContext 重试上下文&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#recoverycallback-&quot;&gt;9.1.2 RecoveryCallback “兜底”回调&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#stateless-retry-&quot;&gt;9.1.3 Stateless Retry 无状态重试&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#stateful-retry-&quot;&gt;9.1.4 Stateful Retry 有状态重试&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#retry-policies-&quot;&gt;9.2 Retry Policies 重试策略&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#backoff-policies-&quot;&gt;9.3 Backoff Policies 回退策略&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#listeners-&quot;&gt;9.4 Listeners 重试监听&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#declarative-retry-&quot;&gt;9.5 Declarative Retry 声明式重试&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;http://docs.spring.io/spring-batch/reference/html/retry.html&quot;&gt;Spring-Retry&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;retrytemplate-&quot;&gt;9.1  RetryTemplate 重试模板方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt; The retry functionality was pulled out of Spring Batch as of 2.2.0. It is now part of a new library, Spring Retry.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;从Spring Batch 2.2.0开始，重试功能作为一个新的项目Spring Retry单独维护&lt;/p&gt;

&lt;p&gt;To make processing more robust and less prone to failure, sometimes it helps to automatically retry a failed operation in case it might succeed on a subsequent attempt. Errors that are susceptible to this kind of treatment are transient in nature. For example a remote call to a web service or RMI service that fails because of a network glitch or a DeadLockLoserException in a database update may resolve themselves after a short wait. To automate the retry of such operations Spring Batch has the RetryOperations strategy. The RetryOperations interface looks like this:&lt;/p&gt;

&lt;p&gt;为了使处理更加健壮，减少异常的发生，重试一个失败的操作有时是必要的，因为有可能在后续的失败重试中处理成功了。因此对于程序异常或者错误更应该使用这种重试机制进行处理。例如在远程调用web服务或者RMI服务时，因网络故障或者数据库更新时发生 &lt;code&gt;DeadLockLoserException&lt;/code&gt; 导致请求失败，但在稍等片刻后这种异常会自动恢复。为了实现这种情况下的重试操作，Spring Batch 提供重试策略。这些重试操作接口定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface RetryOperations {

	&amp;lt;T&amp;gt; T execute(RetryCallback&amp;lt;T&amp;gt; retryCallback) throws Exception;

	&amp;lt;T&amp;gt; T execute(RetryCallback&amp;lt;T&amp;gt; retryCallback, RecoveryCallback&amp;lt;T&amp;gt; recoveryCallback)
		throws Exception;

	&amp;lt;T&amp;gt; T execute(RetryCallback&amp;lt;T&amp;gt; retryCallback, RetryState retryState)
		throws Exception, ExhaustedRetryException;

	&amp;lt;T&amp;gt; T execute(RetryCallback&amp;lt;T&amp;gt; retryCallback, RecoveryCallback&amp;lt;T&amp;gt; recoveryCallback,
		RetryState retryState) throws Exception;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The basic callback is a simple interface that allows you to insert some business logic to be retried:&lt;/p&gt;

&lt;p&gt;基本的回调是一个简单的接口，你可以通过该接口实现需要重试的业务逻辑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface RetryCallback&amp;lt;T&amp;gt; {

	T doWithRetry(RetryContext context) throws Throwable;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The callback is executed and if it fails (by throwing an Exception), it will be retried until either it is successful, or the implementation decides to abort. There are a number of overloaded execute methods in the RetryOperations interface dealing with various use cases for recovery when all retry attempts are exhausted, and also with retry state, which allows clients and implementations to store information between calls (more on this later).&lt;/p&gt;

&lt;p&gt;回调执行过程中如果抛出异常，将会进行重试，直到回调成功或者被回调实现终止。&lt;code&gt;RetryOperations&lt;/code&gt;接口中定义了一些基本执行方法，可以用来处理重试结束后的用户的“兜底”操作，也可以将每次重试失败时的重试状态返回给调用方&lt;/p&gt;

&lt;p&gt;The simplest general purpose implementation of RetryOperations is RetryTemplate. It could be used like this&lt;/p&gt;

&lt;p&gt;最简单的 &lt;code&gt;RetryOperations&lt;/code&gt; 实现是 &lt;code&gt;RetryTempate&lt;/code&gt; 方法，使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// RetryTemplate 默认使用SimpleRetryPolicy策略。
// SimpleRetryPolicy 是调用次数重试。默认3次
RetryTemplate template = new RetryTemplate();

// version1.1.2中默认超时1000ms
TimeoutRetryPolicy policy = new TimeoutRetryPolicy();
policy.setTimeout(30000L);

template.setRetryPolicy(policy);

Foo result = template.execute(new RetryCallback&amp;lt;Foo&amp;gt;() {

	public Foo doWithRetry(RetryContext context) {
		// Do stuff that might fail, e.g. webservice operation
		return result;
	}

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example we execute a web service call and return the result to the user. If that call fails then it is retried until a timeout is reached.&lt;/p&gt;

&lt;p&gt;在这个示例中，我们执行web服务调用并返回结果给用户。如果调用失败了，那么将继续重试，直到超时为止。&lt;/p&gt;

&lt;h3 id=&quot;retrycontext-&quot;&gt;9.1.1 RetryContext 重试上下文&lt;/h3&gt;

&lt;p&gt;The method parameter for the RetryCallback is a RetryContext. Many callbacks will simply ignore the context, but if necessary it can be used as an attribute bag to store data for the duration of the iteration.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RetryCallback&lt;/code&gt; 方法的参数是 &lt;code&gt;RetryContext&lt;/code&gt;（重试上下文） .许多回调将简单地忽略该上下文，但是如果需要，可以将上下文在重试迭代时间范围内当作一个属性包存储数据使用。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public int le10(int i) throws Exception {
	if (i &amp;lt; 10) throw new Exception(i + &quot; le 10&quot;);
	return i;
}
public static void main(String... args) throws Exceptioin {
	RetryTemplate template = new RetryTemplate();

    TimeoutRetryPolicy policy = new TimeoutRetryPolicy();
    policy.setTimeout(50000L);

    template.setRetryPolicy(policy);

    int result = template.execute(new RetryCallback&amp;lt;Integer, Exception&amp;gt;() {

        int i = 5;
        
        @Override
        public Integer doWithRetry(RetryContext context) throws Exception {
            return le10(i++);
        }
    });
	
	System.out.println(i); // final return is 10
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A RetryContext will have a parent context if there is a nested retry in progress in the same thread. The parent context is occasionally useful for storing data that need to be shared between calls to execute.&lt;/p&gt;

&lt;p&gt;如果在同一线程处理中有一个内嵌的重试，那么重试上下文将有一个父上线文。父上下文偶尔被用来在需要被调用执行之间存储共享数据。&lt;/p&gt;

&lt;h3 id=&quot;recoverycallback-&quot;&gt;9.1.2 RecoveryCallback “兜底”回调&lt;/h3&gt;

&lt;p&gt;When a retry is exhausted the RetryOperations can pass control to a different callback, the RecoveryCallback. To use this feature clients just pass in the callbacks together to the same method, for example:&lt;/p&gt;

&lt;p&gt;当所有重试操作完成时（依然没有获取正确的结果）可以通过 &lt;code&gt;RecoveryCallback&lt;/code&gt; 实现一个兜底的操作。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Foo foo = template.execute(new RetryCallback&amp;lt;Foo&amp;gt;() {
	public Foo doWithRetry(RetryContext context) {
		// business logic here
	},
  new RecoveryCallback&amp;lt;Foo&amp;gt;() {
	Foo recover(RetryContext context) throws Exception {
		  // recover logic here
	}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the business logic does not succeed before the template decides to abort, then the client is given the chance to do some alternate processing through the recovery callback.&lt;/p&gt;

&lt;p&gt;在重试调用执行完成前如果业务逻辑仍然不能成功获取结果，那么客户端可以通过实现 &lt;code&gt;RecoveryCallback&lt;/code&gt; 接口替换原有业务逻辑，并返回相应的结果。&lt;/p&gt;

&lt;h3 id=&quot;stateless-retry-&quot;&gt;9.1.3 Stateless Retry 无状态重试&lt;/h3&gt;

&lt;p&gt;In the simplest case, a retry is just a while loop: the RetryTemplate can just keep trying until it either succeeds or fails. The RetryContext contains some state to determine whether to retry or abort, but this state is on the stack and there is no need to store it anywhere globally, so we call this stateless retry. The distinction between stateless and stateful retry is contained in the implementation of the RetryPolicy (the RetryTemplate can handle both). In a stateless retry, the callback is always executed in the same thread on retry as when it failed.&lt;/p&gt;

&lt;p&gt;在最简单的示例中，重试仅仅是一个 while 循环：&lt;code&gt;RetryTemplate&lt;/code&gt; 仅仅能保持尝试直到成功或者失败。 &lt;code&gt;RetryContext&lt;/code&gt; 包含了一些状态用来决定是否重试还是中止，但是该状态是存储在内存栈中的，而不是作为一个全局属性存在，因此我们认为是无状态重试。无状态和有状态重试的区别是在于 &lt;code&gt;RetryPolicy&lt;/code&gt; 的实现上（&lt;code&gt;RetryTemplate&lt;/code&gt; 两种状态的处理都支持）。在无状态重试中，失败重试回调总是执行在同一个线程中。&lt;/p&gt;

&lt;h3 id=&quot;stateful-retry-&quot;&gt;9.1.4 Stateful Retry 有状态重试&lt;/h3&gt;

&lt;p&gt;Where the failure has caused a transactional resource to become invalid, there are some special considerations. This does not apply to a simple remote call because there is no transactional resource (usually), but it does sometimes apply to a database update, especially when using Hibernate. In this case it only makes sense to rethrow the exception that called the failure immediately so that the transaction can roll back and we can start a new valid one.&lt;/p&gt;

&lt;p&gt;当故障导致事务资源变为无效时，需要做一些特殊的考虑。有状态重试并不适用于简单的远程调用，因为远程调用没有事务性资源（通常情况下），但当其被应用到数据库更新，尤其是使用Hibernate时，就显得重要了。在这种场景下，当调用失败时立即重新抛出异常以便事务可以回滚。&lt;/p&gt;

&lt;p&gt;In these cases a stateless retry is not good enough because the re-throw and roll back necessarily involve leaving the RetryOperations.execute() method and potentially losing the context that was on the stack. To avoid losing it we have to introduce a storage strategy to lift it off the stack and put it (at a minimum) in heap storage. For this purpose Spring Batch provides a storage strategy RetryContextCache which can be injected into the RetryTemplate. The default implementation of the RetryContextCache is in memory, using a simple Map. Advanced usage with multiple processes in a clustered environment might also consider implementing the RetryContextCache with a cluster cache of some sort (though, even in a clustered environment this might be overkill).&lt;/p&gt;

&lt;p&gt;这种请况下，一个无状态重试是不够的，因为重新抛出异常并回滚必然会离开 &lt;code&gt;RetryOperations.execute()&lt;/code&gt; 方法，导致内存栈中的上下文信息丢失。为了避免丢失上下文，我们不得不使用一种存储策略将内存栈（局部的）中的信息存放到至少是内存堆（全局）一级的存储中。为此，Spring Batch 提供一种存储策略 ——可以注入到&lt;code&gt;RetryTemplate&lt;/code&gt; 的 &lt;code&gt;RetryContextCache&lt;/code&gt;。&lt;code&gt;RetryContextCache&lt;/code&gt; 默认实现方式是通过使用一个简单的 &lt;code&gt;Map&lt;/code&gt; 对象将其存储在内存中。集群环境中的多进程高级用法可以考虑通过集群的高速缓存来实现 &lt;code&gt;RetryContextCache&lt;/code&gt;（不过在集群环境中，这是做法有点小题大做了）。&lt;/p&gt;

&lt;p&gt;Part of the responsibility of the RetryOperations is to recognize the failed operations when they come back in a new execution (and usually wrapped in a new transaction). To facilitate this, Spring Batch provides the RetryState abstraction. This works in conjunction with a special execute methods in the RetryOperations.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RetryOperations&lt;/code&gt; 的职责之一就是在进行一个新的重试时记住失败的操作（通常包被包装在一个新的事物中）。为此，Spring Batch 抽象出了 &lt;code&gt;RetryState&lt;/code&gt; 接口。&lt;code&gt;RetryState&lt;/code&gt; 被用在  &lt;code&gt;RetryOperations&lt;/code&gt;  作为一个特殊的执行方法。&lt;/p&gt;

&lt;p&gt;The way the failed operations are recognized is by identifying the state across multiple invocations of the retry. To identify the state, the user can provide an RetryState object that is responsible for returning a unique key identifying the item. The identifier is used as a key in the RetryContextCache.&lt;/p&gt;

&lt;p&gt;这种方式下，失败操作被标识为状态在每次重试操作时返回。对于标识的状态，可以通过提供一个能返回唯一标识的&lt;code&gt;RetryState&lt;/code&gt; 对象来定义。该标识在 &lt;code&gt;RetryContextCache&lt;/code&gt; 对象被当作一个唯一键处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;br /&gt;
Be very careful with the implementation of Object.equals() and Object.hashCode() in the key returned by RetryState. The best advice is to use a business key to identify the items. In the case of a JMS message the message ID can be used.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;通过 &lt;code&gt;RetryState&lt;/code&gt; 返回 key 时，要小心 key 的 &lt;code&gt;equals()&lt;/code&gt; 和 &lt;code&gt;hashCode()&lt;/code&gt; 方法。最好的方式是使用一个业务键去标识。比如在使用JMS消息时，可以使用消息的ID作为key。&lt;/p&gt;

&lt;p&gt;When the retry is exhausted there is also the option to handle the failed item in a different way, instead of calling the RetryCallback (which is presumed now to be likely to fail). Just like in the stateless case, this option is provided by the RecoveryCallback, which can be provided by passing it in to the execute method of RetryOperations.&lt;/p&gt;

&lt;p&gt;当所有重试完成，仍然可以选择使用不同方式去替代 &lt;code&gt;RetryCallback&lt;/code&gt; （RetryCallback 操作现在被假定为可能失败） 去处理失败的操作。就像无状态重试下可以通过&lt;code&gt;RecoveryCallback&lt;/code&gt; 接口传递到对应的处理操作到 &lt;code&gt;RetryOperations&lt;/code&gt; 的 execute 方法中。&lt;/p&gt;

&lt;p&gt;The decision to retry or not is actually delegated to a regular RetryPolicy, so the usual concerns about limits and timeouts can be injected there (see below).&lt;/p&gt;

&lt;p&gt;是否决定重试实际上是委托给 &lt;code&gt;RetryPolicy&lt;/code&gt; 的，所以通常对于重试限制和超时重试可以放在&lt;code&gt;RetryPolicy&lt;/code&gt; 中实现（见下文）。&lt;/p&gt;

&lt;h2 id=&quot;retry-policies-&quot;&gt;9.2 Retry Policies 重试策略&lt;/h2&gt;

&lt;p&gt;Inside a RetryTemplate the decision to retry or fail in the execute method is determined by a RetryPolicy which is also a factory for the RetryContext. The RetryTemplate has the responsibility to use the current policy to create a RetryContext and pass that in to the RetryCallback at every attempt. After a callback fails the RetryTemplate has to make a call to the RetryPolicy to ask it to update its state (which will be stored in the RetryContext), and then it asks the policy if another attempt can be made. If another attempt cannot be made (e.g. a limit is reached or a timeout is detected) then the policy is also responsible for handling the exhausted state. Simple implementations will just throw RetryExhaustedException which will cause any enclosing transaction to be rolled back. More sophisticated implementations might attempt to take some recovery action, in which case the transaction can remain intact.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RetryTemplate&lt;/code&gt;决定重试与否是由&lt;code&gt;RetryPolicy&lt;/code&gt;方法（&lt;code&gt;RetryPolicy&lt;/code&gt;是通过 &lt;code&gt;RetryContext&lt;/code&gt;来操作的）来决定。&lt;code&gt;RetryTemplate&lt;/code&gt;通过当前的 &lt;code&gt;RetryPolicy&lt;/code&gt;创建一个&lt;code&gt;RetryContext&lt;/code&gt;并在每一次重试尝试时调用&lt;code&gt;RetryCallback&lt;/code&gt;。回调失败后&lt;code&gt;RetryTemplate&lt;/code&gt;通知&lt;code&gt;RetryPolicy&lt;/code&gt;让其更新状态（状态信息存储在&lt;code&gt;RetryContext&lt;/code&gt;中），并询问&lt;code&gt;RetryPolicy&lt;/code&gt;是否进行可以进行下一次重试。假如重试不可用（比如到达重试次数限制或者重试超时），&lt;code&gt;RetryPolicy&lt;/code&gt;将修改其状态。&lt;code&gt;RetryPolicy&lt;/code&gt; 简单的实现只是抛出&lt;code&gt;RetryExhaustedException&lt;/code&gt;&lt;sup id=&quot;fnref:correct1&quot;&gt;&lt;a href=&quot;#fn:correct1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;这将导致所有的封闭事务回滚。更复杂的实现方式可能会试图尝试一些恢复性操作，在这种情况下，事务是保持不变的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tip&lt;/strong&gt;&lt;br /&gt;
Failures are inherently either retryable or not - if the same exception is always going to be thrown from the business logic, it doesn’t help to retry it. So don’t retry on all exception types - try to focus on only those exceptions that you expect to be retryable. It’s not usually harmful to the business logic to retry more aggressively, but it’s wasteful because if a failure is deterministic there will be time spent retrying something that you know in advance is fatal.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 对于失败，无论是重试与否，如果业务逻辑总是抛出相同的异常，那么重试是没有意义的。因此，不要对所有的异常都进行重试，而是将重试的焦点放在那些你希望进行重试的异常上。虽然对所以异常都进行重试对于业务没有影响，但这会将时间浪费在事先已知的致命错误上。&lt;/p&gt;

&lt;p&gt;Spring Batch provides some simple general purpose implementations of stateless RetryPolicy, for example a SimpleRetryPolicy, and the TimeoutRetryPolicy used in the example above.&lt;/p&gt;

&lt;p&gt;Spring Batch 提供了一些无状态重试策略（RetryPolicy）的通用实现，比如上述是示例中的&lt;code&gt;SimpleRetryPolicy&lt;/code&gt; （循环重试指定次数）、&lt;code&gt;TimeoutRetryPolicy&lt;/code&gt; （超时时间范围内的重试）等。&lt;/p&gt;

&lt;p&gt;The SimpleRetryPolicy just allows a retry on any of a named list of exception types, up to a fixed number of times. It also has a list of “fatal” exceptions that should never be retried, and this list overrides the retryable list so that it can be used to give finer control over the retry behavior:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SimpleRetryPolicy&lt;/code&gt; 简单重试策略允许当发生指定异常类型时进行指定次数的重试。同时可以指定在那些致命异常上不进行重试，这些异常类型列表可被重写，以便可以更好的控制重试动作&lt;sup id=&quot;fnref:correct2&quot;&gt;&lt;a href=&quot;#fn:correct2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SimpleRetryPolicy policy = new SimpleRetryPolicy();
// Set the max retry attempts
policy.setMaxAttempts(5);
// Retry on all exceptions (this is the default)
policy.setRetryableExceptions(new Class[] {Exception.class});
// ... but never retry IllegalStateException
policy.setFatalExceptions(new Class[] {IllegalStateException.class});

// Use the policy...
RetryTemplate template = new RetryTemplate();
template.setRetryPolicy(policy);
template.execute(new RetryCallback&amp;lt;Foo&amp;gt;() {
	public Foo doWithRetry(RetryContext context) {
		// business logic here
	}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is also a more flexible implementation called ExceptionClassifierRetryPolicy, which allows the user to configure different retry behavior for an arbitrary set of exception types though the ExceptionClassifier abstraction. The policy works by calling on the classifier to convert an exception into a delegate RetryPolicy, so for example, one exception type can be retried more times before failure than another by mapping it to a different policy.&lt;/p&gt;

&lt;p&gt;还有一种被叫做&lt;code&gt;ExceptionClassifierRetryPolicy&lt;/code&gt;的灵活回调策略实现，他允许用户通过抽象类&lt;code&gt;ExceptionClassifier&lt;/code&gt;对任意异常集合配置不同的重试行为。该策略通过调用一个分类器将异常转换成一个代理&lt;code&gt;RetryPolicy&lt;/code&gt;，这种请情况下，针对重试方法抛出的不同异常使用不同的重试策略进行重试。（如果重试方法返回成功或者其中任意一个异常重试达到了终止点，则重试终止）&lt;/p&gt;

&lt;p&gt;例如：&lt;sup id=&quot;fnref:comment1&quot;&gt;&lt;a href=&quot;#fn:comment1&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static String randomException() throws Exception {
	int random = (int) (Math.random() * 10);

	if (random &amp;lt; 4) {
		logger.info(&quot;random={} Null Pointer&quot;, random);
		throw new NullPointerException();
	} else if (random &amp;lt; 10) {
		logger.info(&quot;random={} Arithmetic Excep&quot;, random);
		throw new ArithmeticException();
	}
	
	// 这段代码不会被调用 random:0-1
	logger.info(&quot;random={} ok !!!!&quot;, random);
	return &quot;ok&quot;;
}

public static void testExceptionClassifierRetryPolicy() throws Exception {
	RetryTemplate template = new RetryTemplate();
	ExceptionClassifierRetryPolicy retryPolicy = new ExceptionClassifierRetryPolicy();

	Map&amp;lt;Class&amp;lt;? extends Throwable&amp;gt;, RetryPolicy&amp;gt; policyMap = Maps.newHashMap();
	
	// 如果发生空指针异常，则最大重试2ms，然后退出重试
	TimeoutRetryPolicy timeoutRetryPolicy = new TimeoutRetryPolicy();
	timeoutRetryPolicy.setTimeout(2L);
	policyMap.put(NullPointerException.class, timeoutRetryPolicy);
	
	// 如果发生 1/0 异常，则最多重试10次，然后退出重试
	SimpleRetryPolicy simpleRetryPolicy = new SimpleRetryPolicy();
	simpleRetryPolicy.setMaxAttempts(10);
	policyMap.put(ArithmeticException.class, simpleRetryPolicy);
	
	// 以上两种异常有可能交替出现，直到某一中类型的异常重试达到终止状态，或者被重试方法返回正确结果
	retryPolicy.setPolicyMap(policyMap);

	template.setRetryPolicy(retryPolicy);

	template.execute(new RetryCallback&amp;lt;String, Exception&amp;gt;() {
		@Override
		public String doWithRetry(RetryContext context) throws Exception {
			return randomException();
		}
	});
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Users might need to implement their own retry policies for more customized decisions. For instance, if there is a well-known, solution-specific, classification of exceptions into retryable and not retryable.&lt;/p&gt;

&lt;p&gt;用户可能需要自己实现一些个性化的重试策略。比如一个公共的解决特定问题的异常重试机制。&lt;/p&gt;

&lt;h2 id=&quot;backoff-policies-&quot;&gt;9.3 Backoff Policies 回退策略&lt;/h2&gt;

&lt;p&gt;When retrying after a transient failure it often helps to wait a bit before trying again, because usually the failure is caused by some problem that will only be resolved by waiting. If a RetryCallback fails, the RetryTemplate can pause execution according to the BackoffPolicy in place.&lt;/p&gt;

&lt;p&gt;当一个瞬态失败重试完成后，适当的等待一段时间是必要的，因为通常造成失败的问题被解决，只能通过等待来解决。如果重试回调失败，&lt;code&gt;RetryTemplate&lt;/code&gt;可以通过&lt;code&gt;BackoffPolicy&lt;/code&gt; 进行回退操作（其实就是两次重试之间如何处理的策略，可以理解成两次重试间如何衔接的策略）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface BackoffPolicy {

    BackOffContext start(RetryContext context);

    void backOff(BackOffContext backOffContext)
    throws BackOffInterruptedException;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A BackoffPolicy is free to implement the backOff in any way it chooses. The policies provided by Spring Batch out of the box all use Object.wait(). A common use case is to backoff with an exponentially increasing wait period, to avoid two retries getting into lock step and both failing - this is a lesson learned from the ethernet. For this purpose Spring Batch provides the ExponentialBackoffPolicy.&lt;/p&gt;

&lt;p&gt;可以通过实现&lt;code&gt;BackoffPolicy&lt;/code&gt;接口，选择适合自己的任何方式实现回退（间隔）。Spring Batch 实现的所有开箱策略使用&lt;code&gt;Object.wait()&lt;/code&gt;。一个常见的用例是，等待时间以指数级增长，这样可以避免两个重试争夺锁资源导致都失败——这是来自以太网的教训。出入这样的考虑，Spring Batch 提供了&lt;code&gt;ExponentialBackoffPolicy&lt;/code&gt;（指数级回退策略）。&lt;/p&gt;

&lt;h2 id=&quot;listeners-&quot;&gt;9.4 Listeners 重试监听&lt;/h2&gt;

&lt;p&gt;Often it is useful to be able to receive additional callbacks for cross cutting concerns across a number of different retries. For this purpose Spring Batch provides the RetryListener interface. The RetryTemplate allows users to register RetryListeners, and they will be given callbacks with the RetryContext and Throwable where available during the iteration.&lt;/p&gt;

&lt;p&gt;通常能接受到在多个不同的重试横切关注点的回调是有用的。因此，Spring Batch 提供了&lt;code&gt;RetryListener&lt;/code&gt;重试监听接口。&lt;code&gt;RetryTemplate&lt;/code&gt;重试模板方法允许用户注册相应重试监听，如果有重试，那么可以通过注册的监听获取重试过程中的上下文&lt;code&gt;RetryContext&lt;/code&gt;和抛出的异常。&lt;/p&gt;

&lt;p&gt;The interface looks like this:&lt;/p&gt;

&lt;p&gt;接口定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface RetryListener {

	void open(RetryContext context, RetryCallback&amp;lt;T&amp;gt; callback);

	void onError(RetryContext context, RetryCallback&amp;lt;T&amp;gt; callback, Throwable e);

	void close(RetryContext context, RetryCallback&amp;lt;T&amp;gt; callback, Throwable e);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The open and close callbacks come before and after the entire retry in the simplest case and onError applies to the individual RetryCallback calls. The close method might also receive a Throwable; if there has been an error it is the last one thrown by the RetryCallback.&lt;/p&gt;

&lt;p&gt;开始重试时会回调open方法，所有重试结束后（包括RecoveryCallback）会回调close方法，每次执行重试方法失败时会回调onError方法。假如最后一个方法&lt;code&gt;RetryCallback&lt;/code&gt;抛出异常，那么close方法有可能也会收到&lt;code&gt;Throwable&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Note that when there is more than one listener, they are in a list, so there is an order. In this case open will be called in the same order while onError and close will be called in reverse order.&lt;/p&gt;

&lt;p&gt;需要注意的是当有多个监听时，所有的监听都存放在 list 中，因此监听的执行是有顺序的。在 open 方法中，所有的监听按顺序被调用，但在 onError 和 close 方法中，监听执行顺序与 open 中相反。&lt;/p&gt;

&lt;h2 id=&quot;declarative-retry-&quot;&gt;9.5 Declarative Retry 声明式重试&lt;/h2&gt;

&lt;p&gt;Sometimes there is some business processing that you know you want to retry every time it happens. The classic example of this is the remote service call. Spring Batch provides an AOP interceptor that wraps a method call in a RetryOperations for just this purpose. The RetryOperationsInterceptor executes the intercepted method and retries on failure according to the RetryPolicy in the provided RepeatTemplate.&lt;/p&gt;

&lt;p&gt;有时还有一些是你明确知道，当其每次发生时需要重试的业务逻辑。最典型的例子就是远程服务调用。为此Spring Batch 提供了一个AOP拦截器，包装了一个在&lt;code&gt;RetryOperations&lt;/code&gt;中调用的方法，用来实现这目标。&lt;/p&gt;

&lt;p&gt;Here is an example of declarative iteration using the Spring AOP namespace to repeat a service call to a method called remoteCall (for more detail on how to configure AOP interceptors see the Spring User Guide):&lt;/p&gt;

&lt;p&gt;下面是使用Spring AOP 配置重复操作拦截器的一个示例（关于如何配置AOP拦截器请查看Spring用户指南）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;aop:config&amp;gt;
	&amp;lt;aop:pointcut id=&quot;transactional&quot;
		expression=&quot;execution(* com..*Service.remoteCall(..))&quot; /&amp;gt;
	&amp;lt;aop:advisor pointcut-ref=&quot;transactional&quot;
		advice-ref=&quot;retryAdvice&quot; order=&quot;-1&quot;/&amp;gt;
&amp;lt;/aop:config&amp;gt;

&amp;lt;bean id=&quot;retryAdvice&quot; class=&quot;org.springframework.batch.retry.interceptor.RetryOperationsInterceptor&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example above uses a default RetryTemplate inside the interceptor. To change the policies or listeners, you only need to inject an instance of RetryTemplate into the interceptor.&lt;/p&gt;

&lt;p&gt;上面的例子使用拦截器内部默认的RetryTemplate。可以通过注入新的重试策略和监听到拦截器中，改变上述默认机制。&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:correct1&quot;&gt;
      &lt;p&gt;Spring-Retry 1.2.2版本中，&lt;code&gt;RetryExhaustedException&lt;/code&gt;已被替换成&lt;code&gt;ExhaustedRetryException&lt;/code&gt; &lt;a href=&quot;#fnref:correct1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:correct2&quot;&gt;
      &lt;p&gt;Spring-Retry 1.2.2版本中，可重试异常和不可执行异常数组使用 Map 替代！ &lt;a href=&quot;#fnref:correct2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:comment1&quot;&gt;
      &lt;p&gt;作者补充的Test Case &lt;a href=&quot;#fnref:comment1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
      <pubDate>Sun, 17 Jan 2016 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2016/01/17/spring-retry-simple-introduce</guid>
      <dc:date>2016-01-17T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>PL/SQL块中使用SQL</title>
      <link>http://leeyee.github.io/blog/2015/08/30/plsql-sql-use-sql-in-block</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;检索单行数据&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;1、使用标量变量接收数据&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;2、使用记录变量接收数据&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#select--into--from--where-&quot;&gt;3、嵌入使用 SELECT … INTO … FROM … [WHERE] 语句注意事项&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;操作数据&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;插入数据&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#sqlplus-insert&quot;&gt;SQL*Plus INSERT数据语法为：&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#plsqlinsert-values&quot;&gt;在PL/SQL中使用INSERT VALUES插入数据&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#plsql&quot;&gt;在PL/SQL中使用子查询插入数据&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;更新数据&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#sqlplus-&quot;&gt;SQL*Plus 语法&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#plsql-&quot;&gt;PL/SQL 语法&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;删除数据&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#sqlplus--1&quot;&gt;SQL*Plus 语法&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#plsql--1&quot;&gt;PL/SQL 语法&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#sql&quot;&gt;SQL游标&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#sql-1&quot;&gt;SQL游标属性&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot;&gt;事务控制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;检索单行数据&lt;/h2&gt;

&lt;p&gt;在PL/SQL块中使用select语句，可以将数据库数据检索到变量中。&lt;/p&gt;

&lt;p&gt;当在PL/SQL块中使用select语句时，必须要带有&lt;strong&gt;into&lt;/strong&gt;子句。语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT select_list
	INTO {variable_name[,variable_name]... | record_name}
FROM table_name
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;select_list为指定查询列；&lt;/li&gt;
  &lt;li&gt;variable_name为接收指定查询列的标量变量名；&lt;/li&gt;
  &lt;li&gt;record_name为接收指定查询列的记录变量名；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1、使用标量变量接收数据&lt;/h3&gt;

&lt;p&gt;使用标量变量接收 SELECT 语句的输出结果时，变量个数要与 SELECT 选择项相同，且变量类型和长度要匹配。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECLARE
	v_name user.ename%TYPE;
	v_age user.age%TYPE;
BEGIN
	SELECT name,age into v_name,v_age
	FROM user where uid = &amp;amp;id;
	dbms_output.put_line('姓名:'||v_name);
	dbms_output.put_line('年龄:'||v_age);
END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2、使用记录变量接收数据&lt;/h3&gt;

&lt;p&gt;使用记录变量接受数据时，记录成员的个数必须与选择列表项个数完全一致，且数据类型和长度要相匹配。上述例子使用记录变量可写成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECLARE
	TYPE user_record_type IS RECORD (
		name user.name%TYPE,
		age user.age%TYPE
	);
	user_record user_record_type;
BEGIN
	SELECT name,age into user_record
	FROM user
	WEHRE uid = &amp;amp;id;
	dbms_output.put_line('姓名:'||user_record.name);
	dbms_output.put_line('年龄:'||user_record.age);
END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;select--into--from--where-&quot;&gt;3、嵌入使用 SELECT … INTO … FROM … [WHERE] 语句注意事项&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;在PL/SQL块中使用 SELECT INTO 语句时，该语句只能返回一条数据&lt;/li&gt;
  &lt;li&gt;当 1 不成立时，会触发以下异常：
    &lt;ol&gt;
      &lt;li&gt;&lt;em&gt;&lt;strong&gt;NO_DATA_FOUNT异常&lt;/strong&gt;&lt;/em&gt;。该异常发生在 SELECT INTO 语句&lt;strong&gt;没有返回任何数据&lt;/strong&gt;时&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;&lt;strong&gt;TOO_MANY_ROWS异常&lt;/strong&gt;&lt;/em&gt;。该异常发生在 SELECT INTO 语句&lt;strong&gt;没有返回多条数据&lt;/strong&gt;时&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;em&gt;&lt;strong&gt;以上两个异常在没有捕获时将会将异常信息传递到调用环境中&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;WHERE 子句中使用变量时，变量名不能与列名相同，否则会触发 &lt;strong&gt;TOO_MANY_ROWS&lt;/strong&gt; 异常。例如以下示例将产生异常。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; DECLARE
     uid NUMBER(6) := 10;
     v_name VARCHAR2(10);
 BEGIN
     SELECT name INTO v_name FROM user WHERE uid = uid;
 END;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;操作数据&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;插入数据&lt;/h3&gt;

&lt;h4 id=&quot;sqlplus-insert&quot;&gt;SQL*Plus INSERT数据语法为：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO &amp;lt;table&amp;gt; [(column[,column,...])]
		VALUES(value[,value,...])
或者

INSERT INTO &amp;lt;table&amp;gt; [(column[,column,...])] SubQuery
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PL/SQL中与SQL*Plus INSERT数据相同，只不过在提供数值时需要使用PL/SQL变量。&lt;/p&gt;

&lt;h4 id=&quot;plsqlinsert-values&quot;&gt;在PL/SQL中使用INSERT VALUES插入数据&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;DECLARE
		v_name user.name%TYPE;
		v_age user.age%TYPE;
	BEGIN
		v_name := '&amp;amp;name';
		v_age := &amp;amp;age;
		INSERT INTO user(name,age) VALUES(v_name,v_age);
	END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;plsql&quot;&gt;在PL/SQL中使用子查询插入数据&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;DECLARE
		v_deptno dep.no%TYPE;
	BEGIN
		INSERT INTO user(name,age)
			SELECT name,age
			FROM dep
			WHERE no = v_deptno;
	END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;更新数据&lt;/h3&gt;

&lt;h4 id=&quot;sqlplus-&quot;&gt;SQL*Plus 语法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;UPDATE &amp;lt;table|view&amp;gt;
SET &amp;lt;column&amp;gt; = &amp;lt;value&amp;gt; [, &amp;lt;column&amp;gt; = &amp;lt;value&amp;gt;...]
[WHERE &amp;lt;conditon&amp;gt;];
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;plsql-&quot;&gt;PL/SQL 语法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;DECALARE
		v_name user.name%TYPE := '&amp;amp;name';
		v_age user.age%TYPE := &amp;amp;age;
	BEGIN
		UPDATE user SET name = v_name, age = v_age WHERE uid = 1;
	END;

	DECLARE
		v_uid user.uid%TYPE := &amp;amp;id;
	BEGIN
		UPDATE user SET (name,age) = (
			SELECT name,age FROM user_tmp where uid_tmp = v_uid;
		) WHERE uid = v_uid;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;删除数据&lt;/h3&gt;

&lt;h4 id=&quot;sqlplus--1&quot;&gt;SQL*Plus 语法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;DELETE FROM &amp;lt;table|view&amp;gt; [WHERE &amp;lt;condition&amp;gt;];
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;plsql--1&quot;&gt;PL/SQL 语法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;	DECLARE
		v_uid user.uid%TYPE := &amp;amp;id;
	BEGIN
		DELETE FROM user WHERE uid = v_uid;
	END;

	DECLARE
		v_age user.age%TYPE := &amp;amp;age;
	BEGIN
		DELETE FROM user WHERE uid  in (
			SELECT tmp_uid FROM user_tmp WHERE age = v_age
		);
	END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sql&quot;&gt;SQL游标&lt;/h3&gt;

&lt;p&gt;执行 SELECT、INSERT、UPDATE、DELETE语句时，Oracle Service 会为这些SQL语句分配相应的上下文(Context Area).ORACLE使用上下文解析并执行SQL。而游标是指向上下文区的指针。&lt;/p&gt;

&lt;p&gt;ORACLE中，游标包括&lt;strong&gt;隐式游标&lt;/strong&gt;和&lt;strong&gt;显式游标&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;隐式游标&lt;/strong&gt;又被称作&lt;strong&gt;SQL游标&lt;/strong&gt;，专用于处理 SELECT，INTO，INSERT，UPDATE及DELETE语句；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;显式游标&lt;/strong&gt;则用于处理&lt;strong&gt;多行SELECT语句&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在PL/SQL块中执行INSERT,UPDATE,DELETE时，为了取得DML语句作用的结果，必须要使用SQL游标属性。&lt;/p&gt;

&lt;h4 id=&quot;sql-1&quot;&gt;SQL游标属性&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SQL%ISOPEN&lt;/strong&gt; 属性&lt;/p&gt;

    &lt;p&gt;该属性用于确定SQL游标是否已经打开。在PL/SQL块中执行SELECT INTO,INSERT,UPDATE及DELETE时，Oracle会隐含的打开游标，并且在执行完成后隐含的关闭游标。该属性在实际的开发过程中可以不用考虑。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SQL%FOUND&lt;/strong&gt; 属性&lt;/p&gt;

    &lt;p&gt;该属性用于确定SQL语句执行是否成功（是否有作用行）。当SQL语句有作用时，其属性为TRUE；否则为FALSE;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; DECLARE
 				v_uid user.uid%TYPE := &amp;amp;id;
 			BEGIN
 				UPDATE user SET age = 100
 				WHERE uid = v_uid;
 				IF SQL%FOUND THEN
 					dbms_output.put_line('语句执行成功');
 				ELSE
 					dbms_output.put_line('语句执行失败');
 				END IF;
 			END;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SQL%NOTFOUND&lt;/strong&gt; 属性&lt;/p&gt;

    &lt;p&gt;与 SQL%FOUND 属性相反。有作用行时为FALSE,无作用行时为TRUE;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; DECLARE
 				v_uid user.uid%TYPE := &amp;amp;id;
 			BEGIN
 				UPDATE user SET age = 100
 				WHERE uid = v_uid;
 				IF SQL%NOTFOUND THEN
 					dbms_output.put_line('用户表中不存在该用户');
 				ELSE
 					dbms_output.put_line('语句执行成功');
 				END IF;
 			END;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SQL%ROWCOUNT&lt;/strong&gt; 属性&lt;/p&gt;

    &lt;p&gt;该属性用户统计SQL语句的作用行数。如果没有作用行，则返回0;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; DECLARE
 				v_uid user.uid%TYPE := &amp;amp;id;
 			BEGIN
 				UPDATE user SET age = 100
 				WHERE uid = v_uid;
 				dbms_output.put_line('修改了'||SQL%ROWCOUNT||'行');
 			END;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-7&quot;&gt;事务控制&lt;/h2&gt;

&lt;p&gt;PL/SQL块中的事务同SQL*Plus直接使用事务语句COMMIT，ROLLBACK，SAVEPOINT。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;COMMIT :　提交事务&lt;/li&gt;
  &lt;li&gt;ROLLBACK :　回滚事务&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SAVEPOINT ：设置事务保存点&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  DECLARE
      v_uid user.uid%TYPE :=&amp;amp;id;
  BEGIN
      UPDATE SET age = 100 WHERE uid = v_uid;
  COMMIT;
  EXCEPTION
      WHEN OTHERS THEN
      ROLLBACK;
  END;

  BEGIN
      INSERT INTO user(name,age) VALUEs('name1',20);
      SAVEPOINT u1;
          INSERT INTO user(name,age) VALUEs('name2',30);
      SAVEPOINT u2;
          INSERT INTO user(name,age) VALUEs('name3',40);
      SAVEPOINT u3;
          ROLLBACK TO u2; //回滚到第二条SQL,实际插入两条数据
  COMMIT;
  END;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
      <pubDate>Sun, 30 Aug 2015 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2015/08/30/plsql-sql-use-sql-in-block</guid>
      <dc:date>2015-08-30T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>PL/SQL流程控制语言</title>
      <link>http://leeyee.github.io/blog/2015/08/30/plsql-control-statement</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;条件分支语句&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#if&quot;&gt;IF语句&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#case&quot;&gt;CASE语句&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;循环语句&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#loop-&quot;&gt;LOOP 循环&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#while-&quot;&gt;WHILE 循环&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#for-&quot;&gt;FOR 循环&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;嵌套循环和标号&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;顺序控制语句&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#goto-&quot;&gt;GOTO 语句&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#null-&quot;&gt;NULL 语句&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;条件分支语句&lt;/h2&gt;

&lt;h3 id=&quot;if&quot;&gt;IF语句&lt;/h3&gt;

&lt;p&gt;语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IF condition THEN
	statements;
[ELSIF condition THEN
	statements;]
[ELSE
	statements;]
END IF;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECLARE
	v_age NUMBER(3);
BEGIN
	SELECT age INTO v_age FROM user
	WHERE lower(name) = lower('&amp;amp;&amp;amp;name');
	IF v_age &amp;lt; 20 THEN
		UPDATE user SET age = v_age*2 WHERE lower(name) = lower('&amp;amp;&amp;amp;name');
	ELSEIF v_age &amp;lt; 40 THEN
	  UPDATE user SET age = v_age*3 WHERE lower(name) = lower('&amp;amp;&amp;amp;name');
	ELSE
		UPDATE user SET age = v_age/2 WHERE lower(name) = lower('&amp;amp;&amp;amp;name');
	END IF;
END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;case&quot;&gt;CASE语句&lt;/h3&gt;

&lt;p&gt;语法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;单一条件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; CASE selector
     WHEN expression1 THEN sequence_of_statements1;
     WHEN expression1 THEN sequence_of_statements2;
     ...
     WHEN expression1 THEN sequence_of_statementsN;
     [ELSE sequence_of_statementsN+1;]
 END CASE;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多条件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; CASE
     WHEN selector_condition1 THEN sequence_of_statements1;
     WHEN selector_condition2 THEN sequence_of_statements2;
     ...
     WHEN selector_conditionN THEN sequence_of_statementsN;
     [ELSE sequence_of_statementsN+1;]
 END CASE;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECLARE
	v_uid  user.uid%TYPE;
	BEGIN
		v_uid := &amp;amp;id;
		CASE v_uid
			WHEN 1 THEN UPDATE user SET age = 20 WHERE uid = v_uid;
			WHEN 2 THEN UPDATE user SET age = 40 WHERE uid = v_uid;
			ELSE
				dbms_out.put_line('不存在该用户');
		END CASE;
	END;

DECLARE
	v_uid  user.uid%TYPE;
	BEGIN
		v_uid := &amp;amp;id;
		CASE
			WHEN v_uid == 1 THEN UPDATE user SET age = 20 WHERE uid = v_uid;
			WHEN v_uid == 2 THEN UPDATE user SET age = 40 WHERE uid = v_uid;
			ELSE
				dbms_out.put_line('不存在该用户');
	END CASE;
END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;循环语句&lt;/h2&gt;

&lt;h3 id=&quot;loop-&quot;&gt;LOOP 循环&lt;/h3&gt;

&lt;p&gt;语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LOOP
	statement1;
	EXIT [WHEN condition];
END LOOP;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用该语句statement1至少会被执行一次。相当于do…while&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DELCARE
	i INT :=1;
	BEGIN
		LOOP
			UPDATE user SET createDate = SYSDATE WHERE uid = i;
			EXIT WHEN i = 10 ;
			i := i+1;
		END LOOP;
	COMMIT;
END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;while-&quot;&gt;WHILE 循环&lt;/h3&gt;

&lt;p&gt;语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WHILE condition LOOP
	statement1;
	statement2;
	...
END LOOP;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECLARE
	i INT := 1;
BEGIN
	WHILE i &amp;lt;= 10 LOOP
		UPDATE user SET createDate = SYSDATE WHERE uid = i;
		i := i+1;
	END LOOP;
COMMIT;
END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;for-&quot;&gt;FOR 循环&lt;/h3&gt;

&lt;p&gt;语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FOR counter IN [REVERSE]
	min_bound..upper_bound LOOP
	statement1;
	statement1;
	...
END LOOP;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;counter&lt;/em&gt; : 循环控制变量，由Oracle隐含定义，不需要显示定义；&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;min_bound&lt;/em&gt;、&lt;em&gt;upper_bound&lt;/em&gt; ：循环控制变量的上下界；&lt;/li&gt;
  &lt;li&gt;默认情况下FOR循环在每执行一次后，控制变量会自增一；如果指定&lt;strong&gt;REVERSE&lt;/strong&gt;选项，则会减一；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BEGIN
	FOR i IN 1..10 LOOP
		UPDATE user SET createDate = SYSDATE WHERE uid = i;
	END LOOP;
	COMMIT;
END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;嵌套循环和标号&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;-- 该示例中的&amp;lt;&amp;lt;waibu&amp;gt;&amp;gt;、&amp;lt;&amp;lt;neibu&amp;gt;&amp;gt;为标号，该名称可以自定义。
DECLARE
	result INT;
BEGIN
	&amp;lt;&amp;lt;waibu&amp;gt;&amp;gt;
	FOR i IN 1..10 LOOP
		&amp;lt;&amp;lt;neibu&amp;gt;&amp;gt;
		FOR j IN 1..10 LOOP
		    result := i * j;
			dbms_output.put_line(result);
			-- 当 result=10 时，退出外部循环，本例中是当i=5时退出。相当于调用break语句
			EXIT waibu WHEN result = 10; 
			-- 当 j = 2 时，退出内部循环。相当于调用break语句
			EXIT WHEN j = 2; 
		END LOOP neibu;
	END LOOP waibu;
		dbms_output.put_line(result);
	END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;顺序控制语句&lt;/h2&gt;

&lt;h3 id=&quot;goto-&quot;&gt;GOTO 语句&lt;/h3&gt;

&lt;p&gt;GOTO语句用于跳转到特定标号处。&lt;strong&gt;一般不建议使用&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;语法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GOTO label_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECLARE
	i INT := 1;
BEGIN
	LOOP
		IF i = 10 THEN
			GOTO jump_loop;
		END IF;
		EXIT WHEN i &amp;gt; 11;
		dbms_output.put_line('i--&amp;gt;'||i); -- 这条语句是不会被执行的！
		i := i+1;
	END LOOP;
	&amp;lt;&amp;lt;jump_loop&amp;gt;&amp;gt;
		dbms_output.put_line('i == 10 ! ');
END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;null-&quot;&gt;NULL 语句&lt;/h3&gt;

&lt;p&gt;NULL 语句不执行任何操作，并且直接将控制传递到下一条语句。使用NULL可以提高PL/SQL程序的可读性&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECLARE
	v_uid user.uid%TYPE := &amp;amp;di;
	v_age user.age%TYPE;
BEGIN
	SELECT age INTO v_age FROM user WHERE uid = v_uid;
	IF v_age &amp;lt; 20 THEN
		UPDATE user SET age = 100 WHERE uid = v_uid;
		commit;
	ELSE
		NULL;
	END IF;
END;
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Sun, 30 Aug 2015 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2015/08/30/plsql-control-statement</guid>
      <dc:date>2015-08-30T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>PL/SQL复合数据类型</title>
      <link>http://leeyee.github.io/blog/2015/08/30/plsql-complex-data-type</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#plsql&quot;&gt;PL/SQL记录&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#plsql-1&quot;&gt;自定义PL/SQL记录&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#rowtype&quot;&gt;使用%ROWTYPE属性定义记录变量&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;使用示例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#plsql-2&quot;&gt;PL/SQL集合&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#plsql-3&quot;&gt;索引表(PL/SQL表)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#nested-table&quot;&gt;嵌套表(Nested Table)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#varray&quot;&gt;变长数组(VARRAY)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#plsql-4&quot;&gt;PL/SQL记录表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;多级集合&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;集合方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;plsql&quot;&gt;PL/SQL记录&lt;/h2&gt;

&lt;p&gt;PL/SQL记录类似高级语句中的结构，用于处理&lt;strong&gt;单行多列&lt;/strong&gt;数据。&lt;/p&gt;

&lt;h3 id=&quot;plsql-1&quot;&gt;自定义PL/SQL记录&lt;/h3&gt;

&lt;p&gt;语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TYPE type_name IS RECORD(
	filed_declaration[,filed_declaration]...
);

indetifier type_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECALRE
	TYPE user_record_type IS RECORD(
		name user.name%TYPE,
		age user.age%TYPE
	);
	
	user_record user_type;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;rowtype&quot;&gt;使用%ROWTYPE属性定义记录变量&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;%ROWTYPE&lt;/strong&gt;属性可以&lt;strong&gt;基于表或视图&lt;/strong&gt;定义记录变量。使用该属性后，记录变量成员的名称和类型与表或视图的名称和类型完全相同。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user_record user%ROWTYPE;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;使用示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;set serveroutput on 
	DECLARE
		TYPE user_record_type IS RECORD(
			name user.name%TYPE,
			age user.age%TYPE
		);			
		user_record user_record_type;
		user_record1 user_record_type;
		user_record2 user%ROWTYPE;
		user_record3 user%ROWTYPE;
	BEGIN
		-- 在 SELECT INTO 语句中使用 PL/SQL 记录
		SELECT name,age into user_record
		FROM user where uid = 1;
		dbms_output.put_line(user_record.name);
		
		-- 在 SELECT INTO 语句中使用记录变量
		SELECT name into user_record1.name 
		FROM user where uid = 2;
		dbms_output.put_line(user_record1.name);
		
		user_record2.uid := 100;
		user_record2.name := 'name1';
		user_record2.age := 56;
		
		-- 在 VALUES 子句中使用记录变量(Oracle9i新特性)
		INSERT INTO user VALUES user_record2; 
		
		user_record3.name := user_record2.name;
		user_record3.age := user_record2.age;
		UPDATE user SET ROW = user_record3 WHERE uid = user_record2.uid;
	END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;plsql-2&quot;&gt;PL/SQL集合&lt;/h2&gt;

&lt;p&gt;PL/SQL集合&lt;strong&gt;相当于高级语言的数组&lt;/strong&gt;。用于&lt;strong&gt;存放多行单列数据&lt;/strong&gt;。PL/SQL集合包括&lt;em&gt;索引表&lt;/em&gt;(PL/SQL表)、&lt;em&gt;嵌套表&lt;/em&gt;(Nested Table)和&lt;em&gt;变长数组&lt;/em&gt;(VARRAY)等三种类型&lt;/p&gt;

&lt;h3 id=&quot;plsql-3&quot;&gt;索引表(PL/SQL表)&lt;/h3&gt;

&lt;p&gt;该类型数据为Oracle早期类型。索引表的元素个数没有限制，并且下标可以为负值。&lt;/p&gt;

&lt;p&gt;语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TYPE type_name IS TABLE OF element_type
[NOT NULL] INDEX BY key_type;
identifier type_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;type_name : 定义的索引表名称&lt;/li&gt;
  &lt;li&gt;element_type : 索引表中的元数据类型&lt;/li&gt;
  &lt;li&gt;NOT NULL : 可选项。索引表中的元素不能引用NULL元素&lt;/li&gt;
  &lt;li&gt;key_type ：索引表元素下标数据类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Oracle9i之前key_type只能为 BINARY_INTEGER 和 PLS_INTEGER;从Oracle9i开始key_type也可以使用VARCHAR2.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set serveroutput on 
	DECLARE
		TYPE name_table_type IS TABLE OF user.name%TYPE
			INDEX BY BINARY_INTEGER;
		names_table name_table_type;
		
		TYPE area_table_type IS TABLE OF NUMBER
			INDEX BY VARCHAR2(10);
		area_table area_table_type;
	BEGIN
		SELECT name INTO names_table(-1) FROM user
		WHERE uid = 1;
		dbms_output.put_line('姓名'||names_table(-1));
		
		area_table('北京') := 1;
		area_table('上海') := 2;
		area_table('天津') := 3;
		dbms_output.put_line('first-&amp;gt;'||area_table('北京')); -- 1
		dbms_output.put_line('second-&amp;gt;'||area_table('上海')); -- 2
		dbms_output.put_line('last-&amp;gt;'||area_table.last); -- 天津
		
	END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;nested-table&quot;&gt;嵌套表(Nested Table)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;嵌套表的&lt;strong&gt;元素下标从1开始&lt;/strong&gt;，元素&lt;strong&gt;个数没有限制&lt;/strong&gt;，同时其&lt;strong&gt;元素值可以是稀疏的&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;索引表不能作为表列属性，但嵌套表&lt;strong&gt;可以作为表列属性进行表列定义&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;使用嵌套表元素时，&lt;strong&gt;必须首先使用其构造方法初始化嵌套表&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TYPE type_name IS TABLE OF element_type;
identifier type_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECLARE
	TYPE name_table_type IS TABLE OF user.name%TYPE;
	name_table name_table_type := name_table_type('a','a'); -- 初始化嵌套表
BEGIN
	SELECT name INTO name_table(2) FROM user WHERE uid = 1;
	dbms_output.put_line('姓名:' || name_table(2));
END;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;当嵌套表类型当作表列的数据类型使用时，必须首先使用 CREATE TYPE 命令建立嵌套表，必须为嵌套表列指定专门的存储表。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TYPE phone_type IS TABLE OF VARCHAR2(20);
	
CREATE TABLE user (
	id NUMBER(3),name VARCHAR2(10),salary NUMBER(6,2),phone phone_type
) NESTED TABLE phone STORE AS phone_type;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为嵌套表插入数据&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; BEGIN 
     INSERT INTO user VALUES(1,'leeyee',800,phone_type('13800000000','13912345678'));
 END;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;检索嵌套表数据&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set serveroutput on
 DECLARE
     phone_table phone_type;
 BEGIN
     SELECT phone INTO phone_table FROM user WHERE id = 1 ;
     FOR i IN 1..phone_table.COUNT LOOP
         dbms_output.put_line('电话号码:'||phone_table(i));
     end LOOP;
 END;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;更新嵌套表数据&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; DECLARE
     phone_table phone_type := phone_type('15900001111','15896543219','13345678923');
 BEGIN
     UPDATE user SET phone = phone_table WHERE id = 1;
 END;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;varray&quot;&gt;变长数组(VARRAY)&lt;/h3&gt;

&lt;p&gt;PL/SQL 数组数据类型，可作为&lt;strong&gt;表列数据类型&lt;/strong&gt;使用。该数据类型与高级语言&lt;strong&gt;数组&lt;/strong&gt;类似，元素&lt;strong&gt;下标从1开始&lt;/strong&gt;，并且元素&lt;strong&gt;最大个数有限&lt;/strong&gt;。当使用VARRAY是，应首先进行&lt;strong&gt;初始化&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TYPE type_name IS VARRAY(size) OF element_type [NOT NULL]
indentifier type_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;type_name : 变长数组类型名&lt;/li&gt;
  &lt;li&gt;size : 数组最大元素个数&lt;/li&gt;
  &lt;li&gt;element_type ：数组元素数据类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECLARE
	TYPE user_varray_type IS VARRAY(20) OF user.name%TYPE;
	user_varray user_varray_type := user_varray_type('oxcow','leeyee'); -- 初始化 VARRAY
BEGIN
	SELECT name INTO user_varray(1) FROM user WHERE uid = 1 ;
	dbms_output.put_line('姓名' || user_varray(1));
END;
-- 表列属性
-- 创建表列属性
CREATE TYPE phone_type IS VARRAY(20) OF VARCHAR2(20);
CREATE TABLE user(
	id NUMBER(3),name VARCHAR2(20),phone phone_type
);
-- 插入、检索及更新同嵌套表
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;plsql-4&quot;&gt;PL/SQL记录表&lt;/h3&gt;

&lt;p&gt;PL/SQL记录表用来&lt;strong&gt;存储多行多列数据&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECLARE
	TYPE user_table_type IS TABLE OF user%ROWTYPE
		INDEX BY BINNARY_INTEGER;
	user_table user_table_type;
BEGIN
	SELECT * INTO user_table(1) FROM user WHERE uid = 1;
	SELECT * INTO user_table(2) FROM user WHERE uid = 2;
	dbms_output.put_line('姓名: ' || user_table(1).name);
	dbms_output.put_line('姓名: ' || user_table(2).name);
END;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;多级集合&lt;/h3&gt;

&lt;p&gt;多级集合是指&lt;strong&gt;嵌套了集合类型的集合类型&lt;/strong&gt;。通过使用多级集合，可以在PL/SQL中实现类似于&lt;strong&gt;多维数组&lt;/strong&gt;的功能。&lt;em&gt;(Oracle9i以后可以使用)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- 在块中使用多级 VARRAY
-- 定义VARRAY(10,10)
DECLARE
	-- 定义一维VARRAY
	TYPE al_varray_type IS VARRAY(10) OF INT;
	-- 定义二维VARRAY
	TYPE nal_varray_type IS VARRAY(10) OF al_varray_type;
	-- 初始化二维集合变量
	nvl_array nal_array_type := nal_varray_type(
		al_varray_type(58,100,12),
		al_varray_type(432,43,211),
		al_varray_type(2,4)
	);
BEGIN
	dbms_output.put_line('显示二维数组所有元素');
	FOR i in 1..nvl_array.COUNT LOOP
		FOR j in 1..nvl_array(i).COUNT LOOP
		    dbms_output.put_line('nvl_array('||i||','||j||')='||nvl_array(i)(j));
		END LOOP;
	END LOOP;
END;
	
-- 在块中使用多级嵌套表
DECLARE
	-- 定义一维嵌套表
	TYPE al_table_type IS TABLE OF INT;
	-- 定义二维嵌套表
	TYPE nal_table_type IS TABLE OF al_table_type;
	-- 初始化二维集合变量
	nvl_table nal_table_type := nal_table_type(
		al_table_type(58,100,12),
		al_table_type(432,43,211),
		al_table_type(2,4)
	);
	
--  在块中使用多级索引表
DECLARE
	-- 定义一维table
	TYPE al_table_type IS TABLE OF INT INDEX BY BINARY_INTEGER;
	-- 定义二维table
	TYPE nal_table_type IS TABLE OF al_table_type INDEX BY BINARY_INTEGER;
	-- 初始化二维集合变量
	nvl_table nal_table_type;
	nvl_table(1)(1) := 2;
	nvl_table(1)(2) := 3;
	nvl_table(2)(1) := 4;
	nvl_table(2)(2) := 25;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;集合方法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;EXISTS&lt;br /&gt;
 该方法用来&lt;strong&gt;确定集合元素是否存在&lt;/strong&gt;。如果存在返回TRUE，否则返回FALSE&lt;/li&gt;
  &lt;li&gt;COUNT&lt;br /&gt;
 该方法返回当前&lt;strong&gt;集合变量中的元素总个数&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;LIMIT&lt;br /&gt;
 该方法返回&lt;strong&gt;当前集合元素的最大个数&lt;/strong&gt;。对于嵌套表和索引表，由于其个数没有限制，则在使用该方法时会返回NULL。&lt;/li&gt;
  &lt;li&gt;FIRST 和 LAST&lt;br /&gt;
 FIRST 方法&lt;strong&gt;返回集合变量第一个元素的下标&lt;/strong&gt;；&lt;br /&gt;
 LAST 方法&lt;strong&gt;返回集合变量的最后一个元素下标&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;PRIOR 和 NEXT	&lt;br /&gt;
 PRIOR 方法&lt;strong&gt;返回当前集合元素的前一个元素的下标&lt;/strong&gt;；&lt;br /&gt;
 NEXT 方法&lt;strong&gt;返回当前集合元素的后一个元素下标&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;EXTEND&lt;br /&gt;
 该方法用来&lt;strong&gt;扩展集合变量的尺寸&lt;/strong&gt;，并为他们&lt;strong&gt;增加元素&lt;/strong&gt;。该方法&lt;strong&gt;只适用于嵌套表和VARRAY&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;EXTEND : 为集合变量添加一个NULL元素&lt;/li&gt;
      &lt;li&gt;EXTEND(n) : 为集合变量添加n个NULL元素&lt;/li&gt;
      &lt;li&gt;EXTEND(n,i) : 为集合变量添加n个元素，元素值与第i个元素相同&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TRIM&lt;br /&gt;
 该方法从集合尾部删除元素。该方法&lt;strong&gt;只适应于嵌套表和VARRAY&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;TRIM : 从尾部删除一个元素&lt;/li&gt;
      &lt;li&gt;TRIM(n) : 从尾部删除n个元素&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DELETE&lt;br /&gt;
 该方法用于删除集合元素。该方法&lt;strong&gt;只适用于嵌套表和索引表&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;DELETE : 删除集合变量中的所有元素&lt;/li&gt;
      &lt;li&gt;DELETE(n) : 删除集合变量的第n个元素&lt;/li&gt;
      &lt;li&gt;DELETE(n,m) : 删除集合变量从第n个到第m个的所有元素&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DECLARE
	TYPE name_table_type IS TABLE OF user.name%TYPE;
	name_type name_table_type;
BEGIN
	IF name_type.EXISTS(1）THEN
		name_type(1) := 'leeyee';
	ELSE
		dbms_output_line(&quot;必须初始化集合元素&quot;);
	END IF;
END;
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Sun, 30 Aug 2015 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2015/08/30/plsql-complex-data-type</guid>
      <dc:date>2015-08-30T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>windows下Git命令组的实现</title>
      <link>http://leeyee.github.io/blog/2015/08/11/git-cmdgroup</link>
      <description>
&lt;p&gt;使用git进行项目版本管理时，在实际的操作中经常会有使用多个命令完成一个操作的情况出现，比如常见的代码远程更新操作可能就包含以下几个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;保存当前工作区。&lt;a href=&quot;http://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%EF%BC%88Stashing%EF%BC%89&quot;&gt;&lt;code&gt;git stash&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;拉取远程分支代码到本地。&lt;a href=&quot;http://git-scm.com/docs/git-pull&quot;&gt;&lt;code&gt;git pull --rebase&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;恢复当前工作区。&lt;code&gt;git stash pop&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么有没有办法可以使用一个自定义命令一次完成上述三个命令的执行？&lt;/p&gt;

&lt;p&gt;其实要完成上述命令组很简单，我们只要完成一个包含这几条命令的脚本文件即可。linux环境下我们可以直接自定一个shell脚本，比如下面的形式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;#!/bin/sh

git stash
git pull --rebase
git stash pop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，针对windows系统，处理方式是相同，只不过是完成bat脚本。当然了，一般开发过程中使用的都是&lt;a href=&quot;https://msysgit.github.io/&quot;&gt;Git-preview&lt;/a&gt;,为了可以直接在这个工具下使用自定义命令组，可以进行如下配置：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先新建一个没有后缀的文件，这里我们叫 &lt;em&gt;mypull&lt;/em&gt;，内容如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #!/bin/sh
 # Copyright (C) 2015, leeyee
 # mailto:seadlead@gmail.com
 # 实现以下命令组
 # git stash
 # git pull --rebase
 # git stash pop
 # File: mypull
 echo '---- excute git stash ----'
 git stash

 echo '---- excute git pull --rebase ----'
 git pull --rebase

 echo '---- git stash pop ----'
 git stash pop
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将该文件放到&lt;a href=&quot;https://msysgit.github.io/&quot;&gt;Git-preview&lt;/a&gt;安装路径下的 &lt;em&gt;bin&lt;/em&gt; 目录中即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;此时就可以直接在 git bash 使用命令 &lt;code&gt;mypull&lt;/code&gt; 了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
      <pubDate>Tue, 11 Aug 2015 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2015/08/11/git-cmdgroup</guid>
      <dc:date>2015-08-11T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>awk多文件处理</title>
      <link>http://leeyee.github.io/blog/2015/08/02/awk-muli-file</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;基本语法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;两文件处理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;两文件以上处理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在日常的开发中，我们经常会针对不同的需要将程序中的日志进行分类存储，但在运维或者异常处理需要查看的时候，又不得不针对多个日志文件进行联合处理。甚至有些时候需要进行日志关联查询。那么这种情况下，一般的 &lt;em&gt;linux&lt;/em&gt; 命令，比如 &lt;em&gt;grep&lt;/em&gt; 等就显得功能不够强大了。此时我们可以使用 &lt;em&gt;awk&lt;/em&gt; 进行多文件处理，同时借助其语法可以很方便的实现文件内容关联查询，完成类似 &lt;em&gt;sql&lt;/em&gt; 式的关联查询。&lt;/p&gt;

&lt;p&gt;首先我们还是先定义下我们在该篇文章中演示的待处理文件. 我们定义两个文件，一个是学生信息 &lt;em&gt;s.log&lt;/em&gt; 内容如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;sid tid name age address&lt;br /&gt;
1 1 张三 18 北京朝阳&lt;br /&gt;
2 1 李四 19 北京西城&lt;br /&gt;
3 2 马六 17 北京海淀&lt;br /&gt;
4 2 王五 17 北京昌平&lt;br /&gt;
5 3 唐七 18 北京西城&lt;br /&gt;
6 1 徐六 16 北京朝阳&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另一个是老师信息 &lt;em&gt;t.log&lt;/em&gt; 内容如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;tid name age subject&lt;br /&gt;
1 张正	35	数学&lt;br /&gt;
2 聂磊	40	语文&lt;br /&gt;
3 黄明	42	物理&lt;br /&gt;
4 吴立	23	体育&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;基本语法&lt;/h3&gt;

&lt;p&gt;当我们使用awk读取多文件时，可以有以下两种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;模糊匹配。形式如下：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;awk ‘{…}’ *.log&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;直接指定需要读取的文件。形式如下：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;awk ‘{…}’  file1…fileN&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;针对第一种方式，&lt;em&gt;awk&lt;/em&gt; 会一次读取所有能匹配到的所有文件；而第二种是则是依次处理指定的文件。对应两种方式的处理流程都是&lt;strong&gt;先处理完成一个文件后在接着处理另一个文件&lt;/strong&gt;。比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;awk 'FNR &amp;gt; 1 {print $1,$2,$3,$4}' s.log t.log
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;1 1 张三 18&lt;br /&gt;
2 1 李四 19&lt;br /&gt;
3 2 马六 17&lt;br /&gt;
4 2 王五 17&lt;br /&gt;
5 3 唐七 18&lt;br /&gt;
6 1 徐六 16&lt;br /&gt;
1 张正 35 数学&lt;br /&gt;
2 聂磊 40 语文&lt;br /&gt;
3 黄明 42 物理&lt;br /&gt;
4 吴立 23 体育&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不过以上方式只是简单的将多个文件输出，那么当我们需要在一个命令中针对不同的文件进行一些差异化的处理时该如何操作呢？&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;两文件处理&lt;/h3&gt;

&lt;p&gt;一般的这对两个文件的常规处理方式有以下两种：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;awk ‘NR==FNR{…} NR&amp;gt;FNR{…}’ file1 file2&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;或者&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;awk ‘NR==FNR{…} NR!=FRN{…}’ file1 file2&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;或者&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;awk ‘NR==FNR{…;next}{…}’ file1 file2&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中 &lt;em&gt;NR&lt;/em&gt; 参数代表当前读取文件的总行数，而 &lt;em&gt;FNR&lt;/em&gt; 参数代表当前读取文件的行数。所以当读取第一个文件时，总是有 &lt;em&gt;NR==FNR&lt;/em&gt;。而当读取第二个文件时，总是有 &lt;em&gt;NR&amp;gt;FNR&lt;/em&gt; 或者 &lt;em&gt;NR!=FNR&lt;/em&gt;，因为 &lt;em&gt;FNR&lt;/em&gt; 重新开始计数了！&lt;/p&gt;

&lt;p&gt;下面我们来看下具体的示例。假设我们需要查询学生表中学号为1的学生和教师表中年纪等于23岁的老师，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;awk 'NR==FNR {if($1==1)print $0} NR&amp;gt;FNR {if($3==23)print $0}' s.log t.log
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;1 1 张三 18 北京朝阳&lt;br /&gt;
4 吴立  23      体育&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在我们需要复杂一点的数据，比如我们需要查询学生信息中关联的老师信息，并展示在一行，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;awk 'NR==FNR {a[$1]=$0} NR!=FNR {if(FNR&amp;gt;1)print $0,a[$2] }' t.log s.log
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;1 1 张三 18 北京朝阳 1 张正     35      数学&lt;br /&gt;
2 1 李四 19 北京西城 1 张正     35      数学&lt;br /&gt;
3 2 马六 17 北京海淀 2 聂磊     40      语文&lt;br /&gt;
4 2 王五 17 北京昌平 2 聂磊     40      语文&lt;br /&gt;
5 3 唐七 18 北京西城 3 黄明     42      物理&lt;br /&gt;
6 1 徐六 16 北京朝阳 1 张正     35      数学&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里让 &lt;em&gt;awk&lt;/em&gt; 在处理第一个文件 t.log 时，将老师的信息通过其主键保存在变量 &lt;em&gt;a&lt;/em&gt; 中，&lt;em&gt;a&lt;/em&gt; 类似一个 map。当 &lt;em&gt;awk&lt;/em&gt; 在处理第二个文件 s.log 时，通过 s.log 的第二个字段，学生对应老师的主键作 key 从数据 &lt;em&gt;a&lt;/em&gt; 中获取存储的值进行展示。通过这种方式就完成了日志字段的关联查询。其核心还是通过先将第一个文件的值通过需要关联的key进行存储，而在进行第二个文件解析的时候再通过相关关联主键查询出来。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;两文件以上处理&lt;/h3&gt;

&lt;p&gt;上面只是针对两个文件的处理，那么如果我们要处理的文件超过2个时该如何处理呢？&lt;/p&gt;

&lt;p&gt;那么此时我们就需要用到参数 &lt;em&gt;ARGIND&lt;/em&gt; 了，&lt;em&gt;ARGIND&lt;/em&gt; 用来记录当前正在处理文件参数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;awk ‘ARGIND==1 {…} ARGIND==2 {…} ARGIND==3 {…} … ‘ file1 file2 file3 …fileN&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;或者使用命令行参数数组 &lt;em&gt;ARGV&lt;/em&gt;，&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;awk ‘FILENAME==ARGV[1] {…} FILENAME==ARGV[2] {…} FILENAME==ARGV[3] {…} … ‘ file1 file2 file3 …fileN&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;或者直接使用文件名的方式&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;awk ‘FILENAME==”file1”{…} FILENAME==”file2” {…} FILENAME==”file3” {…} … ‘ file1 file2 file3 …fileN&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;进行多文件处理。下面我们展示一个对应多文件的简单例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;awk 'ARGIND==1 {if(FNR&amp;gt;3)print FNR,$3 } ARGIND==2 {if(FNR&amp;gt;1)print FNR,$2} ARGIND==3 {if(FNR&amp;lt;3)print FNR,$NF}' s.log t.log s.log
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;4 马六&lt;br /&gt;
5 王五&lt;br /&gt;
6 唐七&lt;br /&gt;
7 徐六&lt;br /&gt;
2 张正&lt;br /&gt;
3 聂磊&lt;br /&gt;
4 黄明&lt;br /&gt;
5 吴立&lt;br /&gt;
1 address&lt;br /&gt;
2 北京朝阳&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;针对 &lt;em&gt;awk&lt;/em&gt; 多文件的处理其实不需要额外的新知识学习，只需要掌握以上两文件及其以上文件的处理模板语句就行。在实际的应用中直接套用模板语句即可。语法上每一个文件块的处理按找单文件 &lt;em&gt;awk&lt;/em&gt; 的处理方式处理即可。&lt;/p&gt;
</description>
      <pubDate>Sun, 02 Aug 2015 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2015/08/02/awk-muli-file</guid>
      <dc:date>2015-08-02T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>awk 入门</title>
      <link>http://leeyee.github.io/blog/2015/07/28/awk-base-get-start</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;常用命令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#tab&quot;&gt;1. 使用默认分割符（空格或者TAB）分割.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#f-&quot;&gt;2. 使用 &lt;strong&gt;-F&lt;/strong&gt; 指定分割符&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#v-&quot;&gt;3.  使用 &lt;strong&gt;-v&lt;/strong&gt; 设置变量&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#f-awk&quot;&gt;4. 使用 &lt;strong&gt;-f&lt;/strong&gt; 读取awk脚本&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;基本运算符&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;运算符说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;举例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;内置变量&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;变量说明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;举例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Awk&quot;&gt;awk&lt;/a&gt;是一款强大的文本分析工具。&lt;a href=&quot;https://zh.wikipedia.org/wiki/Awk&quot;&gt;awk&lt;/a&gt; 按行解析数据，并对其进行分割处理。下面是一些&lt;a href=&quot;https://zh.wikipedia.org/wiki/Awk&quot;&gt;awk&lt;/a&gt;的入门语法与示例。&lt;/p&gt;

&lt;p&gt;首先我们使用以下的文件片段演示。文件片段&lt;sup id=&quot;fnref:pome&quot;&gt;&lt;a href=&quot;#fn:pome&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;内容如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Lost Love&lt;br /&gt;
William Wordsworth&lt;br /&gt;
She dwelt among the untrodden ways beside the springs of dove.&lt;br /&gt;
A maid whom there were none to praise, and very few to love.&lt;br /&gt;
A violet by a mossy stone, half hidden from the eye!&lt;br /&gt;
Fair as a star, when only one is shining in the sky.&lt;br /&gt;
She lived unknown, and few could know, when lucy ceased to be.&lt;br /&gt;
But she is in her grave, and oh, the difference to me!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;常用命令&lt;/h2&gt;

&lt;h3 id=&quot;tab&quot;&gt;1. 使用默认分割符（空格或者TAB）分割.&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;awk '{print NR,$1}' test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1 The&lt;br /&gt;
2 William&lt;br /&gt;
3 She&lt;br /&gt;
4 A&lt;br /&gt;
5 A&lt;br /&gt;
6 Fair&lt;br /&gt;
7 She&lt;br /&gt;
8 But&lt;/p&gt;
&lt;/blockquote&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/dt&gt;
  &lt;dd&gt;&lt;em&gt;print&lt;/em&gt;：  输出，没有指定输出连接符时，默认为空格；&lt;/dd&gt;
  &lt;dd&gt;&lt;em&gt;NR&lt;/em&gt;： &lt;a href=&quot;https://zh.wikipedia.org/wiki/Awk&quot;&gt;awk&lt;/a&gt;内建变量, 表示当前记录数；&lt;/dd&gt;
  &lt;dd&gt;&lt;em&gt;$n&lt;/em&gt;： 根据空格或者TAB分割后的第n个字符串，从1开始。特殊的  &lt;strong&gt;$0&lt;/strong&gt; 表示所有未被分割的行；&lt;/dd&gt;
&lt;/dl&gt;

&lt;h3 id=&quot;f-&quot;&gt;2. 使用 &lt;strong&gt;-F&lt;/strong&gt; 指定分割符&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;awk -F, 'BEGIN{OFS=&quot;.&quot;} {print NR,$1} END{print &quot;-- End --&quot;}' test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.The Lost Love&lt;br /&gt;
2.William Wordsworth&lt;br /&gt;
3.She dwelt among the untrodden ways beside the springs of dove.&lt;br /&gt;
4.A maid whom there were none to praise&lt;br /&gt;
5.A violet by a mossy stone&lt;br /&gt;
6.Fair as a star&lt;br /&gt;
7.She lived unknown&lt;br /&gt;
8.But she is in her grave
– End –&lt;/p&gt;
&lt;/blockquote&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;&lt;em&gt;-F&lt;/em&gt;: 指定分割字符。如果有多个分割符可使用 &lt;code&gt;-F '[ ,]'&lt;/code&gt;;&lt;/p&gt;
  &lt;/dd&gt;
  &lt;dd&gt;&lt;em&gt;-F&lt;/em&gt;: 相当于&lt;a href=&quot;https://zh.wikipedia.org/wiki/Awk&quot;&gt;awk&lt;/a&gt;内置变量 &lt;em&gt;FS&lt;/em&gt; .示例语句可与下面的命令进行替换

    &lt;pre&gt;&lt;code&gt;  awk 'BEGIN{FS=&quot;,&quot;} {print NR,$2}' test.txt
&lt;/code&gt;&lt;/pre&gt;
  &lt;/dd&gt;
  &lt;dd&gt;
    &lt;p&gt;&lt;em&gt;BEGIN&lt;/em&gt;: 语法片段，表示解析开始时的处理逻辑;&lt;/p&gt;
  &lt;/dd&gt;
  &lt;dd&gt;&lt;em&gt;END&lt;/em&gt;: 语法片段，表示解析完成后的处理逻辑;&lt;/dd&gt;
  &lt;dd&gt;&lt;em&gt;OFS&lt;/em&gt;: 内置函数，表示输出使用的分割符。默认为空格&lt;/dd&gt;
&lt;/dl&gt;

&lt;h3 id=&quot;v-&quot;&gt;3.  使用 &lt;strong&gt;-v&lt;/strong&gt; 设置变量&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;awk -va=' end' -vb=1 '{print NR+1,$1a}' test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2 The end&lt;br /&gt;
3 William end&lt;br /&gt;
4 She end&lt;br /&gt;
5 A end&lt;br /&gt;
6 A end&lt;br /&gt;
7 Fair end&lt;br /&gt;
8 She end&lt;br /&gt;
9 But end&lt;/p&gt;
&lt;/blockquote&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;&lt;em&gt;-v&lt;/em&gt;： 指定变量名，可以有多个；&lt;/p&gt;
  &lt;/dd&gt;
  &lt;dd&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Awk&quot;&gt;awk&lt;/a&gt;字符串连接使用 &lt;strong&gt;.&lt;/strong&gt; 、空格或者直接进行连接即可（&lt;code&gt;$1a &lt;/code&gt;等价于&lt;code&gt;$1.a&lt;/code&gt;等价于 &lt;code&gt;$1  a&lt;/code&gt;）；数字类型直接使用 &lt;strong&gt;+&lt;/strong&gt; ;&lt;/dd&gt;
&lt;/dl&gt;

&lt;h3 id=&quot;f-awk&quot;&gt;4. 使用 &lt;strong&gt;-f&lt;/strong&gt; 读取awk脚本&lt;/h3&gt;

&lt;p&gt;当查询条件比较复杂时，可以将查询的复杂语句写入单独的文件进行维护，这样能专注于查询逻辑的处理，也易于维护。 然后使用  &lt;em&gt;-f&lt;/em&gt; 参数对语句脚本进行读取。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; awk -f a.awk test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;a.awk 文件内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;BEGIN {
	a = &quot; end&quot;
	b = 1
}
{
	print NR+1,$1a
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2 The end&lt;br /&gt;
3 William end&lt;br /&gt;
4 She end&lt;br /&gt;
5 A end&lt;br /&gt;
6 A end&lt;br /&gt;
7 Fair end&lt;br /&gt;
8 She end&lt;br /&gt;
9 But end&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基本运算符&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;运算符说明&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;运算符&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;= += -= *= /= %= ^= **=&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;赋值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;?:&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;条件表达式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;||&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;逻辑或&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;逻辑与&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;~ ~!&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;匹配正则表达式和不匹配正则表达式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;lt; &amp;lt;= &amp;gt; &amp;gt;= != ==&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;关系运算符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;空格&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+ -&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;加，减&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;* / &amp;amp;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;乘，除与求余&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+ - !&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;一元加，减和逻辑非&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;^ ***&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;求幂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;++ –&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;增加或减少，作为前缀或后缀&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;字段引用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;in&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;数组成员&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-3&quot;&gt;举例&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;获取第四行及第五行以后的行&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; awk '(NR&amp;gt;5 || NR==4) {print NR,$0}' test.txt
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;输出：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;4 A maid whom there were none to praise, and very few to love.&lt;br /&gt;
6 Fair as a star, when only one is shining in the sky.&lt;br /&gt;
7 She lived unknown, and few could know, when lucy ceased to be.&lt;br /&gt;
8 But she is in her grave, and oh, the difference to me!&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取按空格分割后第一个分组为‘She’并且第二不分组不等于‘dwelt’的行&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; awk '($1==&quot;She&quot; &amp;amp;&amp;amp; $2 !=&quot;dwelt&quot;) {print NR,$0}' test.txt
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;输出：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;7 She lived unknown, and few could know, when lucy ceased to be.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-4&quot;&gt;内置变量&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;变量说明&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$n&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;当前记录的第n个字段，字段间由FS分隔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;$0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;完整的输入记录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ARGC&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;命令行参数的数目&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ARGIND&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;命令行中当前文件的位置(从0开始算)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ARGV&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;包含命令行参数的数组&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CONVFMT&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ERRNO&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;最后一个系统错误的描述&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FIELDWIDTHS&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;字段宽度列表(用空格键分隔)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FILENAME&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;当前文件名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FNR&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;同NR，但相对于当前文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FS&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;字段分隔符(默认是任何空格)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IGNORECASE&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;如果为真，则进行忽略大小写的匹配&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NF&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;当前记录中的字段数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NR&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;当前记录数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OFMT&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;数字的输出格式(默认值是%.6g)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OFS&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;输出字段分隔符(默认值是一个空格)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ORS&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;输出记录分隔符(默认值是一个换行符)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RLENGTH&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;由match函数所匹配的字符串的长度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RS&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;记录分隔符(默认是一个换行符)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RSTART&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;由match函数所匹配的字符串的第一个位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SUBSEP&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;数组下标分隔符(默认值是/034)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-6&quot;&gt;举例&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;显示相关内置参数&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; awk '{print FILENAME,ARGC,FNR,FS,NF,NR,OFS} BEGIN{OFS=&quot;:&quot;}' test.txt
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;输出：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;test.txt:2:1: :3:1::&lt;br /&gt;
test.txt:2:2: :2:2::&lt;br /&gt;
test.txt:2:3: :11:3::&lt;br /&gt;
test.txt:2:4: :13:4::&lt;br /&gt;
test.txt:2:5: :11:5::&lt;br /&gt;
test.txt:2:6: :12:6::&lt;br /&gt;
test.txt:2:7: :12:7::&lt;br /&gt;
test.txt:2:8: :12:8::&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:pome&quot;&gt;
      &lt;p&gt;来自【英】威廉·华兹华斯&lt;a href=&quot;http://www.douban.com/note/233616298/&quot;&gt;《失去的爱》&lt;/a&gt; &lt;a href=&quot;#fnref:pome&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
      <pubDate>Tue, 28 Jul 2015 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2015/07/28/awk-base-get-start</guid>
      <dc:date>2015-07-28T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>使用DateFormat需设置语言环境</title>
      <link>http://leeyee.github.io/blog/2014/05/19/java-dateformat-instance</link>
      <description>
&lt;p&gt;先看段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String sDate = &quot;2014-12-20&quot;;
try {
    DateFormat df = DateFormat.getDateInstance();
    Date date = df.parse(sDate);
} catch (Exception e) {
    e.printStackTrace();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码在中文语言环境下是可以测试通过。但在其他语言环境中则会抛出异常。原因是&lt;code&gt;DateFormat.getDateInstance()&lt;/code&gt;初始化时会跟据当前语言环境设置日期格式。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;DateFormat.getDateInstance()&lt;/code&gt; 根据当前语言环境设置日期模式：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; zh_CN : yyyy-MM-dd : 2014-05-19
 en_us : MMM d, yyyy : May 19, 2014
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;DateFormat.getDateInstance(int style)&lt;/code&gt; 根据当前语言环境设置指定的日期模式：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; // Locale.SIMPLIFIED_CHINESE | Locale.CHINA | Locale.CHINESE

 // DateFormat.DEFAULT == DateFormat.MEDIUM
 DateFormat.getDateInstance(DateFormat.DEFAULT); // yyyy-M-d
 DateFormat.getDateInstance(DateFormat.FULL);// yyyy'年'M'月'd'日' EEEE
 DateFormat.getDateInstance(DateFormat.LONG);// yyyy'年'M'月'd'日'
 DateFormat.getDateInstance(DateFormat.MEDIUM);// yyyy-M-d
 DateFormat.getDateInstance(DateFormat.SHORT);// yy-M-d


 // Locale.US
 DateFormat.getDateInstance(DateFormat.DEFAULT, Locale.CHINESE); // MMM d, yyyy
 DateFormat.getDateInstance(DateFormat.LONG);// MMMM d, yyyy
 DateFormat.getDateInstance(DateFormat.SHORT);// M/d/yy
 DateFormat.getDateInstance(DateFormat.MEDIUM);// MMM d, yyyy
 DateFormat.getDateInstance(DateFormat.FULL);// EEEE, MMMM d, yyyy
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;DateFormat.getDateInstance(int style, Locale aLocale)&lt;/code&gt; 指定语言环境及相应日期模式&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; DateFormat.getDateInstance(DateFormat.DEFAULT, Locale.CHINESE);

 // 上述代码等价于
 Locale.setDefault(Locale.CHINESE);
 DateFormat.getDateInstance(DateFormat.DEFAULT)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此，在使用&lt;code&gt;DateFormat&lt;/code&gt;时，尽量不要使用无参的&lt;code&gt;getDateInstance()&lt;/code&gt;方法，因其依赖具体的环境，有可能会造成不同环境运行异常的情况。如果确实不知道具体的语言环境极其格式模式的，那么使用&lt;code&gt;SimpleDateFormat&lt;/code&gt;直接指定日期格式即可.这样可以避免因不同语言环境导致的日期格式错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String sDate = &quot;2014-12-20&quot;;
try {
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
    Date date = sdf.parse(sDate);
} catch (Exception e) {
    e.printStackTrace();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Mon, 19 May 2014 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2014/05/19/java-dateformat-instance</guid>
      <dc:date>2014-05-19T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>git快速入门</title>
      <link>http://leeyee.github.io/blog/2013/11/27/git-quick-start</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;约定&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#git&quot;&gt;场景一：【本地建立GIT版本管理并添加文件】&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#step-1&quot;&gt;step-1、创建项目根目录&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-2&quot;&gt;step-2、进入目录并初始版本管理&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-3gitproject&quot;&gt;step-3、添加文件到目录gitProject&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-4&quot;&gt;step-4、查看当前版本仓库状态&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-5helloworldjava&quot;&gt;step-5、将HelloWorld.java添加到版本管理中&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-6&quot;&gt;step-6、再次查看版本仓库状态&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-7helloworldjava&quot;&gt;step-7、提交HelloWorld.java到版本库&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-8helloworldjava&quot;&gt;step-8、为HelloWorld.java添加内容&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-9helloworldjava&quot;&gt;step-9、查看当前HelloWorld.java文件与提交的版本库中的差异&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-10helloworldjava&quot;&gt;step-10、提交修改后的HelloWorld.java到版本库&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-11&quot;&gt;step-11、查看操作日志&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;场景二：【建立分支并合并分支】&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#step-1git-gitpro--hellogitjava-&quot;&gt;step-1、使用场景一的命令创建Git项目 gitPro ，并添加文件 HelloGit.java 文件。&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-2-1&quot;&gt;step-2、查看当前分支列表&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-3developdevelop&quot;&gt;step-3、创建develop分支，并且切换到develop分支&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-4-hellogitjava--readme&quot;&gt;step-4、修改 HelloGit.java 并添加 readme文件。&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-5helloworldjavareadme&quot;&gt;step-5、查看HelloWorld.java、readme文件的状态并提交&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-6-master-&quot;&gt;step-6、切换到 master 分支&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-7-master--develop-&quot;&gt;step-7、查看 master 分支和 develop 分支的不同，并合并&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-8-hellogitjava&quot;&gt;step-8、处理冲突文件 HelloGit.java&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-9&quot;&gt;step-9、取消合并，返回到最后一次提交时的版本&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;场景三：【连接远程服务器】&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;准备工作：&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-1git&quot;&gt;step-1、连接到远程服务器GIT空间&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-2-2&quot;&gt;step-2、推送本地版本信息至服务器&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-3&quot;&gt;step-3、修改本地文件，提交并推送到服务器&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-4-1&quot;&gt;step-4、从服务器获取文件&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;场景四：【创建删除发布版本并推送至服务器】&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#step-1-1&quot;&gt;step-1、查看当前发布版本&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-2-3&quot;&gt;step-2、创建新的发布版本在本地仓库&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-3-v10beta-&quot;&gt;step-3、推送 v1.0beta 至服务器&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-4-2&quot;&gt;step-4、删除本地仓库发布版本&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-5&quot;&gt;step-5、删除远程服务器发布版本&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;场景五：【还原已经删除的文件】&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#step-1-2&quot;&gt;step-1、查看当前删除的文件&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-2-4&quot;&gt;step-2、恢复被删除的文件（单个恢复）&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#step-2-1&quot;&gt;step-2-1、全部恢复&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;约定&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;这只是一个简单的快速入门，如果您已经精通，请绕行;&lt;/li&gt;
  &lt;li&gt;这里我们不会讲GIT、SVN、VSS及CVS的区别。如有需要，请&lt;a href=&quot;http://google.com&quot; title=&quot;谷歌&quot;&gt;Google&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;这里不具体讲解GIT COMMAND的具体含义。如有需要，请git help;&lt;/li&gt;
  &lt;li&gt;这里不讲解GIT如何在windows及Linux下的配置。如有需要，请在&lt;a href=&quot;http://github.com&quot; title=&quot;GitHub 主页&quot;&gt;http://github.com&lt;/a&gt;上寻找&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们这里模拟几种场景，以便您快速上手.&lt;/p&gt;

&lt;h3 id=&quot;git&quot;&gt;场景一：【本地建立GIT版本管理并添加文件】&lt;/h3&gt;

&lt;h4 id=&quot;step-1&quot;&gt;step-1、创建项目根目录&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir gitProject
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-2&quot;&gt;step-2、进入目录并初始版本管理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ cd gitProject
$ git init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git init&lt;/code&gt;后，将在 gitProject目录下生成 .git隐藏文件。可使用 &lt;code&gt;ls -a&lt;/code&gt; 进行查看&lt;/p&gt;

&lt;h4 id=&quot;step-3gitproject&quot;&gt;step-3、添加文件到目录gitProject&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ touch HelloWorld.java
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-4&quot;&gt;step-4、查看当前版本仓库状态&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git status     # 这里应该会显示HelloWorld.java为untracked files,也就是尚未进行版本管理
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-5helloworldjava&quot;&gt;step-5、将HelloWorld.java添加到版本管理中&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git add HelloWorld.java
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-6&quot;&gt;step-6、再次查看版本仓库状态&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git status     # 此时将会显示HelloWorld为一个new file，需要提交到版本库中
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-7helloworldjava&quot;&gt;step-7、提交HelloWorld.java到版本库&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git commit HelloWorld.java
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-8helloworldjava&quot;&gt;step-8、为HelloWorld.java添加内容&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ vi HelloWorld.java
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-9helloworldjava&quot;&gt;step-9、查看当前HelloWorld.java文件与提交的版本库中的差异&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git diff
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-10helloworldjava&quot;&gt;step-10、提交修改后的HelloWorld.java到版本库&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -m 'init import' HelloWorld.java
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-11&quot;&gt;step-11、查看操作日志&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;补充知识&lt;/em&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在 step-5 时，如何对使用了[git add]的文件反操作呢？&lt;/p&gt;

    &lt;p&gt;你可以使用命令 &lt;code&gt;git rm --cached HelloWorld.java&lt;/code&gt; 这样就可以将已经在版本管理中的文件解除版本控制了。&lt;br /&gt;
你也可以使用 &lt;code&gt;git reset HEAD HelloWorld.java&lt;/code&gt; 解除版本控制，但使用 &lt;code&gt;git reset&lt;/code&gt; 命令时，目标文件应没有使用过 &lt;code&gt;git commit&lt;/code&gt;，否则该命令将不起作用;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 step-5、step-8 时，如何批量添加和提交？&lt;/p&gt;

    &lt;p&gt;你可以使用命令 &lt;code&gt;git add *.java&lt;/code&gt; 使用通配符添加。或者 &lt;code&gt;git add .&lt;/code&gt;添加当前目录下的所有文件。
&lt;code&gt;git add .&lt;/code&gt;等价于 &lt;code&gt;git add *&lt;/code&gt;。对于 &lt;code&gt;git commit&lt;/code&gt; 同样可以使用通配看符添加。同时 &lt;code&gt;git commit&lt;/code&gt; 只会操作那些使用过 &lt;code&gt;git add&lt;/code&gt; 的文件;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 step-9 时，当你修改了文件但没有使用 &lt;code&gt;git commit&lt;/code&gt; 时，你想取消当前修改到最近一次提交？&lt;/p&gt;

    &lt;p&gt;你可以使用以下命令&lt;code&gt;git checkout -- HelloWorld.java&lt;/code&gt;;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 step-10 时，当 &lt;code&gt;git commit -m &amp;lt;msg&amp;gt;&lt;/code&gt; 后，如果修改提交时的内容？比如修改 ‘init import’为 ‘初始提交’?&lt;/p&gt;

    &lt;p&gt;你可以使用命令 &lt;code&gt;git commit --amend&lt;/code&gt; 或者使用 &lt;code&gt;git reset --soft HEAD&lt;/code&gt;，其中：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;HEAD: 为当前提交版本&lt;/li&gt;
      &lt;li&gt;HEAD^:为HEAD的父亲版本；&lt;/li&gt;
      &lt;li&gt;HEAD~2: 为HEAD的父亲的父亲版本 ….&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;code&gt;git commit -m '初始提交' HelloWorld.java&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;场景二：【建立分支并合并分支】&lt;/h3&gt;

&lt;h4 id=&quot;step-1git-gitpro--hellogitjava-&quot;&gt;step-1、使用场景一的命令创建Git项目 gitPro ，并添加文件 HelloGit.java 文件。&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;HelloGit.java文件内容如下：
public class HelloGit{
    public static void main(String []args){
        System.out.println(&quot;Say Hello Git from master branch&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-2-1&quot;&gt;step-2、查看当前分支列表&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git branch  # git init 后默认的分支名为master.因此如果没有建立过分支，那么使用[git branch]将显示分支master
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-3developdevelop&quot;&gt;step-3、创建develop分支，并且切换到develop分支&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git branch develop
$ git checkout develop
# 以上两句命令可用 [ $ git checkout -b develop]替代
# 如果需要删除分支可用 [ $ git branch -d develop]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-4-hellogitjava--readme&quot;&gt;step-4、修改 HelloGit.java 并添加 readme文件。&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ vi HelloGit.java
$ touch readme
$ git add readme
$ vi readme
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改后HelloGit.java的内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class HelloGit{
    public void developSayHello(){
        System.out.println(&quot;Say Hello Git from develop branch&quot;);
    }
    public static void main(String []args){
        HelloGit hg = new HelloGit();
        hg.developSayHello();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;readme文件内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this readme file is created by develop
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-5helloworldjavareadme&quot;&gt;step-5、查看HelloWorld.java、readme文件的状态并提交&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git status
$ git commit HelloWorld.java
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-6-master-&quot;&gt;step-6、切换到 master 分支&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-7-master--develop-&quot;&gt;step-7、查看 master 分支和 develop 分支的不同，并合并&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git diff master develop
$ git merge --no-ff develop  # 可以使用 [ $ git reset --hard ORIG_HEAD] 取消合并
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-8-hellogitjava&quot;&gt;step-8、处理冲突文件 HelloGit.java&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ vi HelloGit.java
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改后的文件内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class HelloGit{
    public void developSayHello(){
        System.out.println(&quot;Say Hello Git from develop branch&quot;);
    }
    public static void main(String []args){
        System.out.println(&quot;Say Hello Git from master branch&quot;);
        HelloGit hg = new HelloGit();
        hg.developSayHello();
    }
}

$ git add HelloGit.java
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如有多个冲突文件，重复以上命令即可。最后提交合并后的文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-9&quot;&gt;step-9、取消合并，返回到最后一次提交时的版本&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git reset --hard ORIG_HEAD  # 可查看帮助手册了解 --hard|--soft|--mixed 当前区别
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;场景三：【连接远程服务器】&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;准备工作：&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;申请GitHub账户并登录&lt;/li&gt;
  &lt;li&gt;配置相关KEY。具体可查看GitHub官方说明&lt;/li&gt;
  &lt;li&gt;新建Repositories，名为Test-Git&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;step-1git&quot;&gt;step-1、连接到远程服务器GIT空间&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git remote add origin git@github.com:oxcow/Test-Git.git  # 实际使用中请使用自己的地址
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-2-2&quot;&gt;step-2、推送本地版本信息至服务器&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git push -u origin master     # 如果本地还有分支需要存放到服务器，那么可继续执行该命令
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-3&quot;&gt;step-3、修改本地文件，提交并推送到服务器&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ vi HelloWorld.java     # 编辑一些内容...
$ git commit -m 'add some contentext' HelloWorld.java
$ git push origin master     # 更新本地修改后的文件到服务器
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-4-1&quot;&gt;step-4、从服务器获取文件&lt;/h4&gt;

&lt;p&gt;首先我们在github.com/Test-Git上修改我们前面上传的文件HelloWorld.java并提交。本地获取可用以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git pull origin master     # [git pull]命令将会直接用服务器上的版本覆盖本地版本，请慎用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch --all     # 获取服务器文件到本地，但不覆盖本地文件
$ git meger     origin/master     # 合并服务器主干到本地分支
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;场景四：【创建删除发布版本并推送至服务器】&lt;/h3&gt;

&lt;h4 id=&quot;step-1-1&quot;&gt;step-1、查看当前发布版本&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git tag
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-2-3&quot;&gt;step-2、创建新的发布版本在本地仓库&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git tag v1.0beta
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-3-v10beta-&quot;&gt;step-3、推送 v1.0beta 至服务器&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git push -u origin v1.0.beta     #推送成功后可在github的tag标签出看到打包后的文件。有两种格式,zip和tar
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-4-2&quot;&gt;step-4、删除本地仓库发布版本&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git tag -d v1.0beta
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-5&quot;&gt;step-5、删除远程服务器发布版本&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin v1.0beta --delete
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;场景五：【还原已经删除的文件】&lt;/h3&gt;

&lt;h4 id=&quot;step-1-2&quot;&gt;step-1、查看当前删除的文件&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git ls-files -d
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-2-4&quot;&gt;step-2、恢复被删除的文件（单个恢复）&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout &amp;lt;filename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;step-2-1&quot;&gt;step-2-1、全部恢复&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git ls-files -d | xargs git checkout
&lt;/code&gt;&lt;/pre&gt;

</description>
      <pubDate>Wed, 27 Nov 2013 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2013/11/27/git-quick-start</guid>
      <dc:date>2013-11-27T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>mybatis自增主键配置</title>
      <link>http://leeyee.github.io/blog/2013/08/22/mybatis-auto-increment-primary-key</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;不返回自增主键值&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;插入后获取自增主键值&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;mybatis进行插入操作时，如果表的主键是自增的，针对不同的数据库相应的操作也不同。基本上经常会遇到的就是 Oracle Sequece 和  Mysql 自增主键，至于其他的手动生成唯一主键的问题在这里就不讨论了，这里主要说明下在mybatis中对于自增主键的配置。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;不返回自增主键值&lt;/h2&gt;

&lt;p&gt;如果考虑到插入数据的主键不作为其他表插入数据的外键使用，那么可以考虑使用这种方式。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Oracle Sequence 配置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;sql id='TABLE_NAME'&amp;gt;TEST_USER&amp;lt;/sql&amp;gt;
 &amp;lt;sql id='TABLE_SEQUENCE'&amp;gt;SEQ_TEST_USER_ID.nextval&amp;lt;/sql&amp;gt;

 &amp;lt;!-- 注意这里直接调用sequence的nextval函数 --&amp;gt;
 &amp;lt;insert id=&quot;insert&quot; parameterType=&quot;User&quot;&amp;gt;
     insert into &amp;lt;include refid=&quot;TABLE_NAME&quot; /&amp;gt; (ID,NAME,AGE)
         values ( &amp;lt;include refid=&quot;TABLE_SEQUENCE&quot; /&amp;gt; ,#{name}, #{age} )
 &amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;当插入语句如上配置时，那么针对如下语句&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; User user = new User();
 user.setName(&quot;test&quot;);
 user.setAge(24);

 userMapper.insert(user);
 System.out.println(user.id); // user.id 为空
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;code&gt;user.id&lt;/code&gt;为空，也就是说如上的配置并不能在完成插入操作后将插入时的主键值存放到保存的对象中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mysql自增主键配置&lt;/p&gt;

    &lt;p&gt;由于mysql数据库中，可以设置表的主键为自增，所以对于Mysql数据库在mybatis配置插入语句时，不指定插入ID字段即可。主键的自增交由Mysql来管理。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;sql id='TABLE_NAME'&amp;gt;TEST_USER&amp;lt;/sql&amp;gt;
   
 &amp;lt;!-- 注意这里的插入SQL中是没有指明ID字段的！ --&amp;gt;
 &amp;lt;insert id=&quot;insert&quot; parameterType=&quot;User&quot;&amp;gt;
     insert into &amp;lt;include refid=&quot;TABLE_NAME&quot; /&amp;gt; (NAME,AGE)
 	        values (#{name}, #{age} )
 &amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;同样，针对Mysql如此配置mybaits，插入完成后&lt;code&gt;user.id&lt;/code&gt;为空。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;插入后获取自增主键值&lt;/h2&gt;

&lt;p&gt;上述的情况能满足大部分情况，但有时候我们会遇到类似一对多的那种表结构，在插入多端数据时，需要获取刚刚保存了的一段的主键。那么这个时候，上述的配置就无法满足需要了。为此我们需要使用mybatis提供的&lt;code&gt;&amp;lt;selectKey /&amp;gt;&lt;/code&gt;来单独配置针对自增逐渐的处理。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Oracle Sequence 配置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;sql id='TABLE_NAME'&amp;gt;TEST_USER&amp;lt;/sql&amp;gt;
 &amp;lt;sql id='TABLE_SEQUENCE'&amp;gt;SEQ_TEST_USER_ID.nextval&amp;lt;/sql&amp;gt;

 &amp;lt;!-- 注意这里需要先查询自增主键值 --&amp;gt;
 &amp;lt;insert id=&quot;insert&quot; parameterType=&quot;User&quot;&amp;gt;
     &amp;lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&amp;gt;
 		    select &amp;lt;include refid=&quot;TABLE_SEQUENCE&quot; /&amp;gt; from dual
     &amp;lt;/selectKey&amp;gt;
     insert into &amp;lt;include refid=&quot;TABLE_NAME&quot; /&amp;gt; (ID,NAME,AGE)
 	        values ( #{id}, #{name}, #{age} )
 &amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;当使用了&lt;code&gt;&amp;lt;selectKey /&amp;gt;&lt;/code&gt;后，在实际的插入操作时，mybatis会执行以下两句SQL:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; select SEQ_TEST_USER_ID.nextval from dual; // 语句1
 insert into (ID,NAME,AGE) values ( ?, ?, ? ); // 语句2
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在执行插入 &lt;em&gt;语句2&lt;/em&gt; 之前，会先执行 &lt;em&gt;语句1&lt;/em&gt; 以获取当前的ID值，然后mybatis使用反射调用&lt;code&gt;User&lt;/code&gt;对象的&lt;code&gt;setId&lt;/code&gt;方法，将 &lt;em&gt;语句1&lt;/em&gt; 查询出的值保存在&lt;code&gt;User&lt;/code&gt;对象中，然后才执行 &lt;em&gt;语句2&lt;/em&gt; 这样就保证了执行完插入后&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; User user = new User();
 user.setName(&quot;test&quot;);
 user.setAge(24);

 userMapper.insert(user);
 System.out.println(user.id); // user.id 不为空
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;code&gt;user.id&lt;/code&gt;是有值的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mysql自增主键配置&lt;/p&gt;

    &lt;p&gt;针对于Mysql这种自己维护主键的数据库，可以直接使用以下配置在插入后获取插入主键，&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;sql id='TABLE_NAME'&amp;gt;TEST_USER&amp;lt;/sql&amp;gt;

 &amp;lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; parameterType=&quot;User&quot;&amp;gt;
     insert into &amp;lt;include refid=&quot;TABLE_NAME&quot; /&amp;gt; ( NAME, AGE )
         values ( #{name}, #{age} )
 &amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;当然，由于Mysql的自增主键可以通过SQL语句&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; select LAST_INSERT_ID();
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;来获取的。因此针对Mysql，Mybatis也可配置如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;sql id='TABLE_NAME'&amp;gt;TEST_USER&amp;lt;/sql&amp;gt;

 &amp;lt;!-- 注意这里需要先查询自增主键值 --&amp;gt;
 &amp;lt;insert id=&quot;insert&quot; parameterType=&quot;User&quot;&amp;gt;
     &amp;lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&amp;gt;
 	    SELECT LAST_INSERT_ID()
     &amp;lt;/selectKey&amp;gt;
     insert into &amp;lt;include refid=&quot;TABLE_NAME&quot; /&amp;gt; (ID,NAME,AGE)
 	    	values ( #{id}, #{name}, #{age} )
 &amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;只不过该中配置需要额外的一条查询SQL!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;小结&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当数据插入操作不关心插入后数据的主键（唯一标识），那么建议使用 &lt;em&gt;不返回自增主键值&lt;/em&gt; 的方式来配置插入语句，这样可以&lt;strong&gt;避免额外的SQL开销&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当执行插入操作后需要立即获取插入的自增主键值，比如一次操作中保存一对多这种关系的数据，那么就要使用 &lt;em&gt;插入后获取自增主键值&lt;/em&gt; 的方式配置.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
      <pubDate>Thu, 22 Aug 2013 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2013/08/22/mybatis-auto-increment-primary-key</guid>
      <dc:date>2013-08-22T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>javascript身份证号码验证</title>
      <link>http://leeyee.github.io/blog/2013/07/31/javascript-idcard-validate</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;15位身份证号码编码规则&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;18位身份证号码编码规则&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;校验规则&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#javascript&quot;&gt;javascript编码实现&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;源代码&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;验证示例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;15位身份证号码编码规则&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ddddddyymmddxxp
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;dddddd: 地区码&lt;/li&gt;
  &lt;li&gt;yymmdd: 出生年月日&lt;/li&gt;
  &lt;li&gt;xx: 顺序类编码，无法确定&lt;/li&gt;
  &lt;li&gt;p: 性别。奇数位男，偶数为女&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;18位身份证号码编码规则&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ddddddyyyymmddxxxy
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;dddddd: 地区码&lt;/li&gt;
  &lt;li&gt;yyyymmdd: 出生年月日&lt;/li&gt;
  &lt;li&gt;xxx：顺序类编码，无法确定。奇数为男，偶数为女&lt;/li&gt;
  &lt;li&gt;y: 校验位。可通过前17位计算获取&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;校验规则&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;加权因子&lt;strong&gt;W&lt;sub&gt;i&lt;/sub&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;从右到左依次定义为：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;W&lt;sub&gt;i&lt;/sub&gt; = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2, 1]&lt;/strong&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;校验位值&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;Y = [ 1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2 ]&lt;/strong&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;其中 &lt;em&gt;10&lt;/em&gt; 身份证中用 &lt;em&gt;X&lt;/em&gt; 替代。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;校验位位置&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;Y_P = mod(Σ(A&lt;sub&gt;i&lt;/sub&gt;+W&lt;sub&gt;i&lt;/sub&gt;),11)&lt;/strong&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;其中下标 &lt;strong&gt;i&lt;/strong&gt; 为身份证号码 &lt;strong&gt;从右往左&lt;/strong&gt; 的 2…8 位;  &lt;strong&gt;A&lt;sub&gt;i&lt;/sub&gt;&lt;/strong&gt;为身份证号对应位数值。&lt;/p&gt;

    &lt;p&gt;该公式表示将身份证的前17位与其对应的加权因子 &lt;strong&gt;W&lt;sub&gt;i&lt;/sub&gt;&lt;/strong&gt; 相乘并求和，再将得到的结果与 11 求模，所得的结果即为校验位值所在的位置。然后直接在校验位值 &lt;strong&gt;Y&lt;/strong&gt; 中查找即可得到校验位值.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;比如有一为 &lt;em&gt;330304197002051590&lt;/em&gt; 的身份证号，那么最后一位校验位 &lt;strong&gt;0&lt;/strong&gt; 的验证过程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;加权求和&lt;/p&gt;

    &lt;p&gt;3×7 + 3×9 + 0×10 + 3×5 + 0×8 + 4×4 + 1×2 + 9×1 + 7×6 + 0×3 + 0×7 + 2×9 + 0×10 + 5×5 + 1×8 + 5×4 + 9×2  = &lt;strong&gt;221&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;求模&lt;/p&gt;

    &lt;p&gt;221 % 11 = 1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取验证位数值&lt;/p&gt;

    &lt;p&gt;Y[1] = 0&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;javascript&quot;&gt;javascript编码实现&lt;/h2&gt;

&lt;p&gt;针对上述身份证生成规则的描述，在验证时针对15位身份证号只需要判断其出生日期是否正确即可；而针对18位身份证号，除了验证出生日期外还需要对最后的校验位进行验证。&lt;/p&gt;

&lt;p&gt;因此我们命名一个名为&lt;code&gt;getIdCardInfo&lt;/code&gt;的函数，接受身份证号作为参数进行验证。该函数返回身份证信息对象。该对象具有5个属性，分别为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;isTrue : 身份证号是否有效。默认为 false&lt;/li&gt;
    &lt;li&gt;year : 出生年。默认为null&lt;/li&gt;
    &lt;li&gt;month : 出生月。默认为null&lt;/li&gt;
    &lt;li&gt;day : 出生日。默认为null&lt;/li&gt;
    &lt;li&gt;isMale : 是否为男性。默认false&lt;/li&gt;
    &lt;li&gt;isFemale : 是否为女性。默认false&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;源代码&lt;/h3&gt;

&lt;p&gt;您可进入&lt;a href=&quot;https://github.com/oxcow/id-number-validator&quot;&gt;该项目的GitHub页&lt;/a&gt;进行下载或贡献&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getIdCardInfo(cardNo) {
	var info = {
		isTrue : false,
		year : null,
		month : null,
		day : null,
		isMale : false,
		isFemale : false
	};
	if (!cardNo || (15 != cardNo.length &amp;amp;&amp;amp; 18 != cardNo.length) ) {
		info.isTrue = false;
		return info;
	}
	if (15 == cardNo.length) {
		var year = cardNo.substring(6, 8);
		var month = cardNo.substring(8, 10);
		var day = cardNo.substring(10, 12);
		var p = cardNo.substring(14, 15); //性别位
		var birthday = new Date(year, parseFloat(month) - 1,
				parseFloat(day));
		// 对于老身份证中的年龄则不需考虑千年虫问题而使用getYear()方法  
		if (birthday.getYear() != parseFloat(year)
				|| birthday.getMonth() != parseFloat(month) - 1
				|| birthday.getDate() != parseFloat(day)) {
			info.isTrue = false;
		} else {
			info.isTrue = true;
			info.year = birthday.getFullYear();
			info.month = birthday.getMonth() + 1;
			info.day = birthday.getDate();
			if (p % 2 == 0) {
				info.isFemale = true;
				info.isMale = false;
			} else {
				info.isFemale = false;
				info.isMale = true
			}
		}
		return info;
	}
	if (18 == cardNo.length) {
		var year = cardNo.substring(6, 10);
		var month = cardNo.substring(10, 12);
		var day = cardNo.substring(12, 14);
		var p = cardNo.substring(14, 17)
		var birthday = new Date(year, parseFloat(month) - 1,
				parseFloat(day));
		// 这里用getFullYear()获取年份，避免千年虫问题
		if (birthday.getFullYear() != parseFloat(year)
				|| birthday.getMonth() != parseFloat(month) - 1
				|| birthday.getDate() != parseFloat(day)) {
			info.isTrue = false;
			return info;
		}
		var Wi = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2, 1 ];// 加权因子  
		var Y = [ 1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2 ];// 身份证验证位值.10代表X 
		// 验证校验位
		var sum = 0; // 声明加权求和变量
		var _cardNo = cardNo.split(&quot;&quot;);

		if (_cardNo[17].toLowerCase() == 'x') {
			_cardNo[17] = 10;// 将最后位为x的验证码替换为10方便后续操作  
		}
		for ( var i = 0; i &amp;lt; 17; i++) {
			sum += Wi[i] * _cardNo[i];// 加权求和  
		}
		var i = sum % 11;// 得到验证码所位置

		if (_cardNo[17] != Y[i]) {
			return info.isTrue = false;
		}
		info.isTrue = true;
		info.year = birthday.getFullYear();
		info.month = birthday.getMonth() + 1;
		info.day = birthday.getDate();
		if (p % 2 == 0) {
			info.isFemale = true;
			info.isMale = false;
		} else {
			info.isFemale = false;
			info.isMale = true
		}
		return info;
	}
	return info;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    function getIdCardInfo(cardNo) {
		var info = {
			isTrue : false,
			year : null,
			month : null,
			day : null,
			isMale : false,
			isFemale : false
		};
		if (!cardNo &amp;&amp; 15 != cardNo.length &amp;&amp; 18 != cardNo.length) {
			info.isTrue = false;
			return info;
		}
		if (15 == cardNo.length) {
			var year = cardNo.substring(6, 8);
			var month = cardNo.substring(8, 10);
			var day = cardNo.substring(10, 12);
			var p = cardNo.substring(14, 15); //性别位
			var birthday = new Date(year, parseFloat(month) - 1,
					parseFloat(day));
			// 对于老身份证中的年龄则不需考虑千年虫问题而使用getYear()方法  
			if (birthday.getYear() != parseFloat(year)
					|| birthday.getMonth() != parseFloat(month) - 1
					|| birthday.getDate() != parseFloat(day)) {
				info.isTrue = false;
			} else {
				info.isTrue = true;
				info.year = birthday.getFullYear();
				info.month = birthday.getMonth() + 1;
				info.day = birthday.getDate();
				if (p % 2 == 0) {
					info.isFemale = true;
					info.isMale = false;
				} else {
					info.isFemale = false;
					info.isMale = true
				}
			}
			return info;
		}
		if (18 == cardNo.length) {
			var year = cardNo.substring(6, 10);
			var month = cardNo.substring(10, 12);
			var day = cardNo.substring(12, 14);
			var p = cardNo.substring(14, 17)
			var birthday = new Date(year, parseFloat(month) - 1,
					parseFloat(day));
			// 这里用getFullYear()获取年份，避免千年虫问题
			if (birthday.getFullYear() != parseFloat(year)
					|| birthday.getMonth() != parseFloat(month) - 1
					|| birthday.getDate() != parseFloat(day)) {
				info.isTrue = false;
				return info;
			}
			var Wi = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2, 1 ];// 加权因子  
			var Y = [ 1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2 ];// 身份证验证位值.10代表X 
			// 验证校验位
			var sum = 0; // 声明加权求和变量
			var _cardNo = cardNo.split(&quot;&quot;);

			if (_cardNo[17].toLowerCase() == 'x') {
				_cardNo[17] = 10;// 将最后位为x的验证码替换为10方便后续操作  
			}
			for ( var i = 0; i &lt; 17; i++) {
				sum += Wi[i] * _cardNo[i];// 加权求和  
			}
			var i = sum % 11;// 得到验证码所位置

			if (_cardNo[17] != Y[i]) {
				return info.isTrue = false;
			}
			info.isTrue = true;
			info.year = birthday.getFullYear();
			info.month = birthday.getMonth() + 1;
			info.day = birthday.getDate();
			if (p % 2 == 0) {
				info.isFemale = true;
				info.isMale = false;
			} else {
				info.isFemale = false;
				info.isMale = true
			}
			return info;
		}
		return info;
	}
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    function validateNo(){
        var cardNo = document.getElementById('cardNo').value;
        var cardInfo = getIdCardInfo(cardNo);
        var showInfo = '';
        if(cardInfo.isTrue){
             showInfo = '&lt;span class=&quot;text-success&quot;&gt;验证通过！&lt;/span&gt;';
             if(cardInfo.isMale){
                showInfo += '&lt;span class=&quot;text-info&quot;&gt;男,生于	' + cardInfo.year + '.' + cardInfo.month + '.' + cardInfo.day + '&lt;/span&gt;';
             }
             if(cardInfo.isFemale){
                showInfo += '&lt;span class=&quot;text-info&quot;&gt;女,生于	' + cardInfo.year + '.' + cardInfo.month + '.' + cardInfo.day + '&lt;/span&gt;';
             }
        }else{
            showInfo = '&lt;span class=&quot;text-error&quot;&gt;号码无效！&lt;/span&gt;';
        }
        document.getElementById('cardInfo').innerHTML = showInfo;
    }
&lt;/script&gt;

&lt;h3 id=&quot;section-4&quot;&gt;验证示例&lt;/h3&gt;

&lt;div class=&quot;row-fluid&quot;&gt;
	&lt;div class=&quot;input-append&quot;&gt;
  		&lt;input id=&quot;cardNo&quot; type=&quot;text&quot; placeholder=&quot;请输入身份证号码...&quot; /&gt;
  		&lt;button class=&quot;btn&quot; type=&quot;button&quot; onclick=&quot;validateNo();&quot;&gt;验证&lt;/button&gt;
	&lt;/div&gt;
	&lt;div id=&quot;cardInfo&quot; style=&quot;margin-left:20px;display:inline&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
      <pubDate>Wed, 31 Jul 2013 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2013/07/31/javascript-idcard-validate</guid>
      <dc:date>2013-07-31T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>Hibernate缓存</title>
      <link>http://leeyee.github.io/blog/2013/07/07/hibernate-cache</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;持久化层缓存的范围&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;事务范围&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;进程范围&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;群集范围&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;持久化层缓存的并发访问策略&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;事务型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;读写型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot;&gt;非严格读写型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot;&gt;只读型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-9&quot;&gt;应用场景&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#hibernate&quot;&gt;Hibernate一级缓存&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#hibernate-1&quot;&gt;Hibernate二级缓存&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-10&quot;&gt;二级缓存的开启&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#hibernate-2&quot;&gt;Hibernate查询缓存&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-11&quot;&gt;查询缓存的配置&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-12&quot;&gt;与缓存有关的注解&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#entity&quot;&gt;@Entity&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cache&quot;&gt;@Cache&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-13&quot;&gt;缓存实体&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-14&quot;&gt;缓存集合&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-15&quot;&gt;比较完整的例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hibernate中实现缓存的对象有&lt;code&gt;Session&lt;/code&gt;和&lt;code&gt;SessionFactory&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Session&lt;/code&gt;的缓存为内置缓存，不可被卸载，称为Hibernate的一级缓存；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SessionFactory&lt;/code&gt;有一个内置缓存和一个外置缓存。其中外置缓存可插拔，被称作Hibernate的二级缓存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;  Hibernate的这两级缓存均位于&lt;strong&gt;持久化层&lt;/strong&gt;，存放的都是数据库数据的拷贝。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;持久化层缓存的范围&lt;/h2&gt;

&lt;p&gt;持久化层缓存的范围可分为三类：事务范围、进程范围及群集范围。&lt;/p&gt;

&lt;p&gt;事务范围的缓存是持久化层的第一级缓存，通常是必须的；进程范围或群集范围的缓存是持久化层的第二级缓存，通常是可选的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于是否应用群集范围的缓存应慎重考虑，因为有时它未必能提高应用性能。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;事务范围&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;缓存只能被当前事务访问。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其生命周期依赖于事务的生命周期，事务结束，缓存也就结束；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缓存的物理介质为内存；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这里的事务是数据库事务或应用事务。每个事务都有其独自的缓存，缓存内的数据通常采用相互关联的对象形式。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;进程范围&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;缓存被进程内的所有事务共享。这些事物可并发访问混存，因此需要相应的事务隔离机制；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其生命周期依赖于进程的生命周期；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缓存的介质为内存或者硬盘；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缓存内的数据既可采用相互关联的对象形式，也可采用对对象的散装数据形式，散装数据形式类似对象的序列化。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-3&quot;&gt;群集范围&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;缓存被同一个机器或多个机器上的多个进程共享；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缓存被复制到群集环境中的每个进程节点，进程之间通过远程通讯保证缓存中的数据一致；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缓存中的数据通常采用对象的散装数据形式。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-4&quot;&gt;持久化层缓存的并发访问策略&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;事务型&lt;/h3&gt;

&lt;p&gt;仅在受管理环境中使用。提供&lt;strong&gt;可重复读&lt;a href=&quot;/blog/2013/07/04/database-transaction-concurrency/&quot; title=&quot;数据库事务与并发&quot;&gt;事务隔离级别&lt;/a&gt;&lt;/strong&gt; 。可用于经常读但很少被修改的数据，因为他&lt;strong&gt;可防止脏读和不可重复读&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;读写型&lt;/h3&gt;

&lt;p&gt;提供&lt;strong&gt;读已提交数据&lt;a href=&quot;/blog/2013/07/04/database-transaction-concurrency/&quot; title=&quot;数据库事务与并发&quot;&gt;事务隔离级别&lt;/a&gt;&lt;/strong&gt;。仅在非群集环境中适用，可用于经常度但很少被修改的数据，因为他&lt;strong&gt;可防止读脏数据&lt;/strong&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;非严格读写型&lt;/h3&gt;

&lt;p&gt;不保证缓存与数据库中数据的一致性。如果存在两个事务同时访问缓存中相同的数据，必须为该数据配置一个很短的过期时间，避免脏读。对于允许偶尔脏读的数据，可以采用该策略。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;只读型&lt;/h3&gt;

&lt;p&gt;可用于从来不会被修改的数据，如参考数据等。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;应用场景&lt;/h3&gt;

&lt;p&gt;事务型并发访问策略的&lt;a href=&quot;/blog/2013/07/04/database-transaction-concurrency/&quot; title=&quot;数据库事务与并发&quot;&gt;事务隔离级别&lt;/a&gt;最高，只读型最低。&lt;strong&gt;隔离级别越低，并发性能越好&lt;/strong&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;一般符合以下条件的数据才适合存放在二级缓存中：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;很少被修改的数据；&lt;/li&gt;
      &lt;li&gt;不是很重要的数据，允许出现偶尔的并发问；&lt;/li&gt;
      &lt;li&gt;不会被并发访问的数据；&lt;/li&gt;
      &lt;li&gt;参考数据（常量数据）。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;其中，参考数据具有以下特点：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;实例数目有限；&lt;/li&gt;
      &lt;li&gt;每个实例会被许多其他类的实例引用；&lt;/li&gt;
      &lt;li&gt;实例极少或者从来不被修改。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不适合存放于二级缓存中的数据&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;经常被修改的数据；&lt;/li&gt;
      &lt;li&gt;财务数据，绝对不允许出现并发问题；&lt;/li&gt;
      &lt;li&gt;与其他应用共享的数据。因为当使用Hibernate二级缓存与其他应用共享数据库的某种数据时，如果其他应用修改了数据中的数据，Hibernate将无法保证二级缓存中的数据与数据库保持一致。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;hibernate&quot;&gt;Hibernate一级缓存&lt;/h2&gt;

&lt;p&gt;Hibernate一级缓存中存放的数据是数据库中数据的拷贝，其表现为相互关联的实体对象。&lt;code&gt;Session&lt;/code&gt;会在某些时间点按照缓存中的数据来同步更新数据库，这一个过程称作清理缓存。&lt;/p&gt;

&lt;p&gt;当应用程序调用 Session 的 save(),update(),saveOrUpdate(),load(),get(),find()以及查询接口的 list(),iterate() 或者 filter() 方法时，如果Session 的缓存中不存在相应的对象，Hibernate就会把该对象加入到一级缓存中。&lt;/p&gt;

&lt;p&gt;可通过以下两个方法管理缓存：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;evict(object o)&lt;/code&gt;：从缓存中清除指定持久化对象&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;clear()&lt;/code&gt;：清空缓存中的所有持久化对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中&lt;code&gt;evict(object o)&lt;/code&gt;方法适用于：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不希望 Session 继续按照对象状态变化来同步更新数据库；&lt;/li&gt;
  &lt;li&gt;使用 Hibernate API 批量更新或删除后。当然执行批量更新或者删除最佳的方式是通过 JDBC API 执行相关SQL语句或调用存储过程。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通常，&lt;strong&gt;不建议通过上述方法管理一级缓存&lt;/strong&gt;，因为其并不能显著提高应用性能。有效的一级缓存管理办法是：&lt;strong&gt;合理的检索策略和检索方式&lt;/strong&gt;。如，通过&lt;strong&gt;延迟加载、集合过滤或者投影查询&lt;/strong&gt;等手段来节省内存开销。&lt;/p&gt;

&lt;h2 id=&quot;hibernate-1&quot;&gt;Hibernate二级缓存&lt;/h2&gt;

&lt;p&gt;Hibernate的二级缓存是进程范围或群集范围的缓存，缓存中存放的是对象的散列数据。二级缓存是可配置的插件，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://ehcache.org/&quot; title=&quot;EHCache 主页&quot;&gt;EHCache&lt;/a&gt; : 可作为进程范围内的缓存，存放数据是物理介质是内存或硬盘，支持Hibernate查询缓存；&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.baike.com/wiki/OSCache&quot; title=&quot;OSCache 互动百科&quot;&gt;OSCache&lt;/a&gt; : 可作为进程范围内的缓存，存放数据是物理介质是内存或硬盘，提供了丰富的缓存数据过期策略，支持Hibernate查询缓存；&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://swarmcache.sourceforge.net/&quot; title=&quot;SwarmCache 主页&quot;&gt;SwarmCache&lt;/a&gt; : 可作为群集范围内的的缓存，不支持Hibernate查询缓存；&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jboss.org/jbosscache/&quot; title=&quot;JBossCache 主页&quot;&gt;JBossCache&lt;/a&gt; : 可作为群集范围内的的缓存，支持事务型并发访问策略，支持Hibernate查询缓存。&lt;/li&gt;
&lt;/ul&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
    &lt;caption&gt;各插件支持的并发访问策略&lt;/caption&gt;
    &lt;tr&gt;
        &lt;th&gt;缓存插件&lt;/th&gt;
        &lt;th&gt;只读型&lt;/th&gt;
        &lt;th&gt;非严格读写型&lt;/th&gt;
        &lt;th&gt;读写型&lt;/th&gt;
        &lt;th&gt;事务型&lt;/th&gt;
        &lt;th&gt;Hibernate适配器&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;EHCache&lt;/td&gt;
        &lt;td&gt;支持&lt;/td&gt;
        &lt;td&gt;支持&lt;/td&gt;
        &lt;td&gt;支持&lt;/td&gt;
        &lt;td&gt;否&lt;/td&gt;
        &lt;td&gt;org.hibernate.cache.EhCacheProvider&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;OSCache&lt;/td&gt;
        &lt;td&gt;支持&lt;/td&gt;
        &lt;td&gt;支持&lt;/td&gt;
        &lt;td&gt;支持&lt;/td&gt;
        &lt;td&gt;否&lt;/td&gt;
        &lt;td&gt;org.hibernate.cache.OSCacheProvider&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;SwarmCache&lt;/td&gt;
        &lt;td&gt;支持&lt;/td&gt;
        &lt;td&gt;支持&lt;/td&gt;
        &lt;td&gt;否&lt;/td&gt;
        &lt;td&gt;否&lt;/td&gt;
        &lt;td&gt;org.hibernate.cache.SwarmCacheProvider&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;JBossCache&lt;/td&gt;
        &lt;td&gt;支持&lt;/td&gt;
        &lt;td&gt;否&lt;/td&gt;
        &lt;td&gt;否&lt;/td&gt;
        &lt;td&gt;支持&lt;/td&gt;
        &lt;td&gt;org.hibernate.cache.TressCacheProvider&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tfoot&gt;
        &lt;tr&gt;&lt;td colspan=&quot;6&quot;&gt;注：适配器类名基于Hibernate3.jar包&lt;/td&gt;&lt;/tr&gt;
    &lt;/tfoot&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-10&quot;&gt;二级缓存的开启&lt;/h3&gt;

&lt;p&gt;这里采用OSCache作为Hibernate cache适配器。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;配置二级缓存适配器&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;prop key=&quot;hibernate.cache.provider_class&quot;&amp;gt;
     org.hibernate.cache.OSCacheProvider
 &amp;lt;/prop&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开启二级缓存&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;prop key=&quot;hibernate.cache.use_second_level_cache&quot;&amp;gt;true&amp;lt;/prop&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;hibernate-2&quot;&gt;Hibernate查询缓存&lt;/h2&gt;

&lt;p&gt;Hibernate查询缓存依赖于二级缓存。当启用查询缓存后，第一次执行查询语句时，Hibernate会把查询结果保存在二级缓存中。当再次执行查询语句时，只需从缓存中获取查询结果即可。&lt;/p&gt;

&lt;p&gt;需要注意的是：&lt;strong&gt;如果查询结果中包含实体，二级缓存只会存放实体的OID，而对于投影查询，二级缓存则会存放所有数值&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;查询缓存适用于以下场合：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;经常使用的查询语句&lt;/li&gt;
  &lt;li&gt;很少对于查询语句关联的数据库数据进行插入、删除和更新操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-11&quot;&gt;查询缓存的配置&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;配置二级缓存&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在Hibernate中配置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;prop key=&quot;hibernate.cache.use_query_cache&quot;&amp;gt;true&amp;lt;/prop&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;调用&lt;code&gt;Query&lt;/code&gt;,&lt;code&gt;Criteria&lt;/code&gt;接口的&lt;code&gt;setCacheable()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;只有当以上三个工作都做了，查询缓存才会生效！&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;与缓存有关的注解&lt;/h2&gt;

&lt;h3 id=&quot;entity&quot;&gt;@Entity&lt;/h3&gt;

&lt;p&gt;这里的&lt;code&gt;@Entity&lt;/code&gt;是指来自  persistence.jar 包的&lt;code&gt;@javax.persistence.Entity&lt;/code&gt;。 当使用该注解持久化一个实体时，Hibernate会将该实体存放在一级缓存（Session）中。&lt;/p&gt;

&lt;p&gt;默认情况下，实体不是二级缓存的一部分。通常不建议这么做，但你可以通过在你的持久化配置文件中重写 shared-cache-mode 或者使用 javax.persistence.sharedCache.mode 属性来改变默认情况。可能的值有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ENABLE_SELECTIVE&lt;/strong&gt;: 实体不被缓存，除非明确的被标记为可被缓存。该值为默认值.言下之意就是完全禁止实体二级缓存。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DISABLE_SELECTIVE&lt;/strong&gt;: 实体被缓存，除非明确的被标记为不可缓存。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ALL&lt;/strong&gt;: 所有实体被缓存，除非明确的被标记为不可缓存。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另，&lt;strong&gt;还有一个来自 hibernate-annotations.jar 包的 &lt;a href=&quot;http://docs.jboss.org/hibernate/stable/annotations/reference/en/html/entity.html#entity-hibspec-entity&quot;&gt;org.hibernate.annotations.Entity&lt;/a&gt; 注解，该注解是作为 @javax.persistence.Entity 注解的补充来使用的，其自身不具有持久化类的功能。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;cache&quot;&gt;@Cache&lt;/h3&gt;

&lt;p&gt;来自 hibernate-annotations.jar 包，全称&lt;code&gt;@org.hibernate.annotations.Cache&lt;/code&gt;。该注解可用于类和集合上。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.jboss.org/hibernate/stable/annotations/reference/en/html/entity.html#d0e2298&quot;&gt;@Cache&lt;/a&gt;定义了二级缓存策略和缓存范围，定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Cache(
    CacheConcurrencyStrategy usage(); // 1
    String region() default &quot;&quot;;       // 2
    String include() default &quot;all&quot;;   // 3
)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;usage&lt;/strong&gt;: 当前缓存策略（&lt;strong&gt;NONE, READ_ONLY, NONSTRICT_READ_WRITE, TRANSACTIONAL&lt;/strong&gt;）。
    &lt;ul&gt;
      &lt;li&gt;read-only: 只读缓存；&lt;/li&gt;
      &lt;li&gt;read-write: 读写缓存；&lt;/li&gt;
      &lt;li&gt;nonstrict-read-write: 不严格读写缓存；&lt;/li&gt;
      &lt;li&gt;transactional: 事务型缓存；&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;具体的使用说明请查看上述的&lt;strong&gt;持久化层缓存的并发访问策略&lt;/strong&gt;或者&lt;a href=&quot;http://docs.jboss.org/hibernate/orm/3.6/reference/zh-CN/html/performance.html#performance-cache&quot;&gt;查看这里&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;region&lt;/strong&gt;: 可选参数。指定二级缓存的区域名，默认为类或者集合的名字&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;include&lt;/strong&gt;：可选参数（all&lt;/td&gt;
          &lt;td&gt;non-lazy）。all 包含所有属性，non-lazy 仅包含非延迟加载的属性。&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-13&quot;&gt;缓存实体&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;@javax.persistence.Entity
@Table(name = &quot;PROVINCE&quot;)
@Cache(usage = CacheConcurrencyStrategy.READ_ONLY)
public class Province(){ // 省份对象
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-14&quot;&gt;缓存集合&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;@javax.persistence.Entity
@Cache (usage = CacheConcurrencyStrategy.READ_ONLY)
public class Province {//省份对象
    @OneToMany(fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;cityId&quot;)
    @Cache(usage = CacheConcurrencyStrategy.READ_ONLY)
    private Set&amp;lt;City&amp;gt; citys; // 省份对应城市
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时，在访问&lt;code&gt;province.citys&lt;/code&gt;时，Hibernate只缓存了city的OID,因此在实际的查询过程中还是需要执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select * from city where cityid = ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来访问数据库表的。为了避免该问题，可以为&lt;code&gt;City&lt;/code&gt;对象配置同样的二级缓存。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@javax.persistence.Entity
@Table(name = &quot;CITY&quot;)
@Cache (usage = CacheConcurrencyStrategy.READ_ONLY)
public class City {
    ...
} // 城市对象
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-15&quot;&gt;比较完整的例子&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;xml配置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;!-- 缓存适配器 --&amp;gt;
 &amp;lt;prop key=&quot;hibernate.cache.provider_class&quot;&amp;gt;
     org.hibernate.cache.OSCacheProvider
 &amp;lt;/prop&amp;gt;
 &amp;lt;!-- 开启查询缓存 --&amp;gt;
 &amp;lt;prop key=&quot;hibernate.cache.use_query_cache&quot;&amp;gt;true&amp;lt;/prop&amp;gt;
 &amp;lt;!-- 开启二级缓存 --&amp;gt;
 &amp;lt;prop key=&quot;hibernate.cache.use_second_level_cache&quot;&amp;gt;true&amp;lt;/prop&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实体配置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; @javax.persistence.Entity
 @Table(name = &quot;PROVINCE&quot;)
 @Cache(usage = CacheConcurrencyStrategy.READ_ONLY)
 public class Province { // 省份对象
     private String pid;
     private String pname;
        
     @OneToMany // 不用lazy加载，一次性全部加载
     @JoinColumn(name = &quot;cid&quot;)
     @Cache(usage = CacheConcurrencyStrategy.READ_ONLY)
     private Set&amp;lt;City&amp;gt; citys; // 省份对应城市
        
     // some set or get method
 }
    
 @javax.persistence.Entity
 @Table(name = &quot;CITY&quot;)
 @Cache (usage = CacheConcurrencyStrategy.READ_ONLY)
 public class City { // 城市对象
     private String cid;
     private String cname;
        
     // some set or get method
 } 
    
 // DAO.class
 // HQL
 public List&amp;lt;Provice&amp;gt; findAll(){
     Query query = session.createQuery(&quot; from Provice&quot;);
     // 设置为true,启动查询缓存
     query.setCacheable(true); 
     List&amp;lt;Provice&amp;gt; list = query.list();
     session.close();
     return list;
 }
    
 // QBC
 public List&amp;lt;Provice&amp;gt; findAll2(){
     Criteria crit = session.createCriteria(Province.class);
     // 设置为true,启动查询缓存
     crit.setCacheable(true);
 	    List&amp;lt;Module&amp;gt; list = crit.list();
     session.close();
     return list;
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
      <pubDate>Sun, 07 Jul 2013 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2013/07/07/hibernate-cache</guid>
      <dc:date>2013-07-07T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>数据库事务与并发</title>
      <link>http://leeyee.github.io/blog/2013/07/04/database-transaction-concurrency</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;多事务运行时的并发问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;数据库锁&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;共享锁&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;独占锁&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;更新锁&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;如何防止死锁&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;数据库事务隔离级别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;多事务运行时的并发问题&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;第一类丢失更新：撤销一个事务时，把其他事务已提交的更新数据覆盖；&lt;/li&gt;
  &lt;li&gt;脏读：一个事务读到另一个事务未提交的更新数据；&lt;/li&gt;
  &lt;li&gt;虚读：一个事务读到另一个事务已提交的新插入的数据；&lt;/li&gt;
  &lt;li&gt;不可重复读：一个事务读到另一个事务已提交的更新数据；&lt;/li&gt;
  &lt;li&gt;第二类丢失更新：这是不可重复读中的特例，一个事务覆盖另一个事务已提交的更新数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;数据库锁&lt;/h2&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
    &lt;tr&gt;
        &lt;th&gt;资源上已防止的锁&lt;/th&gt;
        &lt;th&gt;第二个事务读操作&lt;/th&gt;
        &lt;th&gt;第二个事务更新操作&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;无&lt;/td&gt;
        &lt;td&gt;立即获取共享锁&lt;/td&gt;
        &lt;td&gt;立即获取独占锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;共享锁&lt;/td&gt;
        &lt;td&gt;立即获取共享锁&lt;/td&gt;
        &lt;td&gt;等待第一个事务解除共享锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;独占锁&lt;/td&gt;
        &lt;td&gt;等待第一个事务解除独占锁&lt;/td&gt;
        &lt;td&gt;等待第一个事务解除独占锁&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-2&quot;&gt;共享锁&lt;/h3&gt;

&lt;p&gt;用于读数据操作，他是非独占的，允许其他事务同时读取其锁定的资源，但不允许其他事务更新他。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;加锁条件：当一个事务执行&lt;code&gt;select&lt;/code&gt;语句时。&lt;/li&gt;
  &lt;li&gt;解锁条件：默认情况下，数据读取后，数据库系统立即释放共享锁。&lt;/li&gt;
  &lt;li&gt;兼容性：放置共享锁后还可放置共享锁和更新锁。&lt;/li&gt;
  &lt;li&gt;并发性：具有良好的并发性能。当多个事务读取相同的数据时，每个事务都会获得一把共享锁，因此可以同时读锁定的数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-3&quot;&gt;独占锁&lt;/h3&gt;

&lt;p&gt;也叫排他锁，使用与修改数据的场合。他锁定的资源，其他事务不能进行读写。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;加锁条件：当一个事务执行&lt;code&gt;insert&lt;/code&gt;,&lt;code&gt;update&lt;/code&gt;,&lt;code&gt;delete&lt;/code&gt;时，数据库系统会自动对被操作的数据使用独占锁。如果该数据已有其他锁存在，则不能放置独占锁。&lt;/li&gt;
  &lt;li&gt;解锁条件：事务结束。&lt;/li&gt;
  &lt;li&gt;兼容性：不和其他锁兼容。&lt;/li&gt;
  &lt;li&gt;并发性：并发性差，只允许有一个事务访问锁定数据。其他事务需等待，直到当前事务结束。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-4&quot;&gt;更新锁&lt;/h3&gt;

&lt;p&gt;更新操作的初始阶段用来锁定可以能要被修改资源的锁。更新锁可避免使用共享锁造成的死锁现象。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;加锁条件：当执行&lt;code&gt;update&lt;/code&gt;时，数据库系统会先为事务分配一个更新锁。&lt;/li&gt;
  &lt;li&gt;解锁条件：当读取数据完毕，执行更新操作时，更新锁升级为独占锁。&lt;/li&gt;
  &lt;li&gt;兼容性：与共享锁兼容。一个资源可同时放置更新锁和共享锁，但只能放置一把更新锁。&lt;/li&gt;
  &lt;li&gt;并发性：允许多个事务同时读锁定的资源，但不允许其他事务修改。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-5&quot;&gt;如何防止死锁&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;合理安排表访问顺序；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用短事务（包含尽可能少的能在短时间内完成操作的事务）；&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;将事务分解为多个小事务，让后分别执行。这样可保证每个小事务的快速完成，减少对数据资源锁定的时间；&lt;/li&gt;
      &lt;li&gt;减少执行事务过程中等待需要更新的数据。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果对数据要求不高，可以允许脏读。脏读不需要对数据资源加锁，可以避免锁冲突；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果可能，错开多个事务访问相同数据资源的时间，防止锁冲突；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;使用尽可能低的事务隔离级别。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-6&quot;&gt;数据库事务隔离级别&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Serializalble: 串行化。一个事务在执行过程完全看不到其他事务对数据库所做的更新。当两个事务同时访问相同数据时，第一个事务必须等第二个事务完成后才能访问。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Repeatable Read: 可重复读。事务在执行过程中可以看到其他事务已提交的新插入记录，但不能看到其他事务已提交的对已有记录的更新。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Read Committed: 读已提交数据。事务在执行过程中可以看到其他事务已提交的新插入记录，也可看到其他事务已提交的对已有记录的更新。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Read Uncommited: 读未提交数据。事务在执行过程既可以看到其他事务没有提交的新插入数据，也可看到其他事务已经提交的对已有记录的更新。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中&lt;strong&gt;Serializalble&lt;/strong&gt;的隔离级别最高，但并发性能最差。而&lt;strong&gt;Read Uncommited&lt;/strong&gt;的隔离级别最低，但并发性能最好。隔离级别越高，越能保证数据的完整性和一致性，但并发性能则会降低。对于多数程序，可以优先考虑把数据库系统的隔离级别设置为Read Committed，它可以避免脏读，而且具有较好的并发性能。&lt;/p&gt;
</description>
      <pubDate>Thu, 04 Jul 2013 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2013/07/04/database-transaction-concurrency</guid>
      <dc:date>2013-07-04T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>使用autoMapping配置关联关系时应注意的问题</title>
      <link>http://leeyee.github.io/blog/2013/05/30/mybatis-association-autoMapping</link>
      <description>
&lt;p&gt;利用&lt;code&gt;association&lt;/code&gt;解决多对一、一对一问题时，在配置&lt;code&gt;resultMap&lt;/code&gt;时使用&lt;code&gt;autoMapping&lt;/code&gt;属性映射表字段时，生成的多端对象数据中是拿不到声明的外键的。&lt;/p&gt;

&lt;p&gt;如果业务有需要在多的一端对象中直接获取外键属性，而不是通过对应的一端来获取，那么就需要在使用&lt;code&gt;autoMapping&lt;/code&gt;时，重新为多端表指明主外键映射关系或者撇弃&lt;code&gt;autoMapping&lt;/code&gt;而改用手工声明。&lt;/p&gt;

&lt;p&gt;假设我们有两张表:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Blog(&lt;strong&gt;id&lt;/strong&gt;,&lt;em&gt;authorid&lt;/em&gt;,name,context,create_time)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Author(&lt;strong&gt;id&lt;/strong&gt;,name,age)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两张表间的关系为&lt;code&gt;ManyToOne&lt;/code&gt;,其中&lt;code&gt;Blog.authorid&lt;/code&gt;对应&lt;code&gt;Author.id&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对应的&lt;code&gt;javaBean&lt;/code&gt;为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Blog {
    private int id;
    private String name;
    private String context;
    private Integer authorid;
    private Author author;
    // some set or get method
}
public class Author {
    private int id;
    private String name;
    private int age;
    // some set or get method
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着我们需要给SQL&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select a.*,b.id as bid,b.name as bname,b.age from Blog a left join Author b on a.authorid = b.id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置&lt;code&gt;mybatis&lt;/code&gt; Mapper映射文件BlogMapper，那么通常我们的配置如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;resultMap type= &quot;Blog&quot; id=&quot;blogResultMap&quot; autoMapping =&quot;true&quot;&amp;gt;
    &amp;lt;!-- manyToOne --&amp;gt;
    &amp;lt;association property =&quot;author&quot; column=&quot;authorid&quot; javaType= &quot;Author&quot;&amp;gt;
        &amp;lt;id property =&quot;id&quot; column=&quot;bid&quot; /&amp;gt;
        &amp;lt;!-- 或者使用
            &amp;lt;id property =&quot;id&quot; column=&quot;authorid&quot; /&amp;gt;
        --&amp;gt;
        &amp;lt;result property =&quot;name&quot; column=&quot;bname&quot; /&amp;gt;
        &amp;lt;result property =&quot;age&quot; column=&quot;age&quot; /&amp;gt;
    &amp;lt;/association&amp;gt;
&amp;lt;/resultMap&amp;gt;

&amp;lt;select id=&quot;queryByVo&quot; parameterType=&quot;Blog&quot; resultMap=&quot;blogResultMap&quot;&amp;gt;
    select a.*,b.id as bid,b.name as bname,b.age from Blog a left join Author b on a.authorid = b.id
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们使用了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;Blog&amp;gt; blogs = blogService.queryByVo(new Blog());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后，就可以通过&lt;code&gt;blog.author&lt;/code&gt;获取&lt;code&gt;Author&lt;/code&gt;对象了。这里需要注意的一点是，虽然我们在&lt;code&gt;Blog&lt;/code&gt;对象中设置了&lt;code&gt;authorid&lt;/code&gt;属性,并且也在&lt;code&gt;resultMap&lt;/code&gt;标签中使用了&lt;code&gt;autoMapping&lt;/code&gt;，但在查询出的&lt;code&gt;blog&lt;/code&gt;中通过&lt;code&gt;blog.authorid&lt;/code&gt;是获取不到值的，只能通过&lt;code&gt;blog.author.id&lt;/code&gt;来获取&lt;code&gt;authorid&lt;/code&gt;.可见&lt;code&gt;autoMapping&lt;/code&gt;并未自动映射&lt;code&gt;authorid&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;那么如果想直接通过&lt;code&gt;Blog&lt;/code&gt;对象获取&lt;code&gt;authorid&lt;/code&gt;该怎么办呢？有两种办法来处理：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code&gt;autoMapping = &quot;true&quot;&lt;/code&gt;时，mybatis 默认规则不在多端映射外键属性，通过多端只能获取一端的对象。因此我们需要在使用&lt;code&gt;autoMapping = &quot;true&quot;&lt;/code&gt;时补充一些映射规则&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;resultMap type= &quot;Blog&quot; id=&quot;blogResultMap&quot; autoMapping =&quot;true&quot;&amp;gt;
     &amp;lt;id property=&quot;id&quot; column=&quot;id&quot; /&amp;gt;  &amp;lt;!-- 注释:1  --&amp;gt;
     &amp;lt;!-- 或者 &amp;lt;result property=&quot;id&quot; column=&quot;id&quot; /&amp;gt; --&amp;gt;
     &amp;lt;result property=&quot;authorid&quot; column=&quot;authorid&quot; /&amp;gt;  &amp;lt;!-- 注释:2 --&amp;gt;
     &amp;lt;!-- manyToOne --&amp;gt;
     &amp;lt;association property =&quot;author&quot; column=&quot;authorid&quot; javaType= &quot;Author&quot;&amp;gt;
         &amp;lt;id property =&quot;id&quot; column=&quot;bid&quot; /&amp;gt;
         &amp;lt;!-- 或者使用
             &amp;lt;id property =&quot;id&quot; column=&quot;authorid&quot; /&amp;gt;
         --&amp;gt;
         &amp;lt;result property =&quot;name&quot; column=&quot;bname&quot; /&amp;gt;
         &amp;lt;result property =&quot;age&quot; column=&quot;age&quot; /&amp;gt;
     &amp;lt;/association&amp;gt;
 &amp;lt;/resultMap&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

    &lt;div class=&quot;alert alert-error&quot;&gt;
 &lt;strong&gt;Notes:&lt;/strong&gt;
 如果只设置了&lt;b&gt;‘注释:2’&lt;/b&gt;，那么将只能获取 Blog 表中相同 authorid 的第一条信息,因此这里需要重新覆盖主键和外键的映射.
 &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不使用&lt;code&gt;autoMapping&lt;/code&gt;属性，直接手工配置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;resultMap type= &quot;Blog&quot; id=&quot;blogResultMap&quot;&amp;gt;
     &amp;lt;id property=&quot;id&quot; column=&quot;id&quot; /&amp;gt;
     &amp;lt;result property=&quot;authorid&quot; column=&quot;authorid&quot; /&amp;gt;
 	    &amp;lt;result property=&quot;name&quot; column=&quot;name&quot; /&amp;gt; 
     &amp;lt;result property=&quot;context&quot; column=&quot;context&quot; /&amp;gt;
     &amp;lt;!-- manyToOne --&amp;gt;
     &amp;lt;association property =&quot;author&quot; column=&quot;authorid&quot; javaType= &quot;Author&quot;&amp;gt;
         &amp;lt;id property =&quot;id&quot; column=&quot;bid&quot; /&amp;gt;
         &amp;lt;!-- 或者使用
             &amp;lt;id property =&quot;id&quot; column=&quot;authorid&quot; /&amp;gt;
         --&amp;gt;
         &amp;lt;result property =&quot;name&quot; column=&quot;bname&quot; /&amp;gt;
         &amp;lt;result property =&quot;age&quot; column=&quot;age&quot; /&amp;gt;
     &amp;lt;/association&amp;gt;
 &amp;lt;/resultMap&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

  	很显然这种方式下，如果需要映射的表字段过多，那么就需要点体力了！

&lt;p&gt;改用上述方式后及可以直接在&lt;code&gt;Blog&lt;/code&gt;对象中直接获取&lt;code&gt;authorid&lt;/code&gt;属性了。&lt;/p&gt;
</description>
      <pubDate>Thu, 30 May 2013 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2013/05/30/mybatis-association-autoMapping</guid>
      <dc:date>2013-05-30T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>mybatis分页的简单实现</title>
      <link>http://leeyee.github.io/blog/2013/05/26/mybatis-simple-pagination</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;拦截器代码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#spring&quot;&gt;在spring中配置拦截器&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最近的项目中使用到了&lt;code&gt;mybatis&lt;/code&gt;，发现&lt;code&gt;mybatis&lt;/code&gt;不支持物理分页，只支持内存分页。因此为了解决这个问题，在网上搜索了一番，不过都比较繁琐。最后使用正则表达过滤查询语句的方式简单解决了该问题.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mybatis&lt;/code&gt;物理分页的核心是使用&lt;code&gt;mybatis&lt;/code&gt;的拦截器 &lt;code&gt;org.apache.ibatis.plugin.Interceptor&lt;/code&gt; ,在&lt;code&gt;mybatis&lt;/code&gt;准备好&lt;code&gt;SQL&lt;/code&gt;的时候，对&lt;code&gt;SQL&lt;/code&gt;字符串进行拦截，生成适合&lt;code&gt;Oracle&lt;/code&gt;数据库的分页语句即可。废话不多讲了，直接上代码.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; 该部分依赖commons-lang3.jar包进行反射写入，也可使用 mybatis 自带的反射类实现这部分功能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;拦截器代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package org.mybatis.test.interceptor;

import java.sql.Connection;
import java.util.*;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.reflect.FieldUtils;
import org.apache.ibatis.executor.statement.StatementHandler;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.plugin.*;
import org.apache.ibatis.session.RowBounds;

@Intercepts(@Signature(type = StatementHandler.class, method = &quot;prepare&quot;, args = { Connection.class }))
public class PaginationInterceptor implements Interceptor {

	private final static String SQL_SELECT_REGEX = &quot;(?is)^\\s*SELECT.*$&quot;;
	private final static String SQL_COUNT_REGEX = &quot;(?is)^\\s*SELECT\\s+COUNT\\s*\\(\\s*(?:\\*|\\w+)\\s*\\).*$&quot;;

	//@Override
	public Object intercept(Invocation inv) throws Throwable {

		StatementHandler target = (StatementHandler) inv.getTarget();

		BoundSql boundSql = target.getBoundSql();

		String sql = boundSql.getSql();

		if (StringUtils.isBlank(sql)) {
			return inv.proceed();
		}
		System.out.println(&quot;origin sql&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&quot; + sql.replaceAll(&quot;\n&quot;, &quot;&quot;));

		// 只有为select查询语句时才进行下一步
		if (sql.matches(SQL_SELECT_REGEX)
				&amp;amp;&amp;amp; !Pattern.matches(SQL_COUNT_REGEX, sql)) {

			Object obj = FieldUtils.readField(target, &quot;delegate&quot;, true);
			// 反射获取 RowBounds 对象。
			RowBounds rowBounds = (RowBounds) FieldUtils.readField(obj,
					&quot;rowBounds&quot;, true);
					
			// 分页参数存在且不为默认值时进行分页SQL构造
			if (rowBounds != null &amp;amp;&amp;amp; rowBounds != RowBounds.DEFAULT) {
				FieldUtils.writeField(boundSql, &quot;sql&quot;, newSql(sql, rowBounds),
						true);
				System.out.println(&quot;new sql&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&quot;
						+ boundSql.getSql().replaceAll(&quot;\n&quot;, &quot;&quot;));

				// 一定要还原否则将无法得到下一组数据(第一次的数据被缓存了)
				FieldUtils.writeField(rowBounds, &quot;offset&quot;,
						RowBounds.NO_ROW_OFFSET, true);
				FieldUtils.writeField(rowBounds, &quot;limit&quot;,
						RowBounds.NO_ROW_LIMIT, true);
			}
		}
		return inv.proceed();
	}

	public String newSql(String oldSql, RowBounds rowBounds) {
		String start = &quot; SELECT * FROM   (SELECT   row_.*, ROWNUM rownum_ FROM ( &quot;;
		String end = &quot; ) row_ WHERE   ROWNUM &amp;lt;= &quot; + rowBounds.getLimit()
				+ &quot;) WHERE   rownum_ &amp;gt; &quot; + rowBounds.getOffset();

		return start + oldSql + end;
	}

	//@Override
	public Object plugin(Object target) {
		return Plugin.wrap(target, this);
	}

	//@Override
	public void setProperties(Properties arg0) {
		System.out.println(arg0);
	}
    
    //测试正则表达式是否能正常工作
	public static void main(String[] args) {
		String SQL_SELECT_REGEX = &quot;^\\s*SELECT.*$&quot;;
		String SQL_COUNT_REGEX = &quot;^\\s*SELECT\\s+COUNT\\s*\\(\\s*(?:\\*|\\w+)\\s*\\).*$&quot;;
		List&amp;lt;String&amp;gt; tests = new ArrayList&amp;lt;String&amp;gt;();
		tests.add(&quot;select count(*) from abc \n\t\t where\n abc&quot;);
		tests.add(&quot;SELECT 	COUNT(*) from abc&quot;);
		tests.add(&quot; select count  (*) from abc&quot;);
		tests.add(&quot;  select count(  *) from abc&quot;);
		tests.add(&quot;select count( *  ),id   from abc&quot;);
		tests.add(&quot;select * from abc&quot;);
		tests.add(&quot;select abc,test,fdas from abc&quot;);
		tests.add(&quot;select count(adb) from abc&quot;);
		tests.add(&quot;select count(0) from abc&quot;);
		tests.add(&quot;select min(count(*)) from abc&quot;);
		tests.add(&quot;update min(count(*)) from abc&quot;);
		tests.add(&quot;delete min(count(*)) from abc&quot;);
		Pattern p1 = Pattern.compile(SQL_SELECT_REGEX, Pattern.DOTALL
				| Pattern.CASE_INSENSITIVE);
		Pattern p2 = Pattern.compile(SQL_COUNT_REGEX, Pattern.DOTALL
				| Pattern.CASE_INSENSITIVE);
		for (String str : tests) {
			Matcher m1 = p1.matcher(str);
			Matcher m2 = p2.matcher(str);
			System.out.println(&quot;匹配字符串: &quot; + str);
			System.out.println(&quot;	是select语句? &quot; + m1.matches());
			System.out.println(&quot;	是count语句? &quot; + m2.matches());
			System.out.println();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;spring&quot;&gt;在spring中配置拦截器&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;bean name=&quot;paginationInterceptor&quot; class=&quot;org.mybatis.test.interceptor.PaginationInterceptor&quot;&amp;gt;&amp;lt;/bean&amp;gt;

&amp;lt;!-- define the SqlSessionFactory --&amp;gt;
&amp;lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&amp;gt;
	&amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&amp;gt;
	&amp;lt;property name=&quot;typeAliasesPackage&quot; value=&quot;org.mybatis.test.domain&quot; /&amp;gt;
	&amp;lt;property name=&quot;plugins&quot;&amp;gt;
		&amp;lt;list&amp;gt;
			&amp;lt;ref bean=&quot;paginationInterceptor&quot; /&amp;gt;
		&amp;lt;/list&amp;gt;
	&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;使用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class Test(){
	private String name;
	private int age;
	// set/get省
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在TestMapper.java接口类中声明分页方法&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; //统计总条数
 int countByVo(Test test)；
 //分页查询
 List&amp;lt;T&amp;gt; queryByVo(RowBounds rowBound, Test test);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TestMapper.xml中&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;select id=&quot;countByVo&quot; parameterType=&quot;Test&quot; resultType=&quot;int&quot;&amp;gt;
     select count(*) as count from table_test
     &amp;lt;where&amp;gt;
         &amp;lt;if test=&quot;name != null&quot;&amp;gt;name like '' || #{name} || '%'&amp;lt;/if&amp;gt;
     &amp;lt;/where&amp;gt;
 &amp;lt;/select&amp;gt;

 &amp;lt;select id=&quot;queryByVo&quot; parameterType=&quot;Test&quot; resultType=&quot;Test&quot;&amp;gt;
     select * from table_test
     &amp;lt;where&amp;gt;
         &amp;lt;if test=&quot;name != null&quot;&amp;gt;name like '' || #{name} || '%'&amp;lt;/if&amp;gt;
     &amp;lt;/where&amp;gt;
 &amp;lt;/select&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;业务层代码&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; @Autowired
 private TestMapper testMapper;  
 
 /**
   * @param offset 起始位置
   * @param limit 结束位置
   */
 public void queryByVo(int offset, int limit) {
     Test test = new Test();
     List&amp;lt;User&amp;gt; list = this.testMapper.queryByVo(new RowBounds(offset, limit), test);
 }	
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
      <pubDate>Sun, 26 May 2013 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2013/05/26/mybatis-simple-pagination</guid>
      <dc:date>2013-05-26T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>javascript中的null和undefined</title>
      <link>http://leeyee.github.io/blog/2013/05/07/javascript-null-undefined</link>
      <description>
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;null&lt;/code&gt;表示无值或不存在的对象；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;undefined&lt;/code&gt;表示一个未声明的变量。声明但没有赋值的变量或者一个并不存在的对象属性;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; var param; // 声明但不赋值，其等价于
 var param = undefined;

 var obj = {}; //声明一个对象
 var param1 = obj.param; // 对象不存在的属性
 console.info(param1); // undefined
 console.info(param1 === undefined); // true
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;undefined&lt;/code&gt;不同于&lt;strong&gt;未定义&lt;/strong&gt;，但在使用&lt;code&gt;typeof&lt;/code&gt;方法时，该方法并不区分&lt;code&gt;undefined&lt;/code&gt;和&lt;strong&gt;未定义&lt;/strong&gt;，其返回值均为&lt;em&gt;字符串&lt;code&gt;undefined&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; var param; 
 console.info(typeof param); // 打印 &quot;undefined&quot;
 console.info(typeof param === 'undefined'); // true

 // 注意：param1并未被声明，属于首次使用
 console.info(typeof param1); // 打印 &quot;undefined&quot;
 console.info(typeof param1 === 'undefined'); // true
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;undefined&lt;/code&gt;为函数默认的返回值（当函数无明确返回值时）。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; function test(){};
 var fn = test();
 console.info(fn); // 打印 undefined
 console.info( fn === undefined ); // true
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;typeof(null)&lt;/code&gt;返回&lt;em&gt;字符串&lt;code&gt;object&lt;/code&gt;&lt;/em&gt;,而&lt;code&gt;typeof(undefined)&lt;/code&gt;返回&lt;em&gt;字符串&lt;code&gt;undefined&lt;/code&gt;&lt;/em&gt;。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; console.info(typeof null); // 打印 &quot;object&quot;
 console.info(typeof(null) === 'object'); // true

 console.info(typeof undefined); // 打印 &quot;undefined&quot;
 console.info(typeof(undefined) === 'undefined'); // true
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;但&lt;code&gt;null == undefined&lt;/code&gt;，这是由于值&lt;code&gt;undefined&lt;/code&gt;是从值&lt;code&gt;null&lt;/code&gt;派生过来的，因此&lt;code&gt;ECMAScript&lt;/code&gt;将其定义为一样的。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; console.info(null == undefined);// true
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;虽然&lt;code&gt;null == undefined&lt;/code&gt;，但&lt;code&gt;null&lt;/code&gt;表示尚未存在的对象，而&lt;code&gt;undefined&lt;/code&gt;则是声明了变量但未对其初始化时赋予该变量的值；因此只能通过&lt;code&gt;===&lt;/code&gt;运算符来测试某个值是否&lt;strong&gt;未定义&lt;/strong&gt;。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; var param;
 var param1 = undefined;
 console.info(param === undefined); // true
 console.info(param1 === undefined); // true

 var param2 = null;
 console.info(param2 == undefined); // true
 console.info(param2 === undefined); // false
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数或方法返回值为对象时，如果该返回的对象找不到，则该函数或方法通常返回是&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，关于对于&lt;code&gt;typeof&lt;/code&gt;方法的使用进行下说明：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt;方法返回的是变量的引用类型的字符名称。因此&lt;code&gt;if(typeof param){}&lt;/code&gt;为永真。如果要判断引用类型，可以使用&lt;code&gt;instanceof&lt;/code&gt;，但此时变量的声明应使用&lt;code&gt;new&lt;/code&gt;关键字创建。&lt;/p&gt;

&lt;p&gt;老版地址请查看：&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/oxcow/article/details/7751835&quot;&gt;ECMAScript中原始类型Null和Undefined小结&lt;/a&gt; 或者 &lt;a href=&quot;http://leeyee.iteye.com/admin/blogs/1595338&quot;&gt;ECMAScript中原始类型Null和Undefined小结&lt;/a&gt;&lt;/p&gt;
</description>
      <pubDate>Tue, 07 May 2013 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2013/05/07/javascript-null-undefined</guid>
      <dc:date>2013-05-07T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>jQuery插件编写</title>
      <link>http://leeyee.github.io/blog/2012/12/02/jquery-plugins-authoring</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#contents&quot;&gt;目录(CONTENTS)&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#getting-started&quot;&gt;入门知识(Getting Started)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#context&quot;&gt;上下文(Context)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#the-basics&quot;&gt;基本要素(The Basics)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#maintaining-chainability&quot;&gt;保持可链通性(Maintaining Chainability)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#defaults-and-options&quot;&gt;默认值和可选项(Defaults and Options)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#namespacing&quot;&gt;命名空间(Namespacing)&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#plugin-methods&quot;&gt;插件方法(Plugin Methods)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#events&quot;&gt;事件(Events)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#data&quot;&gt;数据(Data)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#summary-and-best-practices&quot;&gt;总结和最佳实践(Summary and Best Practices)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#translations&quot;&gt;Translations&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;http://docs.jquery.com/Plugins/Authoring&quot;&gt;http://docs.jquery.com/Plugins/Authoring&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So you’ve become comfortable with jQuery and would like to learn how to write your own plugins. Great! You’re in the right spot. Extending jQuery with plugins and methods is very powerful and can save you and your peers a lot of development time by abstracting your most clever functions into plugins. This post will outline the basics, best practices, and common pitfalls to watch out for as you begin writing your plugin.&lt;/p&gt;

&lt;p&gt;当你已经熟练掌握&lt;code&gt;jQuery&lt;/code&gt;并且想学习如何编写属于自己的插件程序时，你可以参看这篇文章。使用插件程序和方法扩展&lt;code&gt;jQuery&lt;/code&gt;是非常强大的。你可以将一些想法抽象为函数并封装到插件中以便为你和你的同事节省许多开发时间。&lt;/p&gt;

&lt;h1 id=&quot;contents&quot;&gt;目录(CONTENTS)&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#t1&quot;&gt;入门知识(Getting Started)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#t2&quot;&gt;上下文(Context)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#t3&quot;&gt;基本要素(The Basics)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#t4&quot;&gt;保持可链通性(Maintaining Chainability)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#t5&quot;&gt;默认值和可选项(Defaults and Options)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#t6&quot;&gt;命名空间(Namespacing)&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;6.1 &lt;a href=&quot;#t61&quot;&gt;插件方法(Plugin Methods)&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;6.2 &lt;a href=&quot;#t62&quot;&gt;事件(Events)&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;6.3 &lt;a href=&quot;#t63&quot;&gt;数据(Data)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#t7&quot;&gt;总结和最佳实践(Summary and Best Practices)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#t8&quot;&gt;翻译(Translations)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;getting-started&quot;&gt;入门知识(Getting Started)&lt;/h2&gt;
&lt;p&gt;To write a jQuery plugin, start by adding a new function property to the jQuery.fn object where the name of the property is the name of your plugin:&lt;/p&gt;

&lt;p&gt;编写&lt;code&gt;jQuery&lt;/code&gt;插件,是从添加一个新的函数属性到&lt;code&gt;jQuery.fn&lt;/code&gt;对象开始的，其中新的函数属性名为你要编写插件的名称：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.fn.myPlugin = function() {
    // Do your awesome plugin stuff here
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But wait! Where’s my awesome dollar sign that I know and love? It’s still there, however to make sure that your plugin doesn’t collide with other libraries that might use the dollar sign, it’s a best practice to pass jQuery to an IIFE (Immediately Invoked Function Expression) that maps it to the dollar sign so it can’t be overwritten by another library in the scope of its execution.&lt;/p&gt;

&lt;p&gt;但是请等一下，我们喜爱的万能&lt;code&gt;$&lt;/code&gt;符号在哪里？它仍然在哪里，然而为了确保你的插件不会与其他可能使用&lt;code&gt;$&lt;/code&gt;符号的&lt;code&gt;javascript&lt;/code&gt;库冲突，一个最佳的实践是将&lt;code&gt;jQuery&lt;/code&gt;对象当做参数传递到一个可立即执行的函数表达式中（IIFE），该函数表达式会通过&lt;code&gt;$&lt;/code&gt;符号来映射&lt;code&gt;jQuery&lt;/code&gt;对象，这样在该函数表达式内，&lt;code&gt;$&lt;/code&gt;符号将不会被在其可执行的作用域中的其他库所覆盖。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function( $ ) {
    $.fn.myPlugin = function() {
        // Do your awesome plugin stuff here
    };
})( jQuery );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ah, that’s better. Now within that closure, we can use the dollar sign in place of jQuery as much as we like.&lt;/p&gt;

&lt;p&gt;这样就可以了。现在通过闭包，我们就能使用我们喜爱的&lt;code&gt;$&lt;/code&gt;符号代替&lt;code&gt;jQuery&lt;/code&gt;对象了。&lt;/p&gt;

&lt;h2 id=&quot;context&quot;&gt;上下文(Context)&lt;/h2&gt;
&lt;p&gt;Now that we have our shell we can start writing our actual plugin code. But before we do that, I’d like to say a word about context. In the immediate scope of the plugin function, the this keyword refers to the jQuery object the plugin was invoked on. This is a common slip up due to the fact that in other instances where jQuery accepts a callback, the this keyword refers to the native DOM element. This often leads to developers unnecessarily wrapping the this keyword (again) in the jQuery function.&lt;/p&gt;

&lt;p&gt;现在，有了插件外壳，我们就可以开始编写真正的插件代码了。但是在此之前，我想要谈谈上下文。在插件函数的当前域中，&lt;em&gt;this&lt;/em&gt; 关键字是指代被调用插件中的&lt;code&gt;jQuery&lt;/code&gt;对象的。这是一个常见的疏忽，因为在&lt;code&gt;jQuery&lt;/code&gt;接受回调的其他情况中，&lt;em&gt;this&lt;/em&gt; 关键字指代的是原生&lt;code&gt;DOM&lt;/code&gt;元素。这常常会导致开发人员不必要地使用&lt;code&gt;jQuery&lt;/code&gt;函数来包装 &lt;em&gt;this&lt;/em&gt; 关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function( $ ){
    $.fn.myPlugin = function() {
        // there's no need to do $(this) because
        // &quot;this&quot; is already a jquery object
        // $(this) would be the same as $($('#element'));
        // 这里不需要执行$(this),
        // 因为this已经是一个jQuery object对象了
        // $(this) 等价于 $($('#element'));
        this.fadeIn('normal', function(){
            // the this keyword is a DOM element
        });
    };
})( jQuery );
$('#element').myPlugin();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;the-basics&quot;&gt;基本要素(The Basics)&lt;/h2&gt;
&lt;p&gt;Now that we understand the context of jQuery plugins, let’s write a plugin that actually does something.&lt;/p&gt;

&lt;p&gt;现在，在了解了&lt;code&gt;jQuery&lt;/code&gt;插件的上下文后，我们来编写一个实现了一些功能的插件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function( $ ){
    $.fn.maxHeight = function() {
        var max = 0;
        this.each(function() {
            max = Math.max( max, $(this).height() );
        });
        return max;
    };
})( jQuery );
// Returns the height of the tallest div
var tallest = $('div').maxHeight();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a simple plugin that leverages .height() to return the height of the tallest div in the page.&lt;/p&gt;

&lt;p&gt;这是一个简单的插件，通过调用 &lt;code&gt;.height()&lt;/code&gt; 来获取页面最高div元素的高度。&lt;/p&gt;

&lt;h2 id=&quot;maintaining-chainability&quot;&gt;保持可链通性(Maintaining Chainability)&lt;/h2&gt;

&lt;p&gt;The previous example returns an integer value of the tallest div on the page, but often times the intent of a plugin is simply modify the collection of elements in some way, and pass them along to the next method in the chain. This is the beauty of jQuery’s design and is one of the reasons jQuery is so popular. So to maintain chainability in a plugin, you must make sure your plugin returns the this keyword.&lt;/p&gt;

&lt;p&gt;前面的示例返回一个整数值。但是大多数时候编写插件的意图是在某种程度上简单的修改一系列的元素，并且传递他们到另一个方法。这是&lt;code&gt;jQuery&lt;/code&gt;优雅的设计之处和如此受欢迎的原因之一。因此为了维护插件中代码的可链通性，必须保证插件返回 &lt;em&gt;this&lt;/em&gt; 关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function( $ ){
    $.fn.lockDimensions = function( type ) { 
        return this.each(function() {
            var $this = $(this);
            if ( !type || type == 'width' ) {
                $this.width( $this.width() );
            }
            if ( !type || type == 'height' ) {
                $this.height( $this.height() );
            }
        });
    };
})( jQuery );
   
$('div').lockDimensions('width').css('color', 'red');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because the plugin returns the this keyword in its immediate scope, it maintains chainability and the jQuery collection can continue to be manipulated by jQuery methods, such as .css. So if your plugin doesn’t return an intrinsic value, you should always return the this keyword in the immediate scope of the plugin function. Also, as you might assume, arguments you pass in your plugin invocation get passed to the immediate scope of the plugin function. So in the previous example, the string ‘width’ becomes the type argument for the plugin function.&lt;/p&gt;

&lt;p&gt;因为插件在其当前的作用范围内返回了 &lt;em&gt;this&lt;/em&gt; 关键字，所以就维持了可链通性，返回的&lt;code&gt;jQuery&lt;/code&gt;对象集合也就可以继续被&lt;code&gt;jQuery&lt;/code&gt;方法操作，比如 &lt;code&gt;.css&lt;/code&gt;。假如插件不能返回一个内在值，那么就应该总是返回在其当前作用范围内的 &lt;em&gt;this&lt;/em&gt; 关键字。另外，如你所想，插件调用中的参数也传递到了当前作用范围内的插件函数中。所以在上述示例中，字符串’width’就变成了插件函数中的一个 type 参数。&lt;/p&gt;

&lt;h2 id=&quot;defaults-and-options&quot;&gt;默认值和可选项(Defaults and Options)&lt;/h2&gt;

&lt;p&gt;For more complex and customizable plugins that provide many options, it’s a best practice to have default settings that can get extended (using $.extend) when the plugin is invoked. So instead of calling a plugin with a large number of arguments, you can call it with one argument which is an object literal of the settings you would like to override. Here’s how you do it.&lt;/p&gt;

&lt;p&gt;对于许多包含可选项的复杂可定制化插件，最好的方式是有一些能在被调用时可扩展(使用&lt;code&gt;$.extend&lt;/code&gt;)的默认设置。这样就可以避免在调用插件时传递大量参数，取而代之的是在调用时使用一个需要覆盖掉的参数对象。下面就是如何实现他。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function( $ ){
    $.fn.tooltip = function( options ) { 
        // Create some defaults, extending them with any options that were provided
        var settings = $.extend( {
            'location'         : 'top',
            'background-color' : 'blue'
        }, options);
   
        return this.each(function() {       
            // Tooltip plugin code here
        });
    };
})( jQuery );
   
$('div').tooltip({
    'location' : 'left'
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, after calling the tooltip plugin with the given options, the default location setting gets overridden to become ‘left’, while the background-color setting remains the default ‘blue’. So the final settings object ends up looking like this:&lt;/p&gt;

&lt;p&gt;在这例子中，当使用给定的可选项调用 &lt;code&gt;tooltip&lt;/code&gt; 插件方法后，默认的 ‘location’ 属性会被设置成 ‘left’, 而 ‘background-color’ 属性则保持不变。所以最终的 ‘settings’ 对象看来是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    'location'         : 'left',
    'background-color' : 'blue'
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a great way to offer a highly configurable plugin without requiring the developer to define all available options.&lt;/p&gt;

&lt;p&gt;这是一种很好的方式。它提供了一个高度可配置的插件，而不需要开发人员去定义所有的可用选项。&lt;/p&gt;

&lt;h2 id=&quot;namespacing&quot;&gt;命名空间(Namespacing)&lt;/h2&gt;

&lt;p&gt;Properly namespacing your plugin is a very important part of plugin development. Namespacing correctly assures that your plugin will have a very low chance of being overwritten by other plugins or code living on the same page. Namespacing also makes your life easier as a plugin developer because it helps you keep better track of your methods, events and data.&lt;/p&gt;

&lt;p&gt;为你的插件设置一个适当的命名空间是插件开发中非常重要的一部分。合理的命名空间可以降低你的插件被另一些插件或者当前页面上的代码覆盖的几率。命名空间也可以让你的开发变得容易，它可以让你更好的跟踪方法、事件和数据。&lt;/p&gt;

&lt;h3 id=&quot;plugin-methods&quot;&gt;插件方法(Plugin Methods)&lt;/h3&gt;

&lt;p&gt;Under no circumstance should a single plugin ever claim more than one namespace in the jQuery.fn object.&lt;/p&gt;

&lt;p&gt;在任何情况下，一个单独的插件在&lt;code&gt;jQuery.fn&lt;/code&gt;对象上的命名空间都不应超过一个。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function( $ ){
    $.fn.tooltip = function( options ) {
        // THIS
    };
    $.fn.tooltipShow = function( ) {
        // IS
    };
    $.fn.tooltipHide = function( ) {
        // BAD
    };
    $.fn.tooltipUpdate = function( content ) {
        // !!! 
    };
})( jQuery );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a discouraged because it clutters up the $.fn namespace. To remedy this, you should collect all of your plugin’s methods in an object literal and call them by passing the string name of the method to the plugin.&lt;/p&gt;

&lt;p&gt;这样做是不被提倡的，因为它会使&lt;code&gt;$.fn&lt;/code&gt;命名空间变得混乱。为了解决这个问题，你应该将所有插件的方法存放在一个对象字面量中，然后通过传递方法的字符串名称来调用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function( $ ){
    var methods = {
        init : function( options ) {
            // THIS
        },
        show : function( ) {
            // IS
        },
        hide : function( ) {
            // GOOD
        },
        update : function( content ) {
            // !!!
        }
    };

    $.fn.tooltip = function( method ) {
    // Method calling logic
        if ( methods[method] ) {
            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.tooltip' );
        }   
    };
})( jQuery );

// calls the init method
$('div').tooltip();

// calls the init method
$('div').tooltip({
    foo : 'bar'
});
// calls the hide method
$('div').tooltip('hide');
// calls the update method
$('div').tooltip('update', 'This is the new tooltip content!');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This type of plugin architecture allows you to encapsulate all of your methods in the plugin’s parent closure, and call them by first passing the string name of the method, and then passing any additional parameters you might need for that method. This type of method encapsulation and architecture is a standard in the jQuery plugin community and it used by countless plugins, including the plugins and widgets in &lt;a href=&quot;http://jqueryui.com/&quot;&gt;jQueryUI&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;这种类型的插件结构允许在插件的父闭包中封装所有的方法，然后通过先传递方法的字符串名称，再传递其他一些这个方法可能用到的参数来调用。这种方式的方法封装和架构在&lt;code&gt;jQuery&lt;/code&gt;插件社区是一种标准并被无数的插件采用，包括&lt;a href=&quot;http://jqueryui.com/&quot;&gt;jQueryUI&lt;/a&gt;插件和组件。&lt;/p&gt;

&lt;h3 id=&quot;events&quot;&gt;事件(Events)&lt;/h3&gt;

&lt;p&gt;A lesser known feature of the &lt;a href=&quot;http://docs.jquery.com/Events/bind&quot;&gt;bind&lt;/a&gt; method is that is allows for namespacing of bound events. If your plugin binds an event, its a good practice to namespace it. This way, if you need to &lt;a href=&quot;http://docs.jquery.com/Events/unbind&quot;&gt;unbind&lt;/a&gt; it later, you can do so without interfering with other events that might have been bound to the same type of event. You can namespace your events by appending “.&amp;lt; namespace &amp;gt;”the type of event you’re binding.&lt;/p&gt;

&lt;p&gt;对于&lt;a href=&quot;http://docs.jquery.com/Events/bind&quot;&gt;bind&lt;/a&gt;方法一个鲜有人知的特性是允许为绑定的事件声明命名空间。假如你的插件绑定了一个事件，一个好的处理方式是为该事件也添加命名空间。通过这种方式，假如随后你需要解除绑定(&lt;a href=&quot;http://docs.jquery.com/Events/unbind&quot;&gt;unbind&lt;/a&gt;)，就可以在不影响其他可能已经绑定了相同类型事件的情况下解除该绑定。你可以通过添加&lt;code&gt;.&amp;lt;namespace&amp;gt;&lt;/code&gt;给你要绑定的事件添加命名空间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function( $ ){
    var methods = {
        init : function( options ) {
            return this.each(function(){
                $(window).bind('resize.tooltip', methods.reposition);
            });
        },
        destroy : function( ) {
            return this.each(function(){
                $(window).unbind('.tooltip');
            })
        },
        reposition : function( ) {
            // ...
        },
        show : function( ) {
            // ...
        },
        hide : function( ) {
            // ...
        },
        update : function( content ) {
            // ...
        }
    };

    $.fn.tooltip = function( method ) {
        if ( methods[method] ) {
            return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.tooltip' );
        }   
    };
})( jQuery );
   
$('#fun').tooltip();
// Some time later...
$('#fun').tooltip('destroy');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, when the tooltip is initialized with the init method, it binds the reposition method to the resize event of the window under the namespace ‘tooltip’. Later, if the developer needs to destroy the tooltip, we can unbind the events bound by the plugin by passing its namespace, in this case ‘tooltip’, to the unbind method. This allows us to safely unbind plugin events without accidentally unbinding events that may have been bound outside of the plugin.&lt;/p&gt;

&lt;p&gt;在这个示例中，当 &lt;code&gt;tooltip&lt;/code&gt; 使用 &lt;code&gt;init&lt;/code&gt; 方法初始化时，他会绑定 &lt;code&gt;reposition&lt;/code&gt; 方法到&lt;code&gt;window&lt;/code&gt;对象的 &lt;code&gt;resize&lt;/code&gt; 事件上，这些都是在 ‘tooltip’ 命名空间下进行的。之后，如果开发人员需要销毁 &lt;code&gt;tooltip&lt;/code&gt; ，就可以通过传递命名空间来解除该命名空间下绑定的事件。这让我们可以安全的解除通过插件绑定的事件，而不用担心将通过插件外其他方式绑定的事件也解除掉。&lt;/p&gt;

&lt;h3 id=&quot;data&quot;&gt;数据(Data)&lt;/h3&gt;

&lt;p&gt;Often times in plugin development, you may need to maintain state or check if your plugin has already been initialized on a given element. Using jQuery’s data method is a great way to keep track of variables on a per element basis. However, rather than keeping track of a bunch of separate data calls with different names, it’s best to use a single object literal to house all of your variables, and access that object by a single data namespace.&lt;/p&gt;

&lt;p&gt;通常在插件开发中，可能需要维护状态或者检测插件在给定的元素上是否已被初始化。使用&lt;code&gt;jquery&lt;/code&gt; 的 &lt;code&gt;data&lt;/code&gt; 方法可以很好的跟踪基于每一个元素的变量。然而，相比跟踪大量有着不同名字的单独数据，还不如使用一个单独对象的字面量去存储所有变量并通过单一数据命名空间来访问此对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function( $ ){
    var methods = {
        init : function( options ) {
            return this.each(function(){
                var $this = $(this),
                data = $this.data('tooltip'),
                tooltip = $('&amp;lt;div /&amp;gt;', {
                    text : $this.attr('title')
                });
            // If the plugin hasn't been initialized yet
                if ( ! data ) {
                    /*
                    Do more setup stuff here
                    */
                    $(this).data('tooltip', {
                        target : $this,
                        tooltip : tooltip
                    });
                }
            });
        },
        destroy : function( ) {
            return this.each(function(){
                var $this = $(this),
                data = $this.data('tooltip');
                // Namespacing FTW
                $(window).unbind('.tooltip');
                data.tooltip.remove();
                $this.removeData('tooltip');
            })
        },
        reposition : function( ) { // ... },
        show : function( ) { // ... },
        hide : function( ) { // ... },
        update : function( content ) { // ...}
    };

    $.fn.tooltip = function( method ) {
        if ( methods[method] ) {
            return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.tooltip' );
        }   
    };
})( jQuery );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using data helps you keep track of variables and state across method calls from your plugin. Namespacing your data into one object literal makes it easy to access all of your plugin’s properties from one central location, as well as reducing the data namespace which allows for easy removal if need be.&lt;/p&gt;

&lt;p&gt;使用数据有助于跟踪变量及来自插件方法调用间的状态。命名空间数据到一个对象字面量中，从一个中心位置来访问  以便从一个中心位置容易的访问所有的插件属性，同时如果有需要还可以轻松的移除不需要的命名空间。&lt;/p&gt;

&lt;h2 id=&quot;summary-and-best-practices&quot;&gt;总结和最佳实践(Summary and Best Practices)&lt;/h2&gt;

&lt;p&gt;Writing jQuery plugins allows you to make the most out of the library and abstract your most clever and useful functions out into reusable code that can save you time and make your development even more efficient. Here’s a brief summary of the post and what to keep in mind when developing your next jQuery plugin:&lt;/p&gt;

&lt;p&gt;编写&lt;code&gt;jQuery&lt;/code&gt;插件允许你实现最有利用效率的库，允许你抽象有用的函数到可重用代码中，从而为你节省大量开发时间，使你的开发团队更加高效。下面是一些一些在开发&lt;code&gt;jQuery&lt;/code&gt;插件过程中应时刻牢记的简要的总结：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Always wrap your plugin in a closure: (function( $ ){ /* plugin goes here */ })( jQuery );&lt;/p&gt;

    &lt;p&gt;始终将你的插件封装在一个闭包中：&lt;code&gt;(function($) { /* plugin goes here */ })( jQuery );&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Don’t redundantly wrap the this keyword in the immediate scope of your plugin’s function&lt;/p&gt;

    &lt;p&gt;不要在插件函数的当前作用域中使用&lt;code&gt;$(this)&lt;/code&gt;多余的处理 &lt;em&gt;this&lt;/em&gt; 关键字。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unless you’re returning an intrinsic value from your plugin, always have your plugin’s function return the this keyword to maintain chainability.&lt;/p&gt;

    &lt;p&gt;除非返回一个内部值，否则总是让你的插件函数返回 &lt;em&gt;this&lt;/em&gt; 关键字以保持链通性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Rather than requiring a lengthy amount of arguments, pass your     plugin settings in an object literal that can be extended over the plugin’s defaults.&lt;/p&gt;

    &lt;p&gt;不要为你的插件函数定义过多的参数，而是通过传递一个可被扩展到插件默认值的对象字面量来传递参数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Don’t clutter the jQuery.fn object with more than one namespace per plugin.&lt;/p&gt;

    &lt;p&gt;保证每个插件中只有一个 &lt;code&gt;jQuery.fn&lt;/code&gt; 对象的命名空间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Always namespace your methods, events and data.&lt;/p&gt;

    &lt;p&gt;总是为自己的方法、事件和数据设置命名空间。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;translations&quot;&gt;Translations&lt;/h2&gt;

&lt;p&gt;If you have translated this article or have some similar one on your blog post a link here. Please mark Full Translated articles with (t) and similar ones with (s).&lt;/p&gt;
</description>
      <pubDate>Sun, 02 Dec 2012 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2012/12/02/jquery-plugins-authoring</guid>
      <dc:date>2012-12-02T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>mybatis参数映射</title>
      <link>http://leeyee.github.io/blog/2012/09/27/mybatis-param-mapping-rules</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;规则&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;示例&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;非注解型&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;一个参数&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;多个参数&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;注解型&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;一个参数&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-7&quot;&gt;多个参数&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot;&gt;非注解和注解型混合型&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-9&quot;&gt;框架主要映射处理代码&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-10&quot;&gt;参数的获取&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#sql&quot;&gt;SQL预编译参数设置&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;规则&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;非&lt;code&gt;@Param&lt;/code&gt;注解参数时可使用&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #{参数位置[0..n-1]}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;或者&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #{param[1..n]}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;如果参数类型是自定义对象(bean)时,只需加上&lt;code&gt;.对象属性&lt;/code&gt;即可&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #{参数位置[0..n-1].对象属性}
 #{param[1..n].对象属性}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;特别的，如果非注解参数只有一个时，可使用&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #{任意字符}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;来访问参数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;@Param&lt;/code&gt;的作用是设置参数别名。设置后的参数只能通过&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #{注解别名}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;或者&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #{param[1..n]}     
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;如果参数类型是自定义对象(bean)时,只需加上&lt;code&gt;.对象属性&lt;/code&gt;即可&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  #{注解别名.属性}
  #{param[1..n].属性}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;来访问参数&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;示例&lt;/h3&gt;

&lt;p&gt;为了明确上述规则，我们的示例具体细分了各种情况进行展示。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;非注解型&lt;/h4&gt;

&lt;h5 id=&quot;section-3&quot;&gt;一个参数&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;User getUserById(int id);

select * from &amp;lt;TABLE&amp;gt; where id = #{id}
// or
select * from &amp;lt;TABLE&amp;gt; where id = #{abdc}
// or
select * from &amp;lt;TABLE&amp;gt; where id = #{param1}

User getUser(User user); // user.getName user.getAge 

select * from &amp;lt;TABLE&amp;gt; where name = #{name} and age = #{age}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-4&quot;&gt;多个参数&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;User getUser(String name, int age);  
    
select * from &amp;lt;TABLE&amp;gt; where name = #{0} and age = #{1}  
// or  
select * from &amp;lt;TABLE&amp;gt; where name = #{param1} and age = #{param2}  
 
User getUser(User usr, int flag);  

select * from &amp;lt;TABLE&amp;gt; where name = #{0.name} and age = {0.age} and flag = #{1}  
// or  
select * from &amp;lt;TABLE&amp;gt; where name = #{param1.name} and age = {param1.age} and flag = #{param2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-5&quot;&gt;注解型&lt;/h4&gt;

&lt;h5 id=&quot;section-6&quot;&gt;一个参数&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;User getUserById(@Param(value=&quot;keyId&quot;) int id);  

select * from &amp;lt;TABEL&amp;gt; where id = #{keyId}  
// or  
select * from &amp;lt;TABLE&amp;gt; where id = #{param1}  
     
User getUser(@Param(value=&quot;user&quot;) User user); // user.getName user.getAge  

select * from &amp;lt;TABLE&amp;gt; where name = #{user.name} and age = #{user.age}  
// or  
select * from &amp;lt;TABLE&amp;gt; where name = #{param1.name} and age = #{param1.age}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-7&quot;&gt;多个参数&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;User getUser(@Param(value=&quot;xm&quot;) String name, @Param(value=&quot;nl&quot;) int age);  

select * from &amp;lt;TABLE&amp;gt; where name = #{xm} and age = #{nl}  
// or  
select * from &amp;lt;TABLE&amp;gt; where name = #{param1} and age = #{param2}  
// or  
select * from &amp;lt;TABLE&amp;gt; where name = #{xm} and age = #{param2}  
  
User getUser(@Param(value=&quot;usr&quot;) User user, @Param(value=&quot;tag&quot;) int flag); 

select * from &amp;lt;TABLE&amp;gt; where name = #{usr.name} and age = #{usr.age} and flag = #{tag}  
// or  
select * from &amp;lt;TABLE&amp;gt; where name = #{param1.name} and age = #{param1.age} and flag = #{param2}  
// or  
select * from &amp;lt;TABLE&amp;gt; where name = #{usr.name} and age = #{param1.age} and flag = #{param2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-8&quot;&gt;非注解和注解型混合型&lt;/h4&gt;

&lt;p&gt;当采用部分参数使用&lt;code&gt;@Param&lt;/code&gt;注解时，参数注释为将以上两种情况结合起来即可.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;User getUser(String name, @Param(value=&quot;nl&quot;) age, int gendar);  
  
// 对于age的访问不能是 #{1} 只能是 #{param2} | #{nl}  
select * from &amp;lt;TABLE&amp;gt; where name = #{0} and age = #{nl} and gendar = #{param3)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-9&quot;&gt;框架主要映射处理代码&lt;/h3&gt;

&lt;h4 id=&quot;section-10&quot;&gt;参数的获取&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;org.apache.ibatis.binding.MapperMethod&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Object getParam(Object[] args) {  
    final int paramCount = paramPositions.size();  
    // 无参数  
    if (args == null || paramCount == 0) {  
        return null;  
    // 无注解并参数个数为1  
    } else if (!hasNamedParameters &amp;amp;&amp;amp; paramCount == 1) {  
        return args[paramPositions.get(0)];  
    } else {  
        Map&amp;lt;String, Object&amp;gt; param = new MapperParamMap&amp;lt;Object&amp;gt;();  
        for (int i = 0; i &amp;lt; paramCount; i++) {  
            param.put(paramNames.get(i), args[paramPositions.get(i)]);  
    }  
    // issue #71, add param names as param1, param2...but ensure backward compatibility  
    // 这就是 #{param[1..n]} 的来源  
    for (int i = 0; i &amp;lt; paramCount; i++) {  
        String genericParamName = &quot;param&quot; + String.valueOf(i + 1);  
        if (!param.containsKey(genericParamName)) {  
            param.put(genericParamName, args[paramPositions.get(i)]);  
        }  
    }  
    return param;  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;sql&quot;&gt;SQL预编译参数设置&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;org.apache.ibatis.executor.parameter.DefaultParameterHandler&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void setParameters(PreparedStatement ps) throws SQLException {  
    ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId());  
    List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();  
    if (parameterMappings != null) {  
        MetaObject metaObject = parameterObject == null ? null : configuration.newMetaObject(parameterObject);  
        for (int i = 0; i &amp;lt; parameterMappings.size(); i++) {  
            ParameterMapping parameterMapping = parameterMappings.get(i);  
            if (parameterMapping.getMode() != ParameterMode.OUT) {  
                Object value;  
                String propertyName = parameterMapping.getProperty();  
                PropertyTokenizer prop = new PropertyTokenizer(propertyName);  
                if (parameterObject == null) {  
                    value = null;  
                } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {  
                    value = parameterObject;  
                } else if (boundSql.hasAdditionalParameter(propertyName)) {  
                    value = boundSql.getAdditionalParameter(propertyName);  
                } else if (propertyName.startsWith(ForEachSqlNode.ITEM_PREFIX)  
          &amp;amp;&amp;amp; boundSql.hasAdditionalParameter(prop.getName())) {  
                    value = boundSql.getAdditionalParameter(prop.getName());  
                    if (value != null) {  
                        value = configuration.newMetaObject(value).getValue(propertyName.substring(prop.getName().length()));  
                    }  
            } else {  
                value = metaObject == null ? null : metaObject.getValue(propertyName);  
            }  
            TypeHandler typeHandler = parameterMapping.getTypeHandler();  
            if (typeHandler == null) {  
                throw new ExecutorException(&quot;There was no TypeHandler found for parameter &quot; + propertyName + &quot; of statement &quot; + mappedStatement.getId());  
            }  
            JdbcType jdbcType = parameterMapping.getJdbcType();  
            if (value == null &amp;amp;&amp;amp; jdbcType == null) jdbcType = configuration.getJdbcTypeForNull();  
                typeHandler.setParameter(ps, i + 1, value, jdbcType);  
            }  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Thu, 27 Sep 2012 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2012/09/27/mybatis-param-mapping-rules</guid>
      <dc:date>2012-09-27T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>jQuery eTable Plugin</title>
      <link>http://leeyee.github.io/blog/2012/05/05/jquery-etable-plugin</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#etable&quot;&gt;eTable对象的获取&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#etable-api&quot;&gt;eTable API&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#getrows-&quot;&gt;&lt;strong&gt;.getRows()&lt;/strong&gt; 获取表格行数.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#getcols-&quot;&gt;&lt;strong&gt;.getCols()&lt;/strong&gt; 获取表格的列数.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#appendrow-&quot;&gt;&lt;strong&gt;.appendRow()&lt;/strong&gt; 追加行.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#inserttofirstrow-&quot;&gt;&lt;strong&gt;.insertToFirstRow()&lt;/strong&gt; 在首行前插入一行.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#inserttolastrow-appendrow&quot;&gt;&lt;strong&gt;.insertToLastRow()&lt;/strong&gt; 在尾行后插入一行.同&lt;code&gt;.appendRow()&lt;/code&gt;方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#insertbeforerow-&quot;&gt;&lt;strong&gt;.insertBeforeRow()&lt;/strong&gt; 在指定行前插入一行.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#insertafterrow-&quot;&gt;&lt;strong&gt;.insertAfterRow()&lt;/strong&gt; 在指定行后插入一行.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#deletefirstrow-&quot;&gt;&lt;strong&gt;.deleteFirstRow()&lt;/strong&gt; 删除首行.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#deletelastrow-&quot;&gt;&lt;strong&gt;.deleteLastRow()&lt;/strong&gt; 删除尾行.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#deleterow-deleterow0&quot;&gt;&lt;strong&gt;.deleteRow()&lt;/strong&gt; 删除指定行.删除第一行为&lt;code&gt;deleteRow(0);&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#deleterows-&quot;&gt;&lt;strong&gt;.deleteRows()&lt;/strong&gt; 批量删除行.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#appendcol-&quot;&gt;&lt;strong&gt;.appendCol()&lt;/strong&gt; 在尾列后追加一列.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#inserttofirstcol-&quot;&gt;&lt;strong&gt;.insertToFirstCol()&lt;/strong&gt; 在首列前插入一列.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#inserttolastcol-appendcol&quot;&gt;&lt;strong&gt;.insertToLastCol()&lt;/strong&gt; 在尾列后插入一列.同&lt;code&gt;.appendCol()&lt;/code&gt;方法.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#insertbeforecol-&quot;&gt;&lt;strong&gt;.insertBeforeCol()&lt;/strong&gt; 在指定列前插入一列.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#insertaftercol-&quot;&gt;&lt;strong&gt;.insertAfterCol()&lt;/strong&gt; 在指定列后插入一列.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#deletefirstcol-&quot;&gt;&lt;strong&gt;.deleteFirstCol()&lt;/strong&gt; 删除首列.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#deletelastcol-&quot;&gt;&lt;strong&gt;.deleteLastCol()&lt;/strong&gt; 删除尾列&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#deletecol-deletecol0&quot;&gt;&lt;strong&gt;.deleteCol()&lt;/strong&gt; 删除指定列.删除第一列为&lt;code&gt;deleteCol(0);&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#deletecols-&quot;&gt;&lt;strong&gt;.deleteCols()&lt;/strong&gt; 批量删除列.&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;jQuery eTable Plugin 提供对表格操作的一些基本方法.其实质是通过&lt;code&gt;$(table).eTable()&lt;/code&gt;获取封装了表格元素的&lt;code&gt;ETable&lt;/code&gt;对象.&lt;code&gt;eTable&lt;/code&gt;对象封装了一些列针对表格行列进行操作的方法。使用这些方法可以对表格进行行列的插入与删除。&lt;/p&gt;

&lt;h3 id=&quot;etable&quot;&gt;eTable对象的获取&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var $eTable = $(&quot;#table1&quot;).eTable();
var $eTable = $(document.getElementById('table1')).eTable();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;etable-api&quot;&gt;eTable API&lt;/h3&gt;

&lt;h4 id=&quot;getrows-&quot;&gt;&lt;strong&gt;.getRows()&lt;/strong&gt; 获取表格行数.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var rows = $eTable.getRows();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;getcols-&quot;&gt;&lt;strong&gt;.getCols()&lt;/strong&gt; 获取表格的列数.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var cols = $eTable.getCols();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;appendrow-&quot;&gt;&lt;strong&gt;.appendRow()&lt;/strong&gt; 追加行.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var cells = ['cell1','cell2','cell3'];
var cells1 = [
    $(&quot;&amp;lt;input type='text'/&amp;gt;&quot;).blur(function() {
        alert(this.value);
    }),
    &quot;&amp;lt;input type='radio' /&amp;gt;&quot;
];
$eTable.appendRow(cells);
$eTable.appendRow(cells1);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;inserttofirstrow-&quot;&gt;&lt;strong&gt;.insertToFirstRow()&lt;/strong&gt; 在首行前插入一行.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var cells = ['cell1','cell2','cell3'];
$eTable.insertToFristRow();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;inserttolastrow-appendrow&quot;&gt;&lt;strong&gt;.insertToLastRow()&lt;/strong&gt; 在尾行后插入一行.同&lt;code&gt;.appendRow()&lt;/code&gt;方法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var cells = ['cell1','cell2','cell3'];
$eTable.insertToLastRow(cells);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;insertbeforerow-&quot;&gt;&lt;strong&gt;.insertBeforeRow()&lt;/strong&gt; 在指定行前插入一行.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var cells = ['cell1','cell2','cell3'];
$eTable.insertBeforeRow(3,cells); // 在第3行前插入
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;insertafterrow-&quot;&gt;&lt;strong&gt;.insertAfterRow()&lt;/strong&gt; 在指定行后插入一行.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var cells = ['cell1','cell2','cell3'];
$eTable.insertAfterRow(3,cells); // 在第3行后插入
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;deletefirstrow-&quot;&gt;&lt;strong&gt;.deleteFirstRow()&lt;/strong&gt; 删除首行.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$eTable.deleteFirstRow();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;deletelastrow-&quot;&gt;&lt;strong&gt;.deleteLastRow()&lt;/strong&gt; 删除尾行.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$eTable.deleteLastRow();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;deleterow-deleterow0&quot;&gt;&lt;strong&gt;.deleteRow()&lt;/strong&gt; 删除指定行.删除第一行为&lt;code&gt;deleteRow(0);&lt;/code&gt;.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var ches = $(&quot;table :checked&quot;);
var iLen = ches.length;
if (iLen === 0) {
    alert(&quot;Please select Delete Rows&quot;);
    return;
}
for (var i = 0; i &amp;lt; iLen; i++) {
    var index = ches[i].parentNode.parentNode.rowIndex;
    $eTable.deleteRow(index);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;deleterows-&quot;&gt;&lt;strong&gt;.deleteRows()&lt;/strong&gt; 批量删除行.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var rowIndexs = [0, 2, 3];
$eTable.deleteRows(rowIndexs); //删除第1、3、4行
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;appendcol-&quot;&gt;&lt;strong&gt;.appendCol()&lt;/strong&gt; 在尾列后追加一列.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var cells = ['cell1','cell2','cell3'];
$eTable.appendCol(cells);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;inserttofirstcol-&quot;&gt;&lt;strong&gt;.insertToFirstCol()&lt;/strong&gt; 在首列前插入一列.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var cells = ['cell1','cell2','cell3'];
$eTable.insertToFirstCol(cells);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;inserttolastcol-appendcol&quot;&gt;&lt;strong&gt;.insertToLastCol()&lt;/strong&gt; 在尾列后插入一列.同&lt;code&gt;.appendCol()&lt;/code&gt;方法.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var cells = ['cell1','cell2','cell3'];
$eTable.insertToLastCol(cells);    
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;insertbeforecol-&quot;&gt;&lt;strong&gt;.insertBeforeCol()&lt;/strong&gt; 在指定列前插入一列.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var cells = ['cell1','cell2','cell3'];
$eTable.insertBeforeCol(2,cells); //在第2列前插入
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;insertaftercol-&quot;&gt;&lt;strong&gt;.insertAfterCol()&lt;/strong&gt; 在指定列后插入一列.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var cells = ['cell1','cell2','cell3'];
$eTable.insertAfterCol(2,cells); //在第2列后插入
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;deletefirstcol-&quot;&gt;&lt;strong&gt;.deleteFirstCol()&lt;/strong&gt; 删除首列.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$eTable.deleteFirstCol();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;deletelastcol-&quot;&gt;&lt;strong&gt;.deleteLastCol()&lt;/strong&gt; 删除尾列&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$eTable.deleteLastCol();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;deletecol-deletecol0&quot;&gt;&lt;strong&gt;.deleteCol()&lt;/strong&gt; 删除指定列.删除第一列为&lt;code&gt;deleteCol(0);&lt;/code&gt;.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$eTable.deleteCol(3); //删除第4列
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;deletecols-&quot;&gt;&lt;strong&gt;.deleteCols()&lt;/strong&gt; 批量删除列.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var colIndexs = [0,2,3];
$eTable.deleteCols(colIndexs); //删除第1,3,4行
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Sat, 05 May 2012 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2012/05/05/jquery-etable-plugin</guid>
      <dc:date>2012-05-05T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>jQuery MsgBox Plugin</title>
      <link>http://leeyee.github.io/blog/2012/05/04/jquery-msgbox-plugin</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#jmaskoptions-&quot;&gt;jmask(options) 遮罩层&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#junmask-&quot;&gt;junmask() 关闭遮罩层&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jalertmsgoptions-&quot;&gt;jalert(msg,options) 消息框&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jconfirmmsgurloptions-&quot;&gt;jconfirm(msg,url,options) 消息确认框&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jmaskoptions-&quot;&gt;jmask(options) 遮罩层&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;移动目标元素对象，使其显示在遮罩层正中央。 &lt;code&gt;jmask&lt;/code&gt; 接受一个参数.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;options&lt;/strong&gt;: 该参数为对象类型。用来设置遮罩层默认全局属性,默认属性为：&lt;/p&gt;

  &lt;pre&gt;&lt;code&gt;$.fn.jmask.defaults = {
	bgcolor : '#eee',
	opacity : 0.8
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&quot;#jmaskDemo&quot;).jmask();
$(&quot;#jmaskDemo&quot;).jmask({
    bgcolor:'pink',
    opacity : 0.6
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;junmask-&quot;&gt;junmask() 关闭遮罩层&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;取消使用 &lt;code&gt;jmask&lt;/code&gt; 方法遮罩的目标元素,并隐藏目标元素。该方法不接受参数.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&quot;#jmaskDemo&quot;).junmask();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;jalertmsgoptions-&quot;&gt;jalert(msg,options) 消息框&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;打开一个消息提示框。 &lt;code&gt;jalert&lt;/code&gt; 接受两个参数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;msg&lt;/strong&gt;: 消息框显示的消息內容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;options&lt;/strong&gt;: 该参数为对象类型，用来设置消息框全局属性,默认属性为：&lt;/p&gt;

  &lt;pre&gt;&lt;code&gt;$.fn.jalert.defaults = {
	    title : '消息框',
        width : 320,
        height : 240,
        mask : true,
       	maskcolor : '#eee',
		maskopacity : 0.8
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&quot;#jalertDemo&quot;).jalert('jalert demo 测试');
$(&quot;#jalertDemo&quot;).jalert('jalert demo 测试',{ 
    title : 'hello jalert', 
    width : 300, 
    height : 250, 
    mask : false
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;jconfirmmsgurloptions-&quot;&gt;jconfirm(msg,url,options) 消息确认框&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;打开一个消息确认框。 &lt;code&gt;jconfirm&lt;/code&gt; 接受两个参数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;msg&lt;/strong&gt;: 消息框显示的消息內容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;options&lt;/strong&gt;: 该参数为对象类型，用来设置消息框全局属性,默认属性为：&lt;/p&gt;

  &lt;pre&gt;&lt;code&gt;$.fn.jconfirm.defaults = {
	title : '确认消息框',
    width : 320,
    height : 240,
    mask : true,
    maskcolor : '#eee',
	maskopacity : 0.8
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&quot;#jconfirmDemo&quot;).jconfirm('jconfirm demo 测试','http://www.163.com');
$(&quot;#jconfirmDemo&quot;).jconfirm('jconfirm demo 测试',null,{
    title : 'hello jconfirm', 
    width : 400, 
    height : 300, 
    maskcolor : 'pink',
    maskopacity : 0.9
});
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Fri, 04 May 2012 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2012/05/04/jquery-msgbox-plugin</guid>
      <dc:date>2012-05-04T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>PL/SQL常用函数</title>
      <link>http://leeyee.github.io/blog/2011/11/18/plsql-sql-comm-func</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;常用数字函数&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#demo&quot;&gt;demo:&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;常用字符函数&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#demo-1&quot;&gt;demo:&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;常用日期时间函数(一)&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#demo-2&quot;&gt;demo:&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;常用日期时间函数(二)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;转换函数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;其他单行当行函数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;分组函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;常用数字函数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;abs(n)&lt;/code&gt; : 返回n的绝对值&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ceil(n)&lt;/code&gt; : 返回大于等于数字n的最小整数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;floor(n)&lt;/code&gt; : 返回小于等于数字n的最大整数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mod(m,n)&lt;/code&gt; : 取m/n的余数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;power(m,n)&lt;/code&gt; : 返回m的n次幂&lt;/p&gt;

&lt;p&gt;&lt;code&gt;round(n[,m])&lt;/code&gt; : 执行四舍五入运算。省略m，则四舍五入到整数位；m为负，四舍五入到小数点前m位；m为正，四舍五入到小数点后m位&lt;/p&gt;

&lt;p&gt;&lt;code&gt;trunc(n[,m])&lt;/code&gt; : 截取数字。省略m，数字n去掉小数部分；m为负,数字n截取小数点前m位；m为正，数字n截取小数点后m位&lt;/p&gt;

&lt;h4 id=&quot;demo&quot;&gt;demo:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;select
    abs(-12),
    ceil(12.4),
    floor(12.9),
    mod(100,3),
    power(2,3),
    round(12.4),
    round(12.5),
    round(12.09,-1),
    round(12.09,1),
    trunc(30.3),
    trunc(20.358899,3),
    trunc(28.3565,-1)
from dual;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;常用字符函数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ascii(char)&lt;/code&gt; : char字符的ascii码&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chr(n)&lt;/code&gt; : 将ascii码值n转换成字符&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;concat(str1,str2)&lt;/code&gt; : 连接str1\str2为一个字符串。相当于连接符（&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;initcap(char)&lt;/code&gt; : 将字符串中的每个单词首字母大写，其他字符小写&lt;/p&gt;

&lt;p&gt;&lt;code&gt;instr(char1,char2[,n[,m]])&lt;/code&gt; : 获取子串char2在字符串char1中的位置。n为其实搜索位置，m为子串出现的次数；n为负，则从尾部开始搜索；n\m默认为1&lt;/p&gt;

&lt;p&gt;&lt;code&gt;length(char)&lt;/code&gt; : 返回字符串的长度。如果char = null则返回null&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lower(char)&lt;/code&gt; : 返回char的小写格式&lt;/p&gt;

&lt;p&gt;&lt;code&gt;upper(char)&lt;/code&gt; : 返回char的大写格式&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lpad(char1,n,char2)&lt;/code&gt; :  在字符串char1的左端填充字符串char2直到长度达到n;char2默认为空格，如果char1.length&amp;gt;n，则返回char1左端的n个字符&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rpad(char1,n,char2)&lt;/code&gt; :  在字符串char1的右端填充字符串char2直到长度达到n;char2默认为空格，如果char1.length&amp;gt;n，则返回char1左端的n个字符&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ltrim(char1[,set])&lt;/code&gt; : 去掉字符串char1左端包含的set中的任意字符。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rtrim(char1[,set])&lt;/code&gt; : 去掉字符串char1右端包含的set中的任意字符。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nls_initcap(char,'nls_param')&lt;/code&gt; : 同&lt;code&gt;initcap&lt;/code&gt;.但这里的char用于指定&lt;code&gt;NCHAR&lt;/code&gt;或者&lt;code&gt;NVARCHAR2&lt;/code&gt;类型字符串；&lt;code&gt;nls_param&lt;/code&gt;的格式为nls_sort=sort,用于指定特定语言特征&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nls_lower(char,'nls_param')&lt;/code&gt; : 同&lt;code&gt;lower&lt;/code&gt;,参数同&lt;code&gt;nls_initcap&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nls_upper(char,'nls_param')&lt;/code&gt; : 同&lt;code&gt;upper&lt;/code&gt;,参数同&lt;code&gt;nls_initcap&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;replace(char,search_str[,replacement_str])&lt;/code&gt; :  将字符串char中的子串search_str替换成replacement_str；如果search_str=null，返回char；如果replacement_str=null，则会去掉char中的search_str&lt;/p&gt;

&lt;p&gt;&lt;code&gt;soundex(char)&lt;/code&gt; : 返回字符串char的语音表示，使用该函数可比较发印相同的字符串&lt;/p&gt;

&lt;p&gt;&lt;code&gt;substr(char,m[,n])&lt;/code&gt; : 获取char的子字符串。m为字符起始位置，n为子串长度。m为0，从首字符开始;m为负从尾部开始&lt;/p&gt;

&lt;p&gt;&lt;code&gt;trim(char|char From string)&lt;/code&gt; : 从字符串的头尾或者两端截断特定字符。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;translate(string,from_str,to_str)&lt;/code&gt; : 将string按照from_str与to_str的对应关系进行转换&lt;/p&gt;

&lt;h4 id=&quot;demo-1&quot;&gt;demo:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;select 
    ascii('a'), -- 字符的assii码
    chr(68), -- 数字对应的字符
    concat('a','cd'), -- 字符串连接
    ('a'||'cd'), -- 字符串连接
    initcap('ok abc'),-- 单词首字母大写
    instr('abccdcdc','c',1,2),
    length(null), -- 字符串的长度
    length('abc'),
    lower('ABCD'),-- 小写字符串
    upper('abcd'),-- 大写字符串
    LPAD('ac',6,'$'), -- 在字符串前面填补$字段直到字符串长度达到6
    LPAD('accc',2,'$'), 
    RPAD('ac',4,'*'), -- 在字符串后面填补*字段直到字符串长度达到4
    RPAD('acccc',4,'*'),
    ltrim('1234','1'), -- 去掉字符串最左边为'1'的字符
    ltrim('1234','23'),
    rtrim('1234','234'), -- 去掉字符串最右边为'234'的字符
    rtrim('1234','23'),
    nls_initcap(n'ok abc'), -- 单词首字母大写
    nls_lower(n'SQL'), -- 单词小写
    replace('abc','b','123'), -- 字符串替换
    replace('abc','b'),
    replace('','b'),
    soundex('lawer'),-- 返回字符串语音表示
    soundex('lier'),
    soundex('ok'),
    substr('hello',2,2), -- 子字符串 substr(str,offset,len)
    substr('hello',2),
    substr('hello',-2),
    substr('hello',-3,2),
    translate('234abcd', '12345abcde','ahellojack'),
    '  adc',
    trim('  adc '), -- 去除字符串两端空格
    trim('a' from 'aa123ab') -- 去除字符串两端指定字符
from dual;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;常用日期时间函数(一)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;add_months(d,n)&lt;/code&gt; : 返回特定日期时间d前后的n个月所对应的日期时间。n为正整数表示之后，负整数表示之后&lt;/p&gt;

&lt;p&gt;&lt;code&gt;current_date&lt;/code&gt; : 返回当前会话时区所对应日期时间。Oracle9i新增&lt;/p&gt;

&lt;p&gt;&lt;code&gt;current_timestamp&lt;/code&gt; : 返回当前会话时区所对应详细日期时间。Oracle9i新增&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dbtimezone&lt;/code&gt; : 返回数据库所在时区。Oracle9i新增&lt;/p&gt;

&lt;p&gt;&lt;code&gt;extract&lt;/code&gt; : 从日期中获取所需要的特定数据。Oracle9i新增。比如：&lt;br /&gt;
    select&lt;br /&gt;
    	extract(year from sysdate)  –年&lt;br /&gt;
    	extract(month from sysdate) –月&lt;br /&gt;
    	extract(day from sysdate)   –日&lt;br /&gt;
    from dual;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;last_day(d)&lt;/code&gt; : 返回特定日期所在月份最后一天&lt;/p&gt;

&lt;p&gt;&lt;code&gt;months_between(d1,d2)&lt;/code&gt; : 返回日期d1和d2之间相差的月数。d1 &amp;lt; d2 返回负数；d1和d2天数相同或都是月底，返回整数；否则Oracle以每月31天为准来计算结果的小数部分。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;new_time(date,zone1,zone2)&lt;/code&gt; : 返回时区zone1对应的时区zone2的日期时间。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;next_day(d,char)&lt;/code&gt; : 返回指定日期d后的第一个工作日char所对应的日期。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select next_day(sysdate,'星期一') from dual;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;demo-2&quot;&gt;demo:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;select  
    to_char(sysdate,'yyyy-MM-dd hh24:mi:ss'),
    add_months(sysdate, 2), -- 当前时间加两个月
    current_date, -- 当前日期
    current_timestamp, -- 当前日期时间
    dbtimezone, -- 当前时区
    extract(year from sysdate) as year, -- 获取from日期的年份
    extract(month from sysdate) month, 
    extract(day from sysdate) day,
    from_tz(timestamp '2011-10-12 21:49:30','5:00'),
    last_day(sysdate), -- 当前日期所在月份的最后一天
    months_between(sysdate+1, sysdate) as 相差月数, 
    new_time(sysdate,'bst','est'),-- bst的时区对应est时区的时间
    next_day(sysdate,'星期二') -- 指定日期后的第一个工作日
from dual;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;常用日期时间函数(二)&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;numtodsinterval(n,char_expr)&lt;/code&gt; : 将数字n转换为INTERVAL DAY TO SECOND格式，char_expr可取 DAY&lt;/td&gt;
      &lt;td&gt;HOUR&lt;/td&gt;
      &lt;td&gt;MINUTE&lt;/td&gt;
      &lt;td&gt;SECOND&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;select 
    numtodsinterval(60,'SECOND'), -- 60秒
    numtodsinterval(60,'MINUTE'), -- 60分钟
    numtodsinterval(60,'HOUR'),-- 60小时
    numtodsinterval(60,'DAY'), -- 60天
from dual;
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;numtoyminterval(n,char_expr)&lt;/code&gt; : 将数字n转换为INTERVAL YEAR TO MONTH格式，char_expr可取 YEAR&lt;/td&gt;
      &lt;td&gt;MONTH&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;select 
    numtoyminterval(60,'MONTH'), -- 60月
    numtoyminterval（60,'YEAR'), -- 60年
from dual;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;round(d[,fmt])&lt;/code&gt; : 返回日期的四舍五入结果。如果fmt指定年度，则7月1日为分界线；如果fmt指定月，则16日为分界线；如果指定天，则中午12:00为分界线。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select 
    round(sysdate,'DAY'),   -- 四舍五入到天
    round(sysdate,'MONTH'), -- 四舍五入到月
    round(sysdate,'YEAR'),  -- 四舍五入到年
from dual;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sessiontimezone&lt;/code&gt; : 当前会话所在时区。Oracle9i新增&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sysdate&lt;/code&gt; : 系统日期时间&lt;/p&gt;

&lt;p&gt;&lt;code&gt;systimestamp&lt;/code&gt; : 系统日期时间及时区。Oracle9i新增&lt;/p&gt;

&lt;p&gt;&lt;code&gt;to_timestamp(char[fmt[,'nls_parame']])&lt;/code&gt; : 将符合指定日期和时间格式的字符串转变为&lt;code&gt;timestamp&lt;/code&gt;类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select to_timestamp('2012-09','yyyy-mm') from dual;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;trunc(d,[fmt])&lt;/code&gt; : 日期阶段函数。如果fmt指定年度，则结果为本年度的1月1日；如果为月，则将结果为本月1日&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select 
    trunc(sysdate,'MONTH'), -- 取到月
    trunc(sysdate,'YEAR'), -- 取到年
    trunc(sysdate,'mm')
from dual;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;转换函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;set serveroutput on ;
declare 
    v_cast varchar2(20);
begin
    v_cast := cast(sysdate as varchar2);
    dbms_output.put_line(v_cast);
end;

select 
    asciistr('中国'), -- 返回参数的数据库字符串的ascii字符串
    bin_to_num(1,0), -- 返回二进制10表示的十进制数
    cast('123' as number) , -- 将字符串123转成number类型输出
    convert('abc','us7ascii','we8iso8859p1') ,-- 将字符串有编码us7ascii转成we8iso8859p1编码
    to_char(n'中国'),
    to_nchar('中国'),
    to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),
    to_char(100,'L99G999D99MI'), -- 将数字100转换成人民币式字符串
    to_clob('abc'), -- 将字符串转化成clob类型
    to_date('2000-12-23','yyyy-mm-dd') ,-- 将字符日期格式转化成日期格式
    to_number('￥100','L99999D99')
from dual;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;其他单行当行函数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;decode(expr1,serch1,result,[search2,result2,...][,default)&lt;/code&gt; : 如果expr1 = serch1 输出 result …&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- id = 1, money * 10; id = 2, money * 20
select id,money, decode(id,1,money*10,2,money*20,money) from customer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;coalesce(expr1[,expr2][,expr3]..)&lt;/code&gt; : 返回表达式中第一个NOT NULL表达式的结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select coalesce(null,null,'ab') from dual;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;dump(expr,return_frm)&lt;/code&gt; : 返回表达式所对应的数据类型代码、长度及内部表示格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select dump('abc','1016') from dual;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;empty_blob()&lt;/code&gt; : 初始化&lt;code&gt;blob&lt;/code&gt;变量或字段&lt;/p&gt;

&lt;p&gt;&lt;code&gt;empty_clob()&lt;/code&gt; : 初始化&lt;code&gt;clob&lt;/code&gt;变量或字段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;update yt_uniform_information set content = empty_clob() where key_id = 20 ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&quot;label label-important&quot;&gt;&lt;em&gt;NOTES：&lt;/em&gt;&lt;/span&gt;
&lt;code&gt;content = empty_clob()&lt;/code&gt; 与 &lt;code&gt;content = null&lt;/code&gt;是不同的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;greatest(expr1[,expr2]...)&lt;/code&gt; : 返回表达式中值最大的一个&lt;/p&gt;

&lt;p&gt;&lt;code&gt;least(expr1[,expr2]...)&lt;/code&gt; : 返回表达式中值最小的一个&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nls_charset_id(text)&lt;/code&gt; : 返回字符集的id号&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nls_charset_name(number)&lt;/code&gt; : 返回特定ID号所对应的字符集名&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nls_charset_decl_len(byte_count,charset[id])&lt;/code&gt; : 返回字节数在特定字符集中占用的字符个数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nullif(expr1,expr2)&lt;/code&gt; : expr1 = expr2 返回 null ; 否则返回expr1。可用在字段上;Oracle9i新增&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nvl(expr1,expr2)&lt;/code&gt; : expr1 = null 返回 expr2 否则返回expr1&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nvl2(expr1,expr2,expr3)&lt;/code&gt; : expr1 != null 返回 expr2; expr1 = null 返回 expr3;参数expr1为任意数据类型，expr2、expr3为除&lt;code&gt;LONG&lt;/code&gt;之外的任何数据类型。Oracle9i新增&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sys_context('context','attribute')&lt;/code&gt; : 返回上下文特定属性值。context为应用上下文名 attribute为指定属性名&lt;/p&gt;

&lt;p&gt;&lt;code&gt;uid&lt;/code&gt; : 当前会话对应的用户ID号&lt;/p&gt;

&lt;p&gt;&lt;code&gt;user&lt;/code&gt; : 当前会话对应数据库用户名&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;userenv(parameter)&lt;/code&gt; : 返回当前上下文的属性信息。paramer = isdba&lt;/td&gt;
      &lt;td&gt;language&lt;/td&gt;
      &lt;td&gt;terminal&lt;/td&gt;
      &lt;td&gt;client_info&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;vsize(expr)&lt;/code&gt; : oracle内部存储expr的实际字节数.只能在SQL语句中使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select 
    greatest(1,2,4,4,10), 
    least(1,2,4,4,10), 
    nullif('abc','abc'),
    nvl(100,23),
    sys_context('userenv','os_user') &quot;OS用户&quot;,
    sys_context('userenv','session_user') &quot;数据库用户&quot; , 
    uid,
    user,
    userenv('isdba'), -- 是否具有DBA权限
    userenv('language'), -- 当前会话语言地区和字符集
    userenv('terminal'), -- 当期会话所在终端的OS标识符 
    userenv('client_info'), -- 返回有包dbms_application_info所存储的用户会话信息（最长64字节）
    vsize('ad')
from dual;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sys_dburigen(colname)&lt;/code&gt; ：根据列或者属性生成类型为DBUriType的URL&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sys_xmlgen(expr[,fmt])&lt;/code&gt; : 根据数据库表的行和列生成一个XMLType实例&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sys_xmlagg(expr[,fmt])&lt;/code&gt; : 汇总所有xml文档，并生成一个xml文档(用于可分组的数据列中(一对多))&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xmlelement(identifier[,xml_attribute_clause][,value_expr]&lt;/code&gt; : 返回XMLType实例.identifier必选，指定元素名，xml_attribute_clause可选，指定元素属性子句，value_expr可选，指定元素值&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xmlcolattval(value_expr1[,value_expr2]...)&lt;/code&gt; : 生成XML块，并增加column做为属性名&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xmlconcat(XMLType_instance1[,XMLType_instance2]...)&lt;/code&gt; : 连接多个XMLType实例，并生成一个新的XMLType实例&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xmlforest(value_expr1[,value_expr2]...)&lt;/code&gt; : 返回XML块&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xmlsequence(XMLType_instance)&lt;/code&gt; : 返回XMLType实例中顶级节点一下的&lt;code&gt;VARRAY&lt;/code&gt;元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select 
    name, 
    sys_dburigen(name),
    sys_xmlgen(name),
    xmlelement(id,name,money), -- &amp;lt;id&amp;gt;namemoney&amp;lt;/id&amp;gt;
    xmlcolattval(name), -- &amp;lt;column name = &quot;NAME&quot;&amp;gt;leeyee&amp;lt;/column&amp;gt;
    xmlcolattval(name,money), -- &amp;lt;column name = &quot;NAME&quot;&amp;gt;leeyee&amp;lt;/column&amp;gt;&amp;lt;column name = &quot;MONEY&quot;&amp;gt;12.23&amp;lt;/column&amp;gt;
    xmlelement(&quot;customer&quot;,xmlcolattval(id,name,money)),
    xmlconcat(xmlelement(id,name),xmlelement(money,money)),
    xmlforest(name,money),
    xmlsequence(xmlelement(&quot;customer&quot;,xmlcolattval(id,name,money)))
from customer a ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sys_xmlagg(expr[,fmt])&lt;/code&gt; : 汇总所有xml文档，并生成一个xml文档&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xmlagg(XMLType_instance[ORDER BY sor_list])&lt;/code&gt; : 汇总多个XML块，生成XML文档。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select 
    sys_xmlagg(sys_xmlgen(name)),
    xmlagg(xmlelement(name,name)),
from yt_site_function_menu where function = 3

create table xml_tables of xmltype;
insert into xml_tables values(xmltype('&amp;lt;address&amp;gt;
    &amp;lt;province name=&quot;北京市&quot;&amp;gt;
	    &amp;lt;city name=&quot;北京辖区&quot;&amp;gt;
		    &amp;lt;country name=&quot;东城区&quot; /&amp;gt;
		    &amp;lt;country name=&quot;西城区&quot; /&amp;gt;
		    &amp;lt;country name=&quot;崇文区&quot; /&amp;gt;
		    &amp;lt;country name=&quot;宣武区&quot; /&amp;gt;
	    &amp;lt;/city&amp;gt;
	    &amp;lt;city name=&quot;北京辖县&quot;&amp;gt;
		    &amp;lt;country name=&quot;密云县&quot; /&amp;gt;
		    &amp;lt;country name=&quot;延庆县&quot; /&amp;gt;
	    &amp;lt;/city&amp;gt;
    &amp;lt;/province&amp;gt;
    &amp;lt;province name=&quot;天津市&quot;&amp;gt;
	    &amp;lt;city name=&quot;天津辖区&quot;&amp;gt;
		    &amp;lt;country name=&quot;和平区&quot; /&amp;gt;
		    &amp;lt;country name=&quot;河东区&quot; /&amp;gt;
	    	&amp;lt;country name=&quot;河西区&quot; /&amp;gt;
		    &amp;lt;country name=&quot;南开区&quot; /&amp;gt;
		    &amp;lt;country name=&quot;河北区&quot; /&amp;gt;
	    &amp;lt;/city&amp;gt;
	    &amp;lt;city name=&quot;天津辖县&quot;&amp;gt;
		    &amp;lt;country name=&quot;宁河县&quot; /&amp;gt;
		    &amp;lt;country name=&quot;静海县&quot; /&amp;gt;
		    &amp;lt;country name=&quot;蓟县&quot; /&amp;gt;
	    &amp;lt;/city&amp;gt;
    &amp;lt;/province&amp;gt;
&amp;lt;/address&amp;gt;'));
insert into xml_tables values(xmltype('&amp;lt;body&amp;gt;
    &amp;lt;form onsubmit=&quot;javascript:return check(this);&quot;&amp;gt;
	    &amp;lt;button onclick=&quot;test();&quot;&amp;gt;fd&amp;lt;/button&amp;gt;
	    &amp;lt;div id=&quot;ad&quot;&amp;gt;&amp;lt;/div&amp;gt;
	    &amp;lt;input type=&quot;submit&quot; value=&quot;check&quot; /&amp;gt;
    &amp;lt;/form&amp;gt;
    &amp;lt;div id=&quot;test&quot;&amp;gt;作为试验，还是让我们来测试一下效果吧。&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;'));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;existsnode(xmltype_instance,Xpath_string)&lt;/code&gt; : 确定xml节点路径是否存在。存在返回1否则返回0&lt;/p&gt;

&lt;p&gt;&lt;code&gt;extract(xmltype_instance,Xpath_string)&lt;/code&gt; : 返回xml节点路径下的内容&lt;/p&gt;

&lt;p&gt;&lt;code&gt;extractvalue(xmltype_instance,Xpath_string)&lt;/code&gt; : 返回xml节点路径下的内容值&lt;/p&gt;

&lt;p&gt;&lt;code&gt;updatexml(xmltype_instance,Xpath_string,value_expr)&lt;/code&gt; : 更新特定XMLType实例相应节点路径内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select 
    -- p.*,
    existsnode(value(p),'/address/province/city[0]'),
    extract(value(p),'/address/province[1]/city[1]/country[1]'),  
    extract(value(p),'/body/div'),
    extractvalue(value(p),'/body/div'),
    xmlsequence(extract(value(p),'/address/province/city/*'))
from xml_tables p ;

update xml_tables p set p=updatexml(value(p),'/body/div/text()','作为试验，还是让我们来测试一下效果吧。');
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;分组函数&lt;/h3&gt;

&lt;p&gt;具体请查看&lt;a href=&quot;/blog/2011/11/16/plsql-sql-groupby/&quot;&gt;SQL分组语句要点&lt;/a&gt;&lt;/p&gt;

</description>
      <pubDate>Fri, 18 Nov 2011 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2011/11/18/plsql-sql-comm-func</guid>
      <dc:date>2011-11-18T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>SQL查询语句要点</title>
      <link>http://leeyee.github.io/blog/2011/11/17/plsql-sql-select</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;内连接和外连接&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;内连接&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;外连接&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;左外连接&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;右外连接&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;完全外连接&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;使用&lt;code&gt;(+)&lt;/code&gt;操作符&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot;&gt;子查询&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot;&gt;单行子查询&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-9&quot;&gt;多行子查询&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-10&quot;&gt;多列子查询&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-11&quot;&gt;其他子查询&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-12&quot;&gt;相关子查询&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#from&quot;&gt;在from子句中使用子查询&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#dml&quot;&gt;在&lt;code&gt;DML&lt;/code&gt;语句中使用子查询&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-13&quot;&gt;合并查询&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#union&quot;&gt;union&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#union-all&quot;&gt;union all&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#intersect&quot;&gt;intersect&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#minus&quot;&gt;minus&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-14&quot;&gt;其他复杂查询&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-15&quot;&gt;层次查询&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#case&quot;&gt;case表达式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#with&quot;&gt;使用with语句重用子查询&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-16&quot;&gt;倒叙查询&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;内连接和外连接&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;select table1.column, table2.column
    from table1 [inner | left | rigth | full ] join table2 ON table1.column1 = table2.column2;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;内连接&lt;/h3&gt;

&lt;p&gt;内连接用于返回满足连接条件的所有记录；默认情况下，在执行连接查询时如果没有指定任何连接操作符，那么这些连接查询都属于内连接。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; select a.dname,b.ename from department a, employee b where a.deptNo = b.deptNo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; select a.dame,b.ename from department a inner join employee b ON a.deptNo = b.deptNo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&quot;label label-important&quot;&gt;&lt;em&gt;NOTES：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;从Ooracle9i开始，如果主表主键列和从表外键列名称相同，那么还可以使用&lt;code&gt;natural join&lt;/code&gt;关键字自动执行内连接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; select dname,ename from department natrual join employee;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;外连接&lt;/h3&gt;

&lt;p&gt;外连接是内连接的扩展，不仅会返回满足连接条件的所有记录，还会返回不满足连接条件的记录。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;左外连接&lt;/h4&gt;

&lt;p&gt;左外连接通过&lt;code&gt;left [outer] join&lt;/code&gt;实现。左外连接返回满足连接条件的记录，同时返回不满足条件的连接操作符左边表的其他行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; select a.dname, b.ename from department a left join employee b on a.deptno = b.deptno;
    
	dname       ename
	------		-------
	test		king
	test 		king2
	test1				
	test2
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;右外连接&lt;/h4&gt;

&lt;p&gt;右外连接通过&lt;code&gt;rigth [outer] join&lt;/code&gt;实现。右外连接返回满足连接条件的记录，同时返回不满足条件的连接操作符右边表的其他行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; select a.dname, b.ename from department a right join employee b on a.deptno = b.deptno;
    
	dname       ename
	------		-------
	test		king
	test 		king2
				king3
				king4
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-5&quot;&gt;完全外连接&lt;/h4&gt;

&lt;p&gt;完全外连接通过&lt;code&gt;full [outer] join&lt;/code&gt;实现。完全外连接时左外连接和右外连接的结合。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; select a.dname, b.ename from department a full join employee b on a.deptno = b.deptno;
    
	dname       ename
	------		-------
	test		king
	test 		king2
	test1
	test2
				king3
				king4		
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-6&quot;&gt;使用&lt;code&gt;(+)&lt;/code&gt;操作符&lt;/h4&gt;

&lt;p&gt;Oracle9i前使用&lt;code&gt;(+)&lt;/code&gt;操作符。Oracle9i后建议使用&lt;code&gt;outer join&lt;/code&gt;执行外连接。语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select table1.column, table2.column 
    from table1, table2 
        where table1.column1(+) = table2.column2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当使用&lt;code&gt;(+)&lt;/code&gt;操作符时，应该将该操作符放在显示较少行（完全满足连接条件）的一端。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;label label-important&quot;&gt;&lt;em&gt;NOTES：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;(+)&lt;/code&gt;操作符只出现在&lt;code&gt;where&lt;/code&gt;子句中，并且不能同&lt;code&gt;OUTER JOIN&lt;/code&gt;语法同用;&lt;/li&gt;
  &lt;li&gt;当使用&lt;code&gt;(+)&lt;/code&gt;操作符执行外连接时，如果&lt;code&gt;where&lt;/code&gt;子句中包含多个条件，则必须所有条件中都包含&lt;code&gt;(+)&lt;/code&gt;操作符;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;(+)&lt;/code&gt;操作符只适用于列，不能用在表达式上;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;(+)&lt;/code&gt;操作符不能与&lt;code&gt;or&lt;/code&gt;和&lt;code&gt;in&lt;/code&gt;操作符一起使用;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;(+)&lt;/code&gt;操作符只能实现左外、右外连接，不能实现完全连接;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 2.1 左外连接示例可写成
 SQL&amp;gt; select a.dname, b.ename from department a, employee b where a.deptno = b.deptno(+);
        
 2.2 右外连接示例可写成
 SQL&amp;gt; select a.dname, b.ename from department a, employee b where a.deptno(+) = b.deptno;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-7&quot;&gt;子查询&lt;/h2&gt;

&lt;h3 id=&quot;section-8&quot;&gt;单行子查询&lt;/h3&gt;

&lt;p&gt;只返回一行数据的子查询语句。当在&lt;code&gt;where&lt;/code&gt;中引用单行子查询时，可以使用单行比较符 =,&amp;gt;,&amp;lt;,&amp;gt;=,&amp;lt;=,&amp;lt;&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; select ename, salary, deptno from employee where deptno = 
SQL&amp;gt; (select deptno from employee where ename = 'scott');
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-9&quot;&gt;多行子查询&lt;/h3&gt;

&lt;p&gt;返回多行数据的子查询语句。当在&lt;code&gt;where&lt;/code&gt;中引用多行子查询时，必须要使用如下多行比较符:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;in&lt;/code&gt; : 匹配于子查询结果的任一个值即可&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  SQL&amp;gt; select ename,job,sal,deptno from emp where job in
  SQL&amp;gt; (select distinct job from emp where deptno = 10);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;all&lt;/code&gt; : 必须要符合子查询结果的所有值&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  SQL&amp;gt; select ename,job,sal,deptno from emp where sal &amp;gt; all
  SQL&amp;gt; (select sal from emp where deptno = 10);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;any&lt;/code&gt; : 只要符合子查询结果的任一个值即可&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  SQL&amp;gt; select ename,job,sal,deptno from emp where sal &amp;gt; any
  SQL&amp;gt; (select sal from emp where deptno = 10);	
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-10&quot;&gt;多列子查询&lt;/h3&gt;

&lt;p&gt;多列子查询返回多列数据的子查询语句。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当多列子查询返回单行数据时，&lt;code&gt;where&lt;/code&gt;中可以使用单行比较符；&lt;/li&gt;
  &lt;li&gt;当多列子查询返回多行数据时，&lt;code&gt;where&lt;/code&gt;中必须使用多行比较符；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当使用子查询比较多列数据时，即可以成对比较也可以非成对比较。成对比较要求多个列的数据必须同时匹配，非成对则不要求。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  -- 成对比较示例
      SQL&amp;gt; select ename, sal, comm, deptno from emp
      SQL&amp;gt; where (sal, nvl(comm,-1) in
      SQL&amp;gt; (select sal, nvl(comm,-1) from emp where deptno = 10 );

  -- 非成对比较示例.执行非成对比较，应使用多个多行子查询实现
      SQL&amp;gt; select ename, sal, comm, deptno from emp
      SQL&amp;gt; where sal in
      SQL&amp;gt; (select sal from emp where deptno = 30 )
      SQL&amp;gt; and nvl(comm,-1) in
      SQL&amp;gt; (select nvl(comm,-1) from emp where deptno = 30);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-11&quot;&gt;其他子查询&lt;/h3&gt;

&lt;h4 id=&quot;section-12&quot;&gt;相关子查询&lt;/h4&gt;

&lt;p&gt;相关子查询是指需要引用主查询表列的子查询语句，相关子查询是通过&lt;code&gt;exists&lt;/code&gt; 谓词实现的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; select ename, sal, job, depton from emp where exists
SQL&amp;gt; (select 1 from dept where dept.depton = emp.depton );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&quot;label label-important&quot;&gt;&lt;em&gt;NOTES：&lt;/em&gt;&lt;/span&gt;&lt;br /&gt;
当使用&lt;code&gt;exists&lt;/code&gt;谓词时，如果子查询存在返回结果，则条件为&lt;code&gt;TRUE&lt;/code&gt;; 如果子查询没有返回结果，则条件为&lt;code&gt;FALSE&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;from&quot;&gt;在from子句中使用子查询&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;from&lt;/code&gt;中的子查询会被当作视图对待，因此也被称作内嵌视图。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;label label-important&quot;&gt;&lt;em&gt;NOTES：&lt;/em&gt;&lt;/span&gt;
&lt;code&gt;from&lt;/code&gt;子句中使用子查询时，必须要给子查询指定别名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; select ename, job, sal, from emp, 
SQL&amp;gt; (select deptno, avg(sal) avgsal from emp group by deptno) dept 
SQL&amp;gt; where emp.deptno = deptno and sal &amp;gt; dept.avgsal;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;dml&quot;&gt;在&lt;code&gt;DML&lt;/code&gt;语句中使用子查询&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在&lt;code&gt;insert&lt;/code&gt;语句中使用子查询&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; SQL&amp;gt; insert into customer(name,age) select name,age from employee where eno = 200;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在&lt;code&gt;update&lt;/code&gt;语句中使用子查询&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; SQL&amp;gt; update emp set (sal, comm) = 
 SQL&amp;gt; (select sal, comm from emp where ename = 'jack')
 SQL&amp;gt; where job = (select job from emp where ename = 'jack');
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在&lt;code&gt;delete&lt;/code&gt;语句中使用子查询&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; SQL&amp;gt; delete emp where deptno = 
 SQL&amp;gt; (select deptno from dept where dname = 'jack');
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在&lt;code&gt;DDL&lt;/code&gt;语句中使用子查询&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;在&lt;code&gt;create table&lt;/code&gt;语句中使用&lt;/p&gt;

        &lt;p&gt;使用子查询可以在建立新表的同时复制表中的数据&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  SQL&amp;gt; create table new_emp (id, name, sal, job) as
  SQL&amp;gt; select empno,ename,esal,ejob from emp;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在&lt;code&gt;create view&lt;/code&gt;中使用&lt;/p&gt;

        &lt;p&gt;创建视图时必须要指定视图所对应的子查询语句&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  SQL&amp;gt; create or replace view dept_10 as
  SQL&amp;gt; SELECT empno,ename,esal,ejob FROM emp ORDER BY empno;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在&lt;code&gt;create materialized view&lt;/code&gt;中使用&lt;/p&gt;

        &lt;p&gt;创建&lt;a href=&quot;http://docs.oracle.com/cd/E11882_01/server.112/e17118/statements_6002.htm&quot; title=&quot;materialized view&quot;&gt;实体化视图&lt;/a&gt;时，必须要指定实体化视图所对应的SQL语句，并且该SQL语句将来可用于查询重写。&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  SQL&amp;gt; create materialized view summary_emp as
  SQL&amp;gt; select deptno, job, avg(sal) avasal, sum(sal) sumsal 
  SQL&amp;gt; from emp group by cube(deptno, job);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-13&quot;&gt;合并查询&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;select 语句1 [union | union all | intersect | minus] select 语句2
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;这些集合操作符具有相同的优先级。同时使用时会按照从左至右的方式引用这些集合操作符&lt;/li&gt;
  &lt;li&gt;使用集合操作符时，必须确保不同查询的列个数和数据类型都要匹配&lt;/li&gt;
  &lt;li&gt;对于&lt;code&gt;lob&lt;/code&gt;、&lt;code&gt;varray&lt;/code&gt;和嵌套表列来说，集合操作符无效&lt;/li&gt;
  &lt;li&gt;对于&lt;code&gt;long&lt;/code&gt;列来说，&lt;code&gt;union&lt;/code&gt;、&lt;code&gt;intersect&lt;/code&gt;、&lt;code&gt;minus&lt;/code&gt;操作无效&lt;/li&gt;
  &lt;li&gt;如果选择列表包含了表达式，则必须要为其指定列别名&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;union&quot;&gt;union&lt;/h3&gt;

&lt;p&gt;合并结果集，并会自动去掉结果集中的重复行，并且会以第一列的结果进行排序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; select ename,sal,job from emp where sal &amp;gt; 2500
SQL&amp;gt; union
SQL&amp;gt; select ename,sal,job from emp where job = 'manager';
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;union-all&quot;&gt;union all&lt;/h3&gt;

&lt;p&gt;合并结果集，但不会去掉结果集中的重复行，也不会进行任何排序，只是简单的做合并&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; select ename,sal,job from emp where sal &amp;gt; 2500
SQL&amp;gt; union all
SQL&amp;gt; select ename,sal,job from emp where job = 'manager';
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;intersect&quot;&gt;intersect&lt;/h3&gt;

&lt;p&gt;获取两个结果集的交集，并以第一列的结果进行排序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; select ename,sal,job from emp where sal &amp;gt; 2500
SQL&amp;gt; intersect
SQL&amp;gt; select ename,sal,job from emp where job = 'manager';
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;minus&quot;&gt;minus&lt;/h3&gt;

&lt;p&gt;获取两个结果集的差集。只显示在第一个结果集中存在，在第二结果集中不存在的数据，并以第一列的结果进行排序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; select ename,sal,job from emp where sal &amp;gt; 2500
SQL&amp;gt; minus
SQL&amp;gt; select ename,sal,job from emp where job = 'manager';
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-14&quot;&gt;其他复杂查询&lt;/h2&gt;

&lt;h3 id=&quot;section-15&quot;&gt;层次查询&lt;/h3&gt;

&lt;p&gt;当表具有层次结构时，使用层次查询可以更直观的显示数据结果，并显示其数据之间的层次关系&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select 语句 start with condition connect by condition
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;start with&lt;/code&gt;: 用于指定层次查询的根行。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;connect by&lt;/code&gt;: 用户指定父行和子行之间的关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在condition表达式中，必须使用&lt;code&gt;prior&lt;/code&gt;引用父行。语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;... prior expr = expr 或者 ... expr = prior expr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如emp表具层次结构，其中empno列对应雇员号，而mgr列对应管理者编号。那么通过层次查询，可以显示雇员之间的上下级关系。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; col ename format a15
SQL&amp;gt; col job format a15
SQL&amp;gt; select lpad(' ', 3 * (level-1))||ename ename,
SQL&amp;gt; lpad(' ', 3 * (level-1))||job job from emp
SQL&amp;gt; where job &amp;lt;&amp;gt; 'clean' start with mgr is null
SQL&amp;gt; connect by mgr = prior empno;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;case&quot;&gt;case表达式&lt;/h3&gt;

&lt;p&gt;为了在 SQL 语句中使用 &lt;code&gt;if..then..else&lt;/code&gt;语法，可以使用 &lt;code&gt;case&lt;/code&gt;表达式。当使用&lt;code&gt;case&lt;/code&gt;表达式时，可以使用 &lt;code&gt;where&lt;/code&gt;子句指定条件语句。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; select ename, sal,
SQL&amp;gt; case when sal &amp;gt; 3000 then 3
SQL&amp;gt; when sal &amp;gt;  2000 then 2
SQL&amp;gt; else 1 end grade
SQL&amp;gt; from emp where deptno = 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;with&quot;&gt;使用with语句重用子查询&lt;/h3&gt;

&lt;p&gt;Oracle9i开始，通过&lt;code&gt;with&lt;/code&gt;子句可以给子查询指定一个名称，并且使得在一条语句中可以完成所有任务，避免使用临时表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; with summary as (
SQL&amp;gt; 	select dname, sum(sal) as dept_total from emp,dept
SQL&amp;gt; 	where emp.deptno = dept.deptno group by dname
SQL&amp;gt; )
SQL&amp;gt; select dname, dept_total from summary where dept_total &amp;gt; 
SQL&amp;gt; ( select sum(dept_total) * 1/3 from summary);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-16&quot;&gt;倒叙查询&lt;/h3&gt;

&lt;p&gt;默认情况下执行查询操作只能看到最近提交的数据。从Oracle9i开始，通过使用倒叙查询(&lt;a href=&quot;http://docs.oracle.com/cd/E11882_01/appdev.112/e25518/adfns_flashback.htm&quot; title=&quot;Flashback Query&quot;&gt;Flashback Query&lt;/a&gt;)特征，可以查看到过去某个时间点所提交的数据。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;label label-important&quot;&gt;&lt;em&gt;NOTES：&lt;/em&gt;&lt;/span&gt;&lt;br /&gt;
使用倒叙查询，要求数据库必须采用&lt;code&gt;undo&lt;/code&gt;管理方式，并且初始化参数&lt;code&gt;undo_retention&lt;/code&gt;限制了&lt;code&gt;undo&lt;/code&gt;数据的保留时间。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;查看当前数据&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; SQL&amp;gt; select ename, sal from emp where ename = 'jack';
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看历史数据&lt;/p&gt;

    &lt;p&gt;执行倒叙查询时，通过在&lt;code&gt;from&lt;/code&gt;子句后指定&lt;code&gt;as of&lt;/code&gt;子句可以查看过去的历史数据。&lt;code&gt;as of&lt;/code&gt;中既可以指定时间，也可以指定SCN.&lt;/p&gt;

    &lt;p&gt;&lt;span class=&quot;label label-important&quot;&gt;&lt;em&gt;NOTES：&lt;/em&gt;&lt;/span&gt;&lt;br /&gt;
 使用倒叙查询只能看到5分钟之前变化数据。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; SQL&amp;gt; select ename, sal from emp as of timestamp to_timestamp('2011-10-12 16:00:00','yyyy-MM-dd hh24:mi:ss')
 SQL&amp;gt; where ename = 'jack';
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code&gt;dbms_flashback&lt;/code&gt;包获取特定&lt;code&gt;SCN&lt;/code&gt;的数据&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; SQL&amp;gt; exec dbms_flashback.enable_at_system_change_number(717402);
 SQL&amp;gt; select sal from emp where ename = 'jack';
 SQL&amp;gt; exec dbms_flashback.disable;
 SQL&amp;gt; select sal from emp where ename = 'jack';
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
      <pubDate>Thu, 17 Nov 2011 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2011/11/17/plsql-sql-select</guid>
      <dc:date>2011-11-17T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>SQL分组语句要点</title>
      <link>http://leeyee.github.io/blog/2011/11/16/plsql-sql-groupby</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;常用分组函数：&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rollup&quot;&gt;横向小计统计(&lt;code&gt;rollup&lt;/code&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#grouping-sets&quot;&gt;分组合并&lt;code&gt;grouping sets&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;常用分组函数：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;max([all|distinct]expr)&lt;/code&gt; : 获取列或表达式的最大值，适合任何数据类型；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;min([all|distinct]expr)&lt;/code&gt; : 获取列或表达式的最小值，适合任何数据类型;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;avg([all|distinct]expr)&lt;/code&gt; : 获取列或表达式的平均值，只适合数字类型;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sum([all|distinct]expr)&lt;/code&gt; : 获取列或表达式的总和，只适合数字类型;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;count([all|distinct]expr)&lt;/code&gt; : 获取总行数;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;grouping&lt;/code&gt; : 用于确定统计结果是否用到了特定列。如果返回0，则表示统计结果使用了该列；如果返回1，则表示统计结果未使用该列&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; SQL&amp;gt; SELECT name,address ,SUM(money),GROUPING(name),GROUPING(address) FROM customer GROUP BY CUBE(name,address);
 NAME                         ADDRESS  COUNT(*) SUM(MONEY) GROUPING(name)  GROUPING(address)
 ---------------------------- ------- ---------- --------- --------------  -----------------
                                         4		162.26		1				1
                             a		 	1		32			1				0
                             abcdefg		2		118.03		1				0
                             152号大街	1		12.23		1				0
 oxcow									2		118.03		0				1
 oxcow						abcdefg		2		118.03		0				0
 leeyee									2		44.23		0				1
 leeyee						a			1		32			0				0
 leeyee						152号大街	1		12.23		0				0
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;dense_rank(expr1,expr2,..) within group (order by expr1,expr2,..)&lt;/code&gt; : 该函数用于返回特定数据在一组行数据中的等级。关于&lt;a href=&quot;http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions123.htm&quot; title=&quot;rank&quot;&gt;rank&lt;/a&gt;,&lt;a href=&quot;http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions043.htm&quot; title=&quot;dense_rank&quot;&gt;dense_rank&lt;/a&gt;的具体说明请&lt;a href=&quot;http://blog.csdn.net/baoqiangwang/article/details/4712481&quot;&gt;查看&lt;/a&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; SQL&amp;gt; select dense_rank(5000) within group (order by sal) rank from emp;
         RANK
         -----
         12
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;first&lt;/code&gt; : &lt;strong&gt;Oracle9i新增函数&lt;/strong&gt;,获取首个排序等级，然后使用分组汇总函数汇总。&lt;strong&gt;该函数不能单独使用，必须与其他分组函数结合使用&lt;/strong&gt;。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; -- 年龄最大的一组人中工资最高的
 SQL&amp;gt; select max(money) keep (dense_rank first order by age desc) from customer;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;last&lt;/code&gt; : &lt;strong&gt;Oracle9i新增函数&lt;/strong&gt;,获取最后一个排序等级，然后使用分组汇总函数汇总。&lt;strong&gt;该函数不能单独使用，必须与其他分组函数结合使用&lt;/strong&gt;。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; -- 年龄最小的一组人中工资最高的
 SQL&amp;gt; select name, max(money) keep (dense_rank last order by age desc) from customer;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;span class=&quot;label label-important&quot;&gt;&lt;em&gt;NOTES：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分组函数只能出现在选择列表、&lt;code&gt;order by&lt;/code&gt;和&lt;code&gt;having&lt;/code&gt;子句中；&lt;/li&gt;
  &lt;li&gt;使用分组函数时，除&lt;code&gt;count(*)&lt;/code&gt;外，其他分组函数都会忽略&lt;code&gt;null&lt;/code&gt;行；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;select&lt;/code&gt;时，列表同时包含列、表达式和分组函数，那么列、表达式必须出现在&lt;code&gt;group by&lt;/code&gt;子句中；&lt;/li&gt;
  &lt;li&gt;使用分组函数时，分组函数中可以指定&lt;code&gt;all&lt;/code&gt;和&lt;code&gt;distinct&lt;/code&gt;其中&lt;code&gt;all&lt;/code&gt;为默认选项；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;rollup&quot;&gt;横向小计统计(&lt;code&gt;rollup&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;rollup&lt;/code&gt;操作符在生成原有统计结果的基础上，还会生成横向小计结果.&lt;br /&gt;
	SQL&amp;gt; SELECT name,address ,SUM(money) FROM customer GROUP BY ROLLUP(name,address);&lt;br /&gt;
		NAME                         ADDRESS  COUNT(*) SUM(MONEY)&lt;br /&gt;
		—————————- ——- ———- ———-&lt;br /&gt;
		oxcow						abcdefg			2				118.03&lt;br /&gt;
		oxcow										2				118.03&lt;br /&gt;
		leeyee										1				32&lt;br /&gt;
		leeyee						152号大街		1				12.23&lt;br /&gt;
		leeyee										2				44.23&lt;br /&gt;
													4				162.26&lt;br /&gt;
### 纵向小计统计(&lt;code&gt;cube&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cube&lt;/code&gt;操作符在生成原有统计结果的基础上，还会生成横向小计、纵向小计结果.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; SELECT name,address ,SUM(money) FROM customer GROUP BY CUBE(name,address);
	NAME                         ADDRESS  COUNT(*) SUM(MONEY)
	---------------------------- ------- ---------- ----------
											4			162.26
									a		1			32
								abcdefg		2			118.03
								152号大街	1				12.23
	oxcow									2			118.03
	oxcow						abcdefg		2			118.03
	leeyee									2			44.23
	leeyee					a				1			32
	leeyee						152号大街	1				12.23
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;grouping-sets&quot;&gt;分组合并&lt;code&gt;grouping sets&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span class=&quot;label label-important&quot;&gt;&lt;em&gt;NOTES：&lt;/em&gt;&lt;/span&gt;&lt;strong&gt;Oracle9i后可以使用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;grouping sets&lt;/code&gt;操作符可以合并多个分组结果.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; SELECT name, COUNT(*) FROM customer GROUP BY name;
	NAME                                       COUNT(*)
	---------------------------------------- ----------
	leeyee                                            2
	oxcow                                             2
	
SQL&amp;gt; SELECT address,COUNT(*) FROM customer GROUP BY address;
	ADDRESS                                   COUNT(*)
	---------------------------------------- ----------
	a											1
	abcdefg										2
	152号大街									1
	
SQL&amp;gt; SELECT name,address,COUNT(*) FROM CUSTOMER GROUP BY GROUPING SETS(name,address);
	NAME 		ADDRESS      COUNT(*)
	-----		---------    ----------  
	leeyee							2
	oxcow							2
				a					1
				abcdefg				2
				152号大街				1
&lt;/code&gt;&lt;/pre&gt;

</description>
      <pubDate>Wed, 16 Nov 2011 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2011/11/16/plsql-sql-groupby</guid>
      <dc:date>2011-11-16T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>SQL事务语句要点</title>
      <link>http://leeyee.github.io/blog/2011/11/15/plsql-sql-transaction</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;只读事务&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;顺序事务&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;提交事务&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; commit
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;当执行&lt;code&gt;commit&lt;/code&gt;后，会确认事务变化、结束事务、删除保存点、释放锁。以下情况会自动提交事务：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;执行&lt;code&gt;DDL&lt;/code&gt;语句时；比如&lt;code&gt;create table&lt;/code&gt;,&lt;code&gt;alter table&lt;/code&gt;,&lt;code&gt;drop table&lt;/code&gt;等&lt;/li&gt;
      &lt;li&gt;执行&lt;code&gt;DCL&lt;/code&gt;语句时；比如&lt;code&gt;grant&lt;/code&gt;,&lt;code&gt;revoke&lt;/code&gt;等。&lt;/li&gt;
      &lt;li&gt;退出&lt;code&gt;SQL*Plus&lt;/code&gt;时。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;保存点&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; savepoint &amp;lt;point_name&amp;gt;
 exec dbms_transaction.savepoint('&amp;lt;point_name&amp;gt;');
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;保存点用来记录事务过程中的某一个阶段。当调用&lt;code&gt;commit&lt;/code&gt;提交事务后，保存将被删除。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;回滚事务&lt;/p&gt;

    &lt;p&gt;3.1. 回滚部分事务&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; rollback to &amp;lt;savepoint&amp;gt;
 exec dbms_transaction.rollback_savepoint('&amp;lt;savepoint&amp;gt;');
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;3.2. 回滚全部事务&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; rollback
 exec dbms_transaction.rollback
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SQL&amp;gt; insert table_name ...
SQL&amp;gt; delete table_name ...
SQL&amp;gt; savepoint A    -- exec dbms_transaction.savepoint('A')
SQL&amp;gt; update table_name ...
SQL&amp;gt; savepoint B    -- exec dbms_transaction.savepoint('B')
SQL&amp;gt; delete table_name ...
SQL&amp;gt; rollback to B -- 回滚到事务保存点B.或者exec dbms_transaction.rollback_savepoint('B')
SQL&amp;gt; rollback to A -- 回滚到事务保存点A.或者exec dbms_transaction.rollback_savepoint('A')
SQL&amp;gt; rollback -- 回滚所有事务.或者exec dbms_transaction.rollback
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;只读事务&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;set transaction read only
exec dbms_transaction.read_only
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只读事务只允许执行查询操作，而不允许执行任何DML操作的事物。使用只读事务可以获取特定的时间点的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- 会话A
SQL&amp;gt; set transaction read only; -- 1 设置当前事务为只读事务。
SQL&amp;gt; select * from emp; -- 3 由于设置了当前事务为只读事务，此时其他会话对表的更新等操作都不会影响该查询SQL。该SQL获取的仍是其他会话更新前的数据

-- 会话B
SQL&amp;gt; update emp set sal = 3000 where ename = 'jack'; -- 2
SQL&amp;gt; commit; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设会话A在1设置了顺序事务，会话B在2更新了数据，那么会话A在3查询时将会获取时间点在1的数据，而不是会话B在2更新后的数据&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;顺序事务&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;set transaction isolation level serializable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用顺序事务时,除了具有只读事务的特点外,顺序事务允许执行DML操作.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- 会话A
SQL&amp;gt; set transaction isolation level serializable; -- 1
SQL&amp;gt; select sal from emp where ename = 'jack'; --3
SQL&amp;gt; udpate dept set loc = 'beijing' where deptno = 6;
SQL&amp;gt; commit;
	
-- 会话B
SQL&amp;gt; update emp set sal = 3000 where ename = 'jack'; --2
SQL&amp;gt; commit;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设会话A在1设置了顺序事务，会话B在2更新了数据，那么会话A在3查询时将会获取时间点在1的数据，而不是会话B在2更新后的数据&lt;/p&gt;
</description>
      <pubDate>Tue, 15 Nov 2011 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2011/11/15/plsql-sql-transaction</guid>
      <dc:date>2011-11-15T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>SQL增删改语句要点</title>
      <link>http://leeyee.github.io/blog/2011/11/14/plsql-sql-cud</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#sql&quot;&gt;SQL分类&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;子查询插入数据&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;多表插入&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#truncate-table&quot;&gt;截断表(&lt;code&gt;truncate table&lt;/code&gt;)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sql&quot;&gt;SQL分类&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;数据查询语句（&lt;code&gt;select&lt;/code&gt; 语句）：用于检索数据库数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据操纵语言（&lt;code&gt;Data Manipulation Language&lt;/code&gt;,&lt;code&gt;DML&lt;/code&gt;）：用于改变数据库数据,包括&lt;code&gt;insert&lt;/code&gt;、&lt;code&gt;update&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;三条语句&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;事物控制语句（&lt;code&gt;Transaction Contorl Language&lt;/code&gt;,&lt;code&gt;TCL&lt;/code&gt;）：用户维护数据库的一致性,包括&lt;code&gt;commit&lt;/code&gt;、&lt;code&gt;rollback&lt;/code&gt;和&lt;code&gt;savepoint&lt;/code&gt;三条语句。&lt;/p&gt;

    &lt;p&gt;3.1. &lt;code&gt;commit&lt;/code&gt;确认已经进行的数据库更改&lt;/p&gt;

    &lt;p&gt;3.2. &lt;code&gt;rollback&lt;/code&gt;取消已经进行的数据库更改&lt;/p&gt;

    &lt;p&gt;3.3. &lt;code&gt;savepoint&lt;/code&gt;设置保存点，以取消部分数据库改变&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据定义语句（&lt;code&gt;Data Definition Language&lt;/code&gt;,&lt;code&gt;DDL&lt;/code&gt;）：用于建立、修改和删除数据库对象。比如&lt;code&gt;create table&lt;/code&gt; 、&lt;code&gt;alter table&lt;/code&gt;和&lt;code&gt;drop table&lt;/code&gt;。&lt;code&gt;DDL&lt;/code&gt;语句会自动提交事务&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库控制语言（&lt;code&gt;Data Control Language&lt;/code&gt;,&lt;code&gt;DCL&lt;/code&gt;）：用于执行权限授予和收回操作，包括&lt;code&gt;grant&lt;/code&gt;和&lt;code&gt;revoke&lt;/code&gt;两条命令。&lt;code&gt;DCL&lt;/code&gt;语句会自动提交事务&lt;/p&gt;

    &lt;p&gt;5.1. &lt;code&gt;grant&lt;/code&gt;命令用户给用户或角色授予权限&lt;/p&gt;

    &lt;p&gt;5.2. &lt;code&gt;revoke&lt;/code&gt;命令用于收回用户或角色所具有的权限。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;子查询插入数据&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用子查询插入数据&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; insert into customer(name,age) select name,age from employee where eno = 200;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用子查询执行直接装载&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; insert /*+append */ into customer(name,age) select name,age from employee where eno = 200;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;span class=&quot;label label-important&quot;&gt;&lt;em&gt;NOTES：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;以上两条语句的执行结果一样，但2使用了&lt;code&gt;/*+append */&lt;/code&gt;来表示采用直接装载方式&lt;/strong&gt;;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;当要装载大批量数据是，采用2方法装载数据的速度要远远优于1&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;多表插入&lt;/h2&gt;

&lt;p&gt;&lt;span class=&quot;label label-important&quot;&gt;&lt;em&gt;NOTES：&lt;/em&gt;&lt;/span&gt; &lt;strong&gt;Oracle9i后可以使用!&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;insert all insert_into_clause [value_clause] subquery;
insert coditional_insert_clause subquery;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;insert_into_clause 用于指定&lt;code&gt;INSERT&lt;/code&gt;语句；&lt;/li&gt;
  &lt;li&gt;value_clause 用于指定值子句；&lt;/li&gt;
  &lt;li&gt;subquery 用于指定提供数据的子查询；&lt;/li&gt;
  &lt;li&gt;conditional_insert_clause 用于指定&lt;code&gt;INSERT&lt;/code&gt;条件子句&lt;/li&gt;
&lt;/ul&gt;

&lt;p /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code&gt;all&lt;/code&gt;操作符执行多表插入&lt;/p&gt;

    &lt;p&gt;1.1. 不指定插入列&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; insert all
 	when cid = 1 then into customer1
     when age &amp;gt; 20 then into customer2
     else into customer3
 select * from customer;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;1.2. 指定插入列&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; insert all
 		when cid = 1 then into customer1(cid,name,age)
     when age &amp;gt; 20 then into customer2(cid,name,age)
     else into customer3(cid,name,age)
 select cid,name,age from customer;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code&gt;first&lt;/code&gt;操作符执行多表插入&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当使用&lt;code&gt;first&lt;/code&gt;操作符执行多表插入时，如果数据已经满足先前条件，并且已经被插入到某表，那么该行数据在后续插入中将不会被再次使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;insert first
    when cid = 1 then into customer1
    -- 如果age&amp;gt;20的数据中包含cid=1的数据，那么该条数据将不会被再次插入customer2
    when age &amp;gt; 20 then into customer2
    else into customer3
select * from customer;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;truncate-table&quot;&gt;截断表(&lt;code&gt;truncate table&lt;/code&gt;)&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;truncate table &amp;lt;table_name&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与&lt;code&gt;delete&lt;/code&gt;的区别:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;delete&lt;/code&gt;删除表的所有数据时，不会释放表所占用的空间。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;truncate&lt;/code&gt;删除表时，不仅会删除表的所有数据，还会释放表所占用空间&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;delete&lt;/code&gt;操作可以回滚，而&lt;code&gt;truncate&lt;/code&gt;则无法回滚&lt;/li&gt;
&lt;/ol&gt;
</description>
      <pubDate>Mon, 14 Nov 2011 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2011/11/14/plsql-sql-cud</guid>
      <dc:date>2011-11-14T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>Spring3 表达式语言(SpEL)介绍</title>
      <link>http://leeyee.github.io/blog/2011/06/19/spring-expression-language</link>
      <description>&lt;p&gt;&lt;a href=&quot;http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch07.html&quot;&gt;Spring Expression Language (SpEL)&lt;/a&gt;语言支持在运行时操作和查询对象，其语法类似统一的EL语言，但是&lt;a href=&quot;http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch07.html&quot; title=&quot;SpEL&quot;&gt;SpEL&lt;/a&gt;提供了额外的功能。&lt;a href=&quot;http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch07.html&quot; title=&quot;SpEL&quot;&gt;SpEL&lt;/a&gt;支持以下功能：&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;2.1 文本表达式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#map&quot;&gt;2.2 属性、数组、列表、字典(map)及索引&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;2.3 内置列表&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#spring303&quot;&gt;2.4 数组构造(spring3.0.3中会抛出异常)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;2.5 方法调用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;2.6 操作符&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;2.6.1 关系操作符&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;2.6.2 逻辑操作符&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;2.6.3 数学运算操作符&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot;&gt;2.7 赋值操作&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-8&quot;&gt;2.8 类型&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-9&quot;&gt;2.9 构造器&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-10&quot;&gt;2.10 变量&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#this&quot;&gt;2.10.1 &lt;code&gt;#this&lt;/code&gt;变量&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-11&quot;&gt;2.11 用户自定义函数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-12&quot;&gt;2.12 三元操作&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#elvis&quot;&gt;2.13 Elvis操作&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-13&quot;&gt;2.14 安全导航操作&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-14&quot;&gt;2.15 集合选择&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-15&quot;&gt;2.16 集合投影&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-16&quot;&gt;2.17 模板表达式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-17&quot;&gt;一大段测试用例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用SpEl进行表达式操作，基本操作如下：&lt;/p&gt;

&lt;p&gt;第一步，构建解析&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ExpressionParser parser = new SpelExpressionParser();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二步，使用表达式进行解析&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Expression exp = parser.parseExpression( SpEl);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三步，获取结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exp.getValue()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;2.1 文本表达式&lt;/h2&gt;

&lt;p&gt;文本表达式支持字符表达式、日期、数字（正数、实数及十六进制数）、布尔类型及null.其中字符表达式需要用单引号声明。&lt;/p&gt;

&lt;p&gt;对数字支持负数、指数及小数。默认情况下实数使用&lt;code&gt;Double.parseDouble()&lt;/code&gt;进行表达式类型转换&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String[] lELs = { &quot;'hello SpEL'&quot;, &quot;1.028E+7&quot;, &quot;0x12EF&quot;, &quot;true&quot;, &quot;null&quot; };
assertEquals(&quot;hello SpEL&quot;,
		exp.parseExpression(lELs[0]).getValue(String.class));
assertEquals(new Double(10280000), exp.parseExpression(lELs[1])
		.getValue(Double.class));
assertEquals(new Integer(4847),
		exp.parseExpression(lELs[2]).getValue(Integer.class));
assertTrue(exp.parseExpression(lELs[3]).getValue(Boolean.class));
assertNull(exp.parseExpression(lELs[4]).getValue());
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;map&quot;&gt;2.2 属性、数组、列表、字典(map)及索引&lt;/h2&gt;

&lt;p&gt;在表达式中访问类属性时直接使用属性名，属性名首字母大小写均可。&lt;/p&gt;

&lt;p&gt;访问数组时可以使用[index]进行元素对象范围。&lt;/p&gt;

&lt;p&gt;访问列表时，可直接使用类表的方法，通过点操作符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 属性测试。time为SpElUtil类Date型数据，这里调用Date的属性Year
assertEquals(new Integer(2011), exp.parseExpression(&quot;time.Year + 1900&quot;)
		.getValue(secontext, Integer.class));

// 属性测试。innerClass为SpElUtil类中引入的其他类。
assertEquals(29,
		exp.parseExpression(&quot;innerClass.age&quot;).getValue(secontext));

// 设置SpElUtil类的numbers属性
spel.setNumbers(Arrays.asList(2, 3, 4, 5, 6, 7, 9));

// 访问对象属性数组通过索引
assertEquals(2, exp.parseExpression(&quot;numbers[0]&quot;).getValue(secontext));

// 访问map
assertEquals(&quot;string1&quot;,
		exp.parseExpression(&quot;maps[1]&quot;)
				.getValue(secontext, String.class));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2.3 内置列表&lt;/h2&gt;

&lt;p&gt;列表可以直接表示在表达式中使用&lt;code&gt;{}&lt;/code&gt;符号表达。&lt;code&gt;{}&lt;/code&gt;本身代表一个空的&lt;code&gt;list&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 构造list
List&amp;lt;String&amp;gt; nums = (List&amp;lt;String&amp;gt;) exp.parseExpression(
		&quot;{'a','b','c','d'}&quot;).getValue();
assertEquals(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;), nums);

// 构造List&amp;lt;List&amp;lt;&amp;gt;&amp;gt;
List listOfLists = (List) exp.parseExpression(&quot;{ {1,2},{3,4} }&quot;)
		.getValue(secontext);
assertEquals(Arrays.asList(1, 2), listOfLists.get(0));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;spring303&quot;&gt;2.4 数组构造(spring3.0.3中会抛出异常)&lt;/h2&gt;

&lt;p&gt;可以通过熟悉的java语法在表达是语言中定义。但目前不支持定义一个初始化的多维数组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 创建没有初始值的数组
int[] a = (int[]) exp.parseExpression(&quot;new int[4]&quot;).getValue();
assertEquals(4, a.length);

// 创建带有初始值的数组
int[] b = (int[]) exp.parseExpression(&quot;new int[4]{1,2,3,4}&quot;).getValue();
assertEquals(3, b[2]);

// 创建二维数组
int[][] c = (int[][]) exp.parseExpression(&quot;new int[4][5]&quot;).getValue();
assertEquals(4, c.length);
assertEquals(5, c[0].length);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;2.5 方法调用&lt;/h2&gt;

&lt;p&gt;表达式中的方法调用遵循java语法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertEquals(
		&quot;abC2def&quot;,
		exp.parseExpression(&quot;'abcdef'.replace('c','C2')&quot;).getValue(
					String.class));

// 自定义类方法测试
assertFalse(exp.parseExpression(&quot;innerClass.isGt30ForAge()&quot;).getValue(
		secontext, Boolean.class));
spel.getInnerClass().setAge(34);
assertTrue(exp.parseExpression(&quot;innerClass.isGt30ForAge()&quot;).getValue(
		secontext, Boolean.class));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;2.6 操作符&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;2.6.1 关系操作符&lt;/h3&gt;

&lt;p&gt;支持&lt;code&gt;eq(&quot;==&quot;)&lt;/code&gt;、&lt;code&gt;ne(&quot;!=&quot;)&lt;/code&gt;、&lt;code&gt;le(&quot;&amp;lt;=&quot;)&lt;/code&gt;、&lt;code&gt;lt(&quot;&amp;lt;&quot;)&lt;/code&gt;、&lt;code&gt;gt(&quot;&amp;gt;&quot;)&lt;/code&gt;、&lt;code&gt;ge(&quot;&amp;gt;=&quot;)&lt;/code&gt;、&lt;code&gt;div(&quot;/&quot;)&lt;/code&gt;、&lt;code&gt;mod(&quot;%&quot;)&lt;/code&gt;、&lt;code&gt;not(&quot;!&quot;)&lt;/code&gt;、正则表达式及&lt;code&gt;instanceof&lt;/code&gt;操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertTrue(exp.parseExpression(&quot;1 == 1&quot;).getValue(Boolean.class));
assertTrue(exp.parseExpression(&quot;1 eq 1&quot;).getValue(Boolean.class));
assertTrue(exp.parseExpression(&quot;1 &amp;gt; -1&quot;).getValue(Boolean.class));
assertTrue(exp.parseExpression(&quot;1 gt -1&quot;).getValue(Boolean.class));
assertTrue(exp.parseExpression(&quot;'a' &amp;lt; 'b'&quot;).getValue(Boolean.class));
assertTrue(exp.parseExpression(&quot;'a' lt 'b'&quot;).getValue(Boolean.class));
assertTrue(exp.parseExpression(
		&quot; new Integer(123) instanceof T(Integer) &quot;).getValue(
		Boolean.class));
assertTrue(exp.parseExpression(&quot;'5.00' matches '^-?\\d+(\\.\\d{2})?$'&quot;)
			.getValue(Boolean.class));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;2.6.2 逻辑操作符&lt;/h3&gt;

&lt;p&gt;逻辑操作符支持&lt;code&gt;and&lt;/code&gt;,&lt;code&gt;or&lt;/code&gt;,&lt;code&gt;not&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertTrue(exp.parseExpression(&quot;true and true&quot;).getValue(Boolean.class));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2.6.3 数学运算操作符&lt;/h3&gt;

&lt;p&gt;加法运算符可以用于数字，字符串和日期。减法可以用在数字和日期。乘法和除法只能用于对数字。其他受支持的数学运算是模数（％）和指数幂（^）。运行顺序按标准运算符优先级执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertEquals(25.0,
		exp.parseExpression(&quot;1 + 2 * 8 div 4 mod 2 + 2 ^ 3 * 3e0&quot;)
				.getValue());
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-7&quot;&gt;2.7 赋值操作&lt;/h2&gt;

&lt;p&gt;通过赋值操作进行属性设置。通常是调用&lt;code&gt;setValue&lt;/code&gt;方法，但也可以在调用&lt;code&gt;getValue&lt;/code&gt;时设置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Date oldDate = spel.getTime();// 获取当前time属性值
exp.parseExpression(&quot;time&quot;).setValue(secontext, new Date(113, 2, 25)); // 为time属性重新赋值
Date newDate = spel.getTime();// 获取赋值后的time属性值
assertEquals(2013,
		exp.parseExpression(&quot;time.Year + 1900&quot;).getValue(secontext));
assertNotSame(oldDate, newDate);

// 或者使用下属方法赋值
assertEquals(&quot;abc&quot;,
		exp.parseExpression(&quot;Name = 'abc'&quot;).getValue(secontext));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-8&quot;&gt;2.8 类型&lt;/h2&gt;

&lt;p&gt;通过特殊的&lt;code&gt;T&lt;/code&gt;操作符可以用来指定一个&lt;code&gt;java.lang.Class&lt;/code&gt;的实例。在实例话对象的静态方法将会被调用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Class dateClass = exp.parseExpression(&quot;T(java.util.Date)&quot;).getValue(Class.class);
assertEquals(&quot;java.util.Date&quot;, dateClass.getName());
assertTrue(exp
		.parseExpression(
				&quot;T(java.math.RoundingMode).CEILING &amp;lt; T(java.math.RoundingMode).FLOOR&quot;)
		.getValue(Boolean.class));		
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-9&quot;&gt;2.9 构造器&lt;/h3&gt;

&lt;p&gt;构造器通过&lt;code&gt;new&lt;/code&gt;操作被调用。在&lt;code&gt;new&lt;/code&gt;操作时需要指明类的完全类名(包括包路径)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SpelTestInnerClass spt = exp
		.parseExpression(
				&quot;new  leeyee.study.spring3.bean.SpelTestInnerClass('constructTest',23)&quot;)
		.getValue(SpelTestInnerClass.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-10&quot;&gt;2.10 变量&lt;/h2&gt;

&lt;p&gt;变量可以通过 &lt;code&gt;#变量名&lt;/code&gt; 在表达式中被引用。变量通过&lt;code&gt;StandardEvaluationContext&lt;/code&gt;类的&lt;code&gt;setVariable&lt;/code&gt;方法进行设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
list.addAll(Arrays.asList(2, 3, 4, 5, 6, 7, 9));

secontext.setVariable(&quot;list&quot;, list);
List&amp;lt;Integer&amp;gt; vList = (List&amp;lt;Integer&amp;gt;) exp.parseExpression(&quot;#list&quot;)
		.getValue(secontext);
assertEquals(vList, list);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;this&quot;&gt;2.10.1 &lt;code&gt;#this&lt;/code&gt;变量&lt;/h3&gt;

&lt;p&gt;变量&lt;code&gt;#this&lt;/code&gt;被定义为当前操作对象的引用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; nums = (List&amp;lt;Integer&amp;gt;) exp.parseExpression(
		&quot;#list.?[#this &amp;gt;5]&quot;).getValue(secontext); // 获取值大于5的元素集合
assertEquals(nums, Arrays.asList(6, 7, 9));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-11&quot;&gt;2.11 用户自定义函数&lt;/h2&gt;

&lt;p&gt;你可以扩展&lt;a href=&quot;http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch07.html&quot; title=&quot;SpEL&quot;&gt;SpEL&lt;/a&gt;通过注册自定义函数。注册后的函数可以在表达式中通过其名称进行调用。函数的注册是通过&lt;code&gt;StandardEvaluationContext&lt;/code&gt;类的&lt;code&gt;registerFunction&lt;/code&gt;方法进行声明&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;context.registerFunction(&quot;len&quot;, SpElUtil.class.getDeclaredMethod(&quot;len&quot;,
		new Class[] { String.class }));
assertEquals(3, exp.parseExpression(&quot;#len('abc')&quot;).getValue(context));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-12&quot;&gt;2.12 三元操作&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;assertTrue(exp.parseExpression(&quot; true ? true :false&quot;).getValue(
		Boolean.class));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;elvis&quot;&gt;2.13 Elvis操作&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Elvis&lt;/code&gt;操作是一个短的三元操作符语法，通常在&lt;a href=&quot;https://zh.wikipedia.org/wiki/Groovy&quot; title=&quot;Groovy&quot;&gt;Groovy&lt;/a&gt;语言中使用。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;code&gt;Elvis&lt;/code&gt;操作在表达式中可以用来生成默认值，当被访问属性为空时。比如&lt;code&gt;@Value&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;@Value(&quot;#systemPro['mail.port'] ? : 25}&quot;)
// 当mail.port为空时将默认为25
Expression ex = exp.parseExpression(&quot;name?:'name is null'&quot;);
assertEquals(&quot;override&quot;, ex.getValue(secontext, String.class));
spel.setName(null);
assertEquals(&quot;name is null&quot;, ex.getValue(secontext, String.class));
spel.setName(&quot;override&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-13&quot;&gt;2.14 安全导航操作&lt;/h3&gt;

&lt;p&gt;该操作是为避免空指针异常。他是来自&lt;a href=&quot;https://zh.wikipedia.org/wiki/Groovy&quot; title=&quot;Groovy&quot;&gt;Groovy&lt;/a&gt;语言的。典型的当你有一个指向对象的引用，在你访问其方法或属性时，可能需要验证该对象的方法或属性是否为空，为了避免验证，使用安全导航操作将简单的返回&lt;code&gt;null&lt;/code&gt;而不是空指针异常。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertEquals(&quot;innerClass&quot;, exp.parseExpression(&quot;innerClass?.name&quot;)
		.getValue(secontext, String.class));
spel.setInnerClass(null);
// 使用这种表达式可以避免抛出空指针异常
assertNull(exp.parseExpression(&quot;innerClass?.name&quot;).getValue(secontext,
		String.class));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-14&quot;&gt;2.15 集合选择&lt;/h2&gt;

&lt;p&gt;选择是一个强大的表达式语言属性，可以使用选择表达式过滤源集合，从而生成一个新的符合选择条件的集合&lt;/p&gt;

&lt;p&gt;选择的语法为&lt;code&gt;?[selectionExpression]&lt;/code&gt;。他将过滤集合并且返回一个新的集合（原集合的子集）。选择语句也可用在Map中，过滤keySet及valueSet分别使用key和value关键字。另外：选择语法中，选择符合条件的结果集的第一个元素的语法为 &lt;code&gt;^[selectionExpression]&lt;/code&gt;，选择最后一个元素的语法为&lt;code&gt;$[selectionExpression]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spel.setNumbers(Arrays.asList(2, 3, 4, 5, 6, 7, 9));

List&amp;lt;Integer&amp;gt; nums = (List&amp;lt;Integer&amp;gt;) exp.parseExpression(
		&quot;numbers.?[#this &amp;gt;5]&quot;).getValue(secontext);
assertEquals(nums, Arrays.asList(6, 7, 9));

// 获取第一个元素
assertEquals(6,
		exp.parseExpression(&quot;numbers.^[#this &amp;gt; 5]&quot;).getValue(secontext));
        
// 获取最后一个元素
assertEquals(9,
		exp.parseExpression(&quot;numbers.$[#this &amp;gt; 5]&quot;).getValue(secontext));

Map&amp;lt;Integer, String&amp;gt; maps = (Map&amp;lt;Integer, String&amp;gt;) exp.parseExpression(
		&quot;maps.?[value == 'string3' ]&quot;).getValue(secontext);
Map&amp;lt;Integer, String&amp;gt; tmap = new HashMap&amp;lt;Integer, String&amp;gt;();
tmap.put(3, &quot;string3&quot;);
assertEquals(maps, tmap);

Map&amp;lt;Integer, String&amp;gt; mapk = (Map&amp;lt;Integer, String&amp;gt;) exp.parseExpression(
		&quot;maps.?[key &amp;gt; 2 and key &amp;lt; 4 ]&quot;).getValue(secontext);
assertEquals(mapk, tmap);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-15&quot;&gt;2.16 集合投影&lt;/h2&gt;

&lt;p&gt;语法&lt;code&gt;![projectionExpression]&lt;/code&gt;判断集合中每个元素是否符合语法要求&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertEquals(Arrays.asList(5, 6, 7, 8, 9), exp
		.parseExpression(&quot;numbers.![#this+3]&quot;).getValue(secontext));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-16&quot;&gt;2.17 模板表达式&lt;/h2&gt;

&lt;p&gt;表达式模板允许混合文字表达式，一个或多个值计算块。每一个值计算块被声明通过可被自定义的前缀和后缀，一般选择使用&lt;code&gt;#{}&lt;/code&gt;作为一个定界符。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertEquals(
		&quot; this is a test 4&quot;,
		exp.parseExpression(&quot; this is a test #{ maps.![key].get(3)}&quot;,
				new TemplateParserContext()).getValue(secontext,
				String.class));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-17&quot;&gt;一大段测试用例&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;import static org.junit.Assert.*;
import java.util.*;
import org.junit.*;

import org.springframework.context.ApplicationContext;
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.common.TemplateParserContext;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;

import study.spring.context.factory.ApplicationContextFactory;

public class SpElUtilTest {
	// spring配置文件上下文
	ApplicationContext context = null;
	// spring el测试辅助类
	SpElUtil spel = null;
	// 表达式解析对象
	ExpressionParser exp = null;
	// 标准赋值上下文
	StandardEvaluationContext secontext;

	@Before
	public void setUp() throws Exception {
		context = ApplicationContextFactory.createInstance();
		spel = context.getBean(SpElUtil.class);
		secontext = new StandardEvaluationContext(spel);
		exp = new SpelExpressionParser();
	}

	@After
	public void tearDown() throws Exception {
		context = null;
		spel = null;
		secontext = null;
		exp = null;
	}

	/**
	 * 文字表达式测试用例
	 * 
	 * @throws Exception
	 */
	@Test
	public void testSpELLiteralExpression() throws Exception {
		// 定义各种文字表达式
		String[] lELs = { &quot;'hello SpEL'&quot;, &quot;1.028E+7&quot;, &quot;0x12EF&quot;, &quot;true&quot;, &quot;null&quot; };
		assertEquals(&quot;hello SpEL&quot;,
				exp.parseExpression(lELs[0]).getValue(String.class));
		assertEquals(new Double(10280000), exp.parseExpression(lELs[1])
				.getValue(Double.class));
		assertEquals(new Integer(4847),
				exp.parseExpression(lELs[2]).getValue(Integer.class));
		assertTrue(exp.parseExpression(lELs[3]).getValue(Boolean.class));
		assertNull(exp.parseExpression(lELs[4]).getValue());
	}

	/**
	 * 访问属性、数组、集合和 map 测试
	 * 
	 * @throws Exception
	 */
	@Test
	public void testSpELProOrArrayOrIndexEtcExpression() throws Exception {
		// 属性测试。time为SpElUtil类Date型数据，这里调用Date的属性Year
		assertEquals(new Integer(2011), exp.parseExpression(&quot;time.Year + 1900&quot;)
				.getValue(secontext, Integer.class));

		// 属性测试。innerClass为SpElUtil类中引入的其他类。
		assertEquals(29,
				exp.parseExpression(&quot;innerClass.age&quot;).getValue(secontext));

		// 设置SpElUtil类的numbers属性
		spel.setNumbers(Arrays.asList(2, 3, 4, 5, 6, 7, 9));

		// 访问对象属性数组通过索引
		assertEquals(2, exp.parseExpression(&quot;numbers[0]&quot;).getValue(secontext));

		// 访问map
		assertEquals(&quot;string1&quot;,
				exp.parseExpression(&quot;maps[1]&quot;)
						.getValue(secontext, String.class));

	}

	/**
	 * 内联list测试
	 * 
	 * @throws Exception
	 */
	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
	@Test
	public void testSpELInnerListExpression() throws Exception {
		// 构造list
		List&amp;lt;String&amp;gt; nums = (List&amp;lt;String&amp;gt;) exp.parseExpression(
				&quot;{'a','b','c','d'}&quot;).getValue();
		assertEquals(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;), nums);
		// 构造List&amp;lt;List&amp;lt;&amp;gt;&amp;gt;
		List listOfLists = (List) exp.parseExpression(&quot;{ {1,2},{3,4} }&quot;)
				.getValue(secontext);
		assertEquals(Arrays.asList(1, 2), listOfLists.get(0));
	}

	/**
	 * Array 构造测试
	 * 
	 * @throws Exception
	 */
	@Test
	public void testSpELArrayConstructionExcpression() throws Exception {
		// 创建没有初始值的数组
		int[] a = (int[]) exp.parseExpression(&quot;new int[4]&quot;).getValue();
		assertEquals(4, a.length);
		// 创建带有初始值的数组
		int[] b = (int[]) exp.parseExpression(&quot;new int[4]{1,2,3,4}&quot;).getValue();
		assertEquals(3, b[2]);
		// 创建二维数组
		int[][] c = (int[][]) exp.parseExpression(&quot;new int[4][5]&quot;).getValue();
		assertEquals(4, c.length);
		assertEquals(5, c[0].length);
	}

	/**
	 * 方法表达式测试
	 * 
	 * @throws Exception
	 */
	@Test
	public void testSpELMethodExcpression() throws Exception {
		// String.replace方法测试
		assertEquals(
				&quot;abC2def&quot;,
				exp.parseExpression(&quot;'abcdef'.replace('c','C2')&quot;).getValue(
						String.class));

		// 自定义类方法测试
		assertFalse(exp.parseExpression(&quot;innerClass.isGt30ForAge()&quot;).getValue(
				secontext, Boolean.class));
		spel.getInnerClass().setAge(34);
		assertTrue(exp.parseExpression(&quot;innerClass.isGt30ForAge()&quot;).getValue(
				secontext, Boolean.class));
	}

	/**
	 * 操作符、正则表达式测试
	 * 
	 * @throws Exception
	 */
	@Test
	public void testSpElOperatorAndRegExpression() throws Exception {
		// 关系操作
		assertTrue(exp.parseExpression(&quot;1 == 1&quot;).getValue(Boolean.class));
		assertTrue(exp.parseExpression(&quot;1 eq 1&quot;).getValue(Boolean.class));
		assertTrue(exp.parseExpression(&quot;1 &amp;gt; -1&quot;).getValue(Boolean.class));
		assertTrue(exp.parseExpression(&quot;1 gt -1&quot;).getValue(Boolean.class));
		assertTrue(exp.parseExpression(&quot;'a' &amp;lt; 'b'&quot;).getValue(Boolean.class));
		assertTrue(exp.parseExpression(&quot;'a' lt 'b'&quot;).getValue(Boolean.class));
		assertTrue(exp.parseExpression(
				&quot; new Integer(123) instanceof T(Integer) &quot;).getValue(
				Boolean.class));
		assertTrue(exp.parseExpression(&quot;'5.00' matches '^-?\\d+(\\.\\d{2})?$'&quot;)
				.getValue(Boolean.class));
		// 逻辑操作
		assertTrue(exp.parseExpression(&quot;true and true&quot;).getValue(Boolean.class));
		assertTrue(exp.parseExpression(&quot;true or false&quot;).getValue(Boolean.class));
		assertFalse(exp.parseExpression(&quot;innerClass.isGt30ForAge() and false &quot;)
				.getValue(secontext, Boolean.class));
		assertFalse(exp.parseExpression(&quot;!innerClass.isGt30ForAge() and true &quot;)
				.getValue(secontext, Boolean.class));
		assertTrue(exp.parseExpression(&quot;!false&quot;).getValue(Boolean.class));
		// 运算操作
		assertEquals(2, exp.parseExpression(&quot;1 + 1&quot;).getValue());
		assertEquals(&quot;ABab&quot;,
				exp.parseExpression(&quot;'AB' + 'ab'&quot;).getValue(String.class));
		assertEquals(25.0,
				exp.parseExpression(&quot;1 + 2 * 8 div 4 mod 2 + 2 ^ 3 * 3e0&quot;)
						.getValue());
		assertEquals(exp.parseExpression(&quot;1 + 2 * 8 / 4 % 2 + 2 ^ 3 &quot;)
				.getValue(),
				exp.parseExpression(&quot;1 + 2 * 8 div 4 mod 2 + 2 ^ 3 &quot;)
						.getValue());
	}

	/**
	 * 赋值表达式测试
	 * 
	 * @throws Exception
	 */
	@SuppressWarnings(&quot;deprecation&quot;)
	@Test
	public void testSpelAssignmentExpression() throws Exception {
		Date oldDate = spel.getTime();// 获取当前time属性值
		exp.parseExpression(&quot;time&quot;).setValue(secontext, new Date(113, 2, 25)); // 为time属性重新赋值
		Date newDate = spel.getTime();// 获取赋值后的time属性值
		assertEquals(2013,
				exp.parseExpression(&quot;time.Year + 1900&quot;).getValue(secontext));
		assertNotSame(oldDate, newDate);

		// 或者使用下属方法赋值
		assertEquals(&quot;abc&quot;,
				exp.parseExpression(&quot;Name = 'abc'&quot;).getValue(secontext));

		// 还原time默认，避免后续测试错误
		spel.setTime(oldDate);
		spel.setName(&quot;override&quot;);
	}

	/**
	 * 类型操作表达式测试
	 * 
	 * @throws Exception
	 */
	@SuppressWarnings(&quot;rawtypes&quot;)
	@Test
	public void testSpelTypesExpression() throws Exception {
		Class dateClass = exp.parseExpression(&quot;T(java.util.Date)&quot;).getValue(
				Class.class);
		assertEquals(&quot;java.util.Date&quot;, dateClass.getName());
		assertTrue(exp
				.parseExpression(
						&quot;T(java.math.RoundingMode).CEILING &amp;lt; T(java.math.RoundingMode).FLOOR&quot;)
				.getValue(Boolean.class));
	}

	/**
	 * 构造函数调用测试
	 * 
	 * @throws Exception
	 */
	@Test
	public void testSpelConstructorsExpression() throws Exception {
		SpelTestInnerClass spt = exp
				.parseExpression(
						&quot;new study.spring.beans.SpelTestInnerClass('constructTest',23)&quot;)
				.getValue(SpelTestInnerClass.class);
		assertEquals(23, spt.getAge());
		assertEquals(&quot;constructTest&quot;, spt.getName());
	}

	/**
	 * 设置变量测试
	 * 
	 * @throws Exception
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	@Test
	public void testSpelVariablesExpression() throws Exception {
		List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
		list.addAll(Arrays.asList(2, 3, 4, 5, 6, 7, 9));

		secontext.setVariable(&quot;list&quot;, list);
		List&amp;lt;Integer&amp;gt; vList = (List&amp;lt;Integer&amp;gt;) exp.parseExpression(&quot;#list&quot;)
				.getValue(secontext);
		assertEquals(vList, list);

		List&amp;lt;Integer&amp;gt; nums = (List&amp;lt;Integer&amp;gt;) exp.parseExpression(
				&quot;#list.?[#this &amp;gt;5]&quot;).getValue(secontext); // 获取值大于5的元素集合
		assertEquals(nums, Arrays.asList(6, 7, 9));
	}

	/**
	 * 自定义函数表达式测试
	 * 
	 * @throws Exception
	 */
	@Test
	public void testSpelFunctionExpression() throws Exception {
		StandardEvaluationContext context = new StandardEvaluationContext();
		context.registerFunction(&quot;len&quot;, SpElUtil.class.getDeclaredMethod(&quot;len&quot;,
				new Class[] { String.class }));
		assertEquals(3, exp.parseExpression(&quot;#len('abc')&quot;).getValue(context));
	}

	@Test
	public void testSpelBeanExpression() throws Exception {

	}

	/**
	 * 三元操作测试
	 * 
	 * @throws Exception
	 */
	@Test
	public void testSpelTernaryOperatorExpression() throws Exception {
		assertTrue(exp.parseExpression(&quot; true ? true :false&quot;).getValue(
				Boolean.class));
		assertEquals(&quot;is true&quot;,
				exp.parseExpression(&quot; 1 == 1 ? 'is true' :'is false'&quot;)
						.getValue(String.class));
	}

	/**
	 * Elvis 操作测试
	 * 
	 * @throws Exception
	 */
	@Test
	public void testSpeleElvisOperatorExpression() throws Exception {
		Expression ex = exp.parseExpression(&quot;name?:'name is null'&quot;);
		assertEquals(&quot;override&quot;, ex.getValue(secontext, String.class));
		spel.setName(null);
		assertEquals(&quot;name is null&quot;, ex.getValue(secontext, String.class));
		spel.setName(&quot;override&quot;);
	}

	/**
	 * 安全导航操作测试
	 * 
	 * @throws Exception
	 */
	@Test
	public void testSpelSafeNavOperatorExpression() throws Exception {
		assertEquals(&quot;innerClass&quot;, exp.parseExpression(&quot;innerClass?.name&quot;)
				.getValue(secontext, String.class));
		spel.setInnerClass(null);
		// 使用这种表达式可以避免抛出空指针异常
		assertNull(exp.parseExpression(&quot;innerClass?.name&quot;).getValue(secontext,
				String.class));

	}

	/**
	 * 集合选择表达式测试
	 * 
	 * @throws Exception
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	@Test
	public void testSpelCollectionSelectExpression() throws Exception {
		spel.setNumbers(Arrays.asList(2, 3, 4, 5, 6, 7, 9));

		List&amp;lt;Integer&amp;gt; nums = (List&amp;lt;Integer&amp;gt;) exp.parseExpression(
				&quot;numbers.?[#this &amp;gt;5]&quot;).getValue(secontext);
		assertEquals(nums, Arrays.asList(6, 7, 9));
		// 获取第一个元素
		assertEquals(6,
				exp.parseExpression(&quot;numbers.^[#this &amp;gt; 5]&quot;).getValue(secontext));
		// 获取最后一个元素
		assertEquals(9,
				exp.parseExpression(&quot;numbers.$[#this &amp;gt; 5]&quot;).getValue(secontext));

		Map&amp;lt;Integer, String&amp;gt; maps = (Map&amp;lt;Integer, String&amp;gt;) exp.parseExpression(
				&quot;maps.?[value == 'string3' ]&quot;).getValue(secontext);
		Map&amp;lt;Integer, String&amp;gt; tmap = new HashMap&amp;lt;Integer, String&amp;gt;();
		tmap.put(3, &quot;string3&quot;);
		assertEquals(maps, tmap);

		Map&amp;lt;Integer, String&amp;gt; mapk = (Map&amp;lt;Integer, String&amp;gt;) exp.parseExpression(
				&quot;maps.?[key &amp;gt; 2 and key &amp;lt; 4 ]&quot;).getValue(secontext);
		assertEquals(mapk, tmap);

	}

	/**
	 * 投影表达式测试
	 * 
	 * @throws Exception
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	@Test
	public void testSpelProjectionExpression() throws Exception {
		spel.setNumbers(Arrays.asList(2, 3, 4, 5, 6));

		assertEquals(Arrays.asList(5, 6, 7, 8, 9),
				exp.parseExpression(&quot;numbers.![#this+3]&quot;).getValue(secontext));

		List&amp;lt;Integer&amp;gt; keys = (List&amp;lt;Integer&amp;gt;) exp.parseExpression(&quot;maps.![key]&quot;)
				.getValue(secontext);
		assertEquals(keys, Arrays.asList(1, 2, 3, 4));

		List&amp;lt;String&amp;gt; mapv = (List&amp;lt;String&amp;gt;) exp.parseExpression(&quot;maps.![value]&quot;)
				.getValue(secontext);
		assertEquals(mapv,
				Arrays.asList(&quot;string1&quot;, &quot;string2&quot;, &quot;string3&quot;, &quot;String4&quot;));

		List&amp;lt;Boolean&amp;gt; mapK = (List&amp;lt;Boolean&amp;gt;) exp.parseExpression(
				&quot;maps.![key &amp;gt; 2 and value !='String4']&quot;).getValue(secontext);
		assertEquals(mapK, Arrays.asList(false, false, true, false));
	}

	/**
	 * 模板语言测试
	 * 
	 * @throws Exception
	 */
	@Test
	public void testSpelTemplate() throws Exception {
		assertEquals(
				&quot; this is a test 4&quot;,
				exp.parseExpression(&quot; this is a test #{ maps.![key].get(3)}&quot;,
						new TemplateParserContext()).getValue(secontext,
						String.class));
	}
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      <pubDate>Sun, 19 Jun 2011 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2011/06/19/spring-expression-language</guid>
      <dc:date>2011-06-19T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>一些关于javascript、jQuery使用时的建议</title>
      <link>http://leeyee.github.io/blog/2011/04/09/javascript-jquery-user-suggests</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;1.在遍历数组时缓存长度&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dom&quot;&gt;2.如果需要给DOM中添加新的元素，避免创建一个元素添加一次。应尽量只添加一次&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;3.避免重复，保持代码干燥&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;4.当心匿名函数。&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;5.选择器的优化&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#id&quot;&gt;5.1.通过ID来获取元素是最好的选择&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;5.2.选择器的右边要具体化，而不是左边。&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot;&gt;5.3.避免选择器过度具体化&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot;&gt;5.4.避免使用通配符选择器。(能被匹配在任何地方的指定或隐含的选择器运行是非常慢的)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#use-event-delegation&quot;&gt;6.使用事件委托(Use Event Delegation)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#fndetachdom&quot;&gt;7.使用&lt;code&gt;$.fn.detach&lt;/code&gt;从DOM中移除元素&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot;&gt;8.使用样式表改变样式，当需要改变许多元素样式时&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#datafndata&quot;&gt;9.使用&lt;code&gt;$.data&lt;/code&gt;替代&lt;code&gt;$.fn.data&lt;/code&gt;存储数据&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-8&quot;&gt;10.不要对不存在的元素施加操作&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-9&quot;&gt;11.变量定义&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-10&quot;&gt;12.条件语句&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jquery&quot;&gt;13.不要把jQuery视作一个黑盒子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;1.在遍历数组时缓存长度&lt;/h2&gt;

&lt;p&gt;在遍历数组时应将数组的长度保存在一个变量中，不要在循环中每次都访问数组长度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// bad code  
for ( var i = 0; i &amp;lt; aArray.length; i++) {  
    // TODO something  
}  

// better code  
var iLen = aArray.length;  
for ( var i = 0; i &amp;lt; iLen; i++) {  
    // TODO something  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;dom&quot;&gt;2.如果需要给DOM中添加新的元素，避免创建一个元素添加一次。应尽量只添加一次&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// bad code  
$.each(aArray, function(i, item) {  
    var newListItem = '&amp;lt;li&amp;gt;' + item + '&amp;lt;/li&amp;gt;';  
    $('ul').append(newListItem); // 这里每append一次都将会重载DOM  
});  

// better code  
var frag = document.createDocumentFragment(); // 创建文档碎片  
$.each(aArray, function(i, item) {  
    var newListItem = '&amp;lt;li&amp;gt;' + item + '&amp;lt;/li&amp;gt;';  
    frag.appendChild(newListItem); // 这里不会刷新DOM  
});  
$('ul').appendChild(frag); // 添加新元素，此时重载DOM一次  

// or do this  
var sHtml = '';  
$.each(aArray, function(i, item) {  
    html += '&amp;lt;li&amp;gt;' + item + '&amp;lt;/li&amp;gt;'; // 构造需要添加元素的字符串  
});  
$('ul').html(sHtml); // 使用jQuery的$.fn.html()方法添加改字符串  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;3.避免重复，保持代码干燥&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// bad code  
if ($eventfade.data('currently') != 'showing') {  
    $eventfade.stop();  
}  
if ($eventhover.data('currently') != 'showing') {  
    $eventhover.stop();  
}  
if ($spans.data('currently') != 'showing') {  
    $spans.stop();  
}  

// good  
var $elems = [ $eventfade, $eventhover, $spans ]; // 构造一个数组  
$.each($elems, function(i, elem) {  
    if (elem.data('currently') != 'showing') {  
        elem.stop();  
    }  
});  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;4.当心匿名函数。&lt;/h2&gt;

&lt;p&gt;绑定匿名函数是让人头疼的，对于他们调试，修改，测试或者重用都是困难的。因此可以使用对象去组织和命名你的处理方法和回调函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// bad code  
$(document).ready(function() {  
    $('#magic').click(function(e){  
            $('#yayeffects').slideUp(function() {  
                    // TODO some codes  
            });  
    });  
    $(&quot;#happiness&quot;).load(url + ' #unicorns',function(){  
        // TODO some codes  
    });  
});  
  
// better  
var PI = {  
     onReady :  function(){  
            $('#magci').click(PI.candyMtn);  
            $('#happiness').load(PI.url + ' #unicorns', PI.unicornCb);  
     },  
     candyMtn : function(e) {  
            $('#yayeffects').slideUp(PI.slideCb);  
     },  
     slideCb : function() { // TODO some codes},  
     unicornCb : function() { // TODO some codes}  
};  
$(document).ready(PI.onReady);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;5.选择器的优化&lt;/h2&gt;

&lt;h3 id=&quot;id&quot;&gt;5.1.通过ID来获取元素是最好的选择&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// fast  
$('#container div.robotarm'); // 获取元素id=container中div元素class=robotarm的元素

// super-fast  
$('#container').find('div.robotarm');  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$.fn.find&lt;/code&gt;方法是快速的，因为对于第一个选择&lt;code&gt;$('#container')&lt;/code&gt;其实质是通过&lt;code&gt;document.getElementById()&lt;/code&gt;来实现的。&lt;code&gt;document.getElementById()&lt;/code&gt;是浏览器原生方法 &lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;5.2.选择器的右边要具体化，而不是左边。&lt;/h3&gt;

&lt;p&gt;如果可以尽量使&lt;code&gt;tag.class&lt;/code&gt;出现在右边，而单独的&lt;code&gt;tag&lt;/code&gt;或者&lt;code&gt;.class&lt;/code&gt;出现在左边&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 未经优化的  
$('div.data .gonzalez'); 

// 优化后  
$('.data td.gonzalez');  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;5.3.避免选择器过度具体化&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$('.data table.attendees td.gonzalez');  
// better : drop the middle if possible  
$('.data td.gonzalez');  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;5.4.避免使用通配符选择器。(能被匹配在任何地方的指定或隐含的选择器运行是非常慢的)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 查询效率低下  
$('.buttons &amp;gt; *'); 

// much better  
$('.buttons').children(); 

// 隐含的通配选择 no good  
$('.gender :radio'); 

// 和上面一样。明确的通配选择 no good  
$('.gender *:radio'); 

// much better  
$('.gender input:radio');  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;use-event-delegation&quot;&gt;6.使用事件委托(Use Event Delegation)&lt;/h2&gt;

&lt;p&gt;事件委托允许绑定一个事件处理程序到一个容器元素上（比如，一个无序序列）替代多容器元素（比如，列表项）。&lt;/p&gt;

&lt;p&gt;使用jQuery的&lt;code&gt;$.fn.live&lt;/code&gt;和&lt;code&gt;$.fn.delegate&lt;/code&gt;是易于实现事件委托的。在可能的情况下应该使用&lt;code&gt;$.fn.delegate&lt;/code&gt;替代&lt;code&gt;$.fn.live&lt;/code&gt;,因为&lt;code&gt;$.fn.delegate&lt;/code&gt;省去了不必要的选择，并且当DOM上下文明确时，相对&lt;code&gt;$.fn.live&lt;/code&gt;，使用&lt;code&gt;$.fn.delegate&lt;/code&gt;能减少约80%的开销。&lt;/p&gt;

&lt;p&gt;除了性能方面的好处外，事件委托会在添加新容器元素到页面时直接绑定处理程序，而无需对新添容器元素重新绑定处理程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// bad (当有很多&amp;lt;li class='trigger'/&amp;gt;时，该种调用将会很慢)  
$('li.trigger').click(handlerFn); // 当动态添加&amp;lt;li class='trigger'/&amp;gt;元素时，该新增元素上将无法自动添加handlerFn时间，需重新绑定

// better: 使用$.fn.live实现事件委托 所有&amp;lt;li class='trigger'/&amp;gt;都将绑定handlerFn事件  
$('li.trigger').live('click', handlerFn);

// best: 使用$.fn.delegate实现事件委托，允许你很容易的指定一个上下
// $('#myList')中的所有&amp;lt;li class='trigger'/&amp;gt;都将绑定handlerFn事件。其他&amp;lt;li class='trigger'/&amp;gt;则未被绑定  
$('#myList').delegate('li.trigger', 'click', handlerFn);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;fndetachdom&quot;&gt;7.使用&lt;code&gt;$.fn.detach&lt;/code&gt;从DOM中移除元素&lt;/h2&gt;

&lt;p&gt;操作DOM是缓慢的；你应该尽可能避免操作他们。在jQuery的1.4版本中提供&lt;code&gt;$.fn.detach&lt;/code&gt;来解决这个问题。&lt;code&gt;$.fn.detach&lt;/code&gt;允许从DOM中移除一个元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $table = $('#myTable');  
var $parent = $table.parent(); // 获取$table元素的父节点  
$table.detach(); // 从DOM中移除该表格  
// TODO 添加一些行到table中  
$parent.append($table); // 将table重新添加到原来位置  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-7&quot;&gt;8.使用样式表改变样式，当需要改变许多元素样式时&lt;/h2&gt;

&lt;p&gt;假如你将使用&lt;code&gt;$.fn.css&lt;/code&gt;改变超过20个元素的样式时，请考虑添加一个样式标签到页面。这样可以提升约60%的执行速度&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 前20个是比较快的，往后会越来越慢  
$('a.swedberg').css('color', '#asd123'); // 考虑到$('a.swedberg')选择的匹配元素的数量很大时  
// instead of  
$('&amp;lt;style type=&quot;text/css&quot;&amp;gt;
        a.swedverg { color ：#asd123 }  
        a.swedverg { color ：#asd123 }
    &amp;lt;/style&amp;gt;').appendTo('head');  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;datafndata&quot;&gt;9.使用&lt;code&gt;$.data&lt;/code&gt;替代&lt;code&gt;$.fn.data&lt;/code&gt;存储数据&lt;/h2&gt;

&lt;p&gt;在DOM元素上使用&lt;code&gt;$.data&lt;/code&gt;替代在jQuery选择器上调用&lt;code&gt;$.fn.data&lt;/code&gt;将带来可达10倍的速度提升。因为&lt;code&gt;$.data&lt;/code&gt;是jQuery的底层方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 惯用的  
$(element).data(key, value); 

// 十倍速度的  
$.data(element, key, value); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-8&quot;&gt;10.不要对不存在的元素施加操作&lt;/h2&gt;

&lt;p&gt;jQuery不会告诉你是否正在一大堆空的选择器上运行代码，他会当做没有事情是错的继续运行。因此你需要自己去核实选择器包含的一些元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// bad  
$('#nosuchthing').slideUp(); // 在实现.slideUp前应先确保$('#nosuchthing')是存在的

// better  
var $mySelection = $('#nosuchthing');  
if ($mySelection.length) {  
    $mySelection.slideUp();  
} 

// best：添加一个doOnce插件  
jQuery.fn.doOnce = function(func) { // doOnce的作用类似公共函数  
    this.length &amp;amp;&amp;amp; func.apply(this);  
    return this;  
};  
$('li.cartitmes').doOnce(function() {  
    // make it ajax！ /ｏ/  
});  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-9&quot;&gt;11.变量定义&lt;/h2&gt;

&lt;p&gt;多变量可被定义可以用一条语句替代几条语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// old &amp;amp; busted  
var test = 1;  
var test2 = function() {  
    // TODO some things  
};  
var test3 = test2(test); 

// new hotness  
var test = 1, test2 = function() {  
    // TODO some things  
}, test3 = test2(test);  
// 在自动执行函数中，变量的定义可被整块跳过  
// out foo+bar --&amp;gt; 3  
(function(foo, bar) {  
    console.log(&quot;foo+bar --&amp;gt; &quot; + (foo + bar));  
})(1, 2);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-10&quot;&gt;12.条件语句&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// old way  
if (type == 'foo' || type == 'bar') {  
    // TODO something  
} 

// better  
if (/^(foo|bar)$/.test(type)) {  
    // TODO something  
}  

// object literal lookup  
if (({  
    foo : 1,  
    bar : 1  
})[type]) {  
// TODO something  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jquery&quot;&gt;13.不要把jQuery视作一个黑盒子&lt;/h2&gt;

&lt;p&gt;将jQuery源码作为你的文档 – 保存&lt;a href=&quot;https://github.com/jquery/jquery&quot;&gt;https://github.com/jquery/jquery&lt;/a&gt; 在你的书签里，并且经常查阅他.&lt;/p&gt;
</description>
      <pubDate>Sat, 09 Apr 2011 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2011/04/09/javascript-jquery-user-suggests</guid>
      <dc:date>2011-04-09T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>javascript 最佳实践</title>
      <link>http://leeyee.github.io/blog/2010/04/07/javascript-best-practices</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#var&quot;&gt;1.总是使用关键字_var_声明变量&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;2.属性检测胜过浏览器检测&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;3.使用方括号&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#eval&quot;&gt;4.避免使用eval&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot;&gt;5.正确引用表单及表单中的元素&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#with&quot;&gt;6.避免使用&lt;em&gt;with&lt;/em&gt;语句&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#onclickjavascript&quot;&gt;7.在锚上使用&lt;em&gt;onclick&lt;/em&gt;事件替代javascript伪协议&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot;&gt;8.用一元+操作进行数字类型转换&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#documentall&quot;&gt;9.避免使用&lt;em&gt;document.all&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#javascripthtml&quot;&gt;10.不要在javascript代码块中使用HTML注解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot;&gt;11.避免杂乱的全局命名空间&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ajax&quot;&gt;12.避免使用同步ajax调用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#json&quot;&gt;13.使用json&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#script&quot;&gt;14.正确使用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;http://www.javascripttoolbox.com/bestpractices/&quot;&gt;http://www.javascripttoolbox.com/bestpractices/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;var&quot;&gt;1.总是使用关键字_var_声明变量&lt;/h3&gt;

&lt;p&gt;javascript中的变量不是全局范围就是函数范围，使用关键字&lt;code&gt;var&lt;/code&gt;声明变量是必不可少的。当声明一个变量时不管是全局变量还是函数级变量，都不应省略变量的前缀关键字&lt;code&gt;var&lt;/code&gt;。下边的例子说明了如果不这样做可能存在的潜在问题。&lt;/p&gt;

&lt;p&gt;没有使用关键字&lt;code&gt;var&lt;/code&gt;声明变量产生的问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i = 0; // This is good - creates a global variable
function test() {
    for (i=0; i&amp;lt;10; i++) {
        alert(&quot;Hello World!&quot;);
    }
}
test();
alert(i); // The global variable i is now 10!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如函数内部的变量i没有作为一个函数级别的变量通过&lt;code&gt;var&lt;/code&gt;声明，它将在这个例子中引用全局变量。这是一个好的方式通过&lt;code&gt;var&lt;/code&gt;声明一个全局变量，但是对于函数范围的变量通过&lt;code&gt;var&lt;/code&gt;来声明是重要的。下面提供的两种方式在功能上与上面的代码是一样的。&lt;/p&gt;

&lt;p&gt;更正过的函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function test() {
	var i=0;
    for (var i = 0; i &amp;lt; 10; i++) {
        alert(&quot;Hello World!&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;2.属性检测胜过浏览器检测&lt;/h3&gt;

&lt;p&gt;有些代码是被写来检测浏览器版本和检测基于用户使用代理的不同行为的。通常情况下这个是一个非常糟糕的编程实践。任何甚至是一些看起来像全局“导航”的对象都是令人怀疑的。&lt;br /&gt;
最好的方式是使用属性检测。也就是说，当在一个老版本的浏览器上使用任何可能不被支持的高级属性时，应该先去检查下该函数或是方法是否被支持，然后再使用它。这样比起在使用函数或是方法时通过检测具体的浏览器版本和假设客户端支持该功能要好的多。关于这个话题更深层次的讨论可以参看&lt;a href=&quot;http://www.jibbering.com/faq/faq_notes/not_browser_detect.html&quot;&gt;这里&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (document.getElementById) {
    var element = document.getElementById('MyId');
} else {
    alert('Your browser lacks the capabilities required to run this script!');
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;3.使用方括号&lt;/h3&gt;

&lt;p&gt;当访问的对象属性是动态生成的（在运行期间定义的）或是对象的属性无法使用点操作获取时，使用方括号。假如你不是一个有经验的javascript程序员，对于在所有地方均使用方括号获取对象属性的操作不算是一个糟糕的编程实践。&lt;br /&gt;
javascript中主要有两种方式可以访问对象的属性：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;点操作&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyObject.property
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;方括号操作&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyObject[&quot;property&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当属性名是硬编码方式并且在运行期间是不能被改变时使用点操作；当属性名是一个被评估用来解析属性名的字符串时使用方括号操作。该字符串可以硬编码，也可以是一个变量，甚至可以是一个调用返回字符串属性名的函数。&lt;br /&gt;
假如属性名是动态（运行期间）生成的，那么方括号是必需的。比如，当你有属性“value1”、“value2”、“value3”并且想通过一个变量&lt;code&gt;i = 2&lt;/code&gt;来访问时：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyObject[&quot;value&quot;+i]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是可以工作的，而&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyObject.value + i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不可以的。同样在其他一些服务端环境中（php、Struts等）被当作服务端的数组表单域是通过附加方括号表示的。然而，使用点符号引用一个包含方括号的域名将是无法工作的，因为引用一个javascript数组时方括号是做为语法参考的。因此方括号是必须的。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;formref.elements[&quot;name[]&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是可以工作的，而&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;formref.elements.name[]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是无法工作的。&lt;/p&gt;

&lt;p&gt;方括号的使用建议是：当需要使用方括号时始终使用它，这是显而易见的。使用方括号是没有严格要求的，只是个人喜好和习惯问题。一个好的经验法则是用点符号访问标准对象属性而使用方括号访问那些定义在页面中的对象属性。因此，尽管&lt;code&gt;document[&quot;getElementById&quot;]()&lt;/code&gt;是一个完美的使用方括号的方式，但&lt;code&gt;document.getElementById()&lt;/code&gt;是一个标准语法，因为&lt;code&gt;getElementById&lt;/code&gt;是一个在&lt;code&gt;DOM&lt;/code&gt;文档中定的标准文档对象属性。混合使用点符合和方括号能清楚的标明那些是标准属性，那些是由内容定义的名称：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.forms[&quot;myformname&quot;].elements[&quot;myinput&quot;].value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，&lt;code&gt;forms&lt;/code&gt;属性是标准的文档属性，表单名&lt;code&gt;myformname&lt;/code&gt;是被页面内容定义的。同样的&lt;code&gt;elements&lt;/code&gt;属性和&lt;code&gt;value&lt;/code&gt;属性均是被特别定义的，而&lt;code&gt;myinput&lt;/code&gt;是在页面定义的。这样的语句非常清晰、易于理解，是一种推荐的约定方式，但不是一个严格的规则。&lt;/p&gt;

&lt;h3 id=&quot;eval&quot;&gt;4.避免使用eval&lt;/h3&gt;

&lt;p&gt;javascript中的&lt;code&gt;eval()&lt;/code&gt;函数是一种在运行时期运行任意代码的方式。几乎在所有的情况下，都应避免使用&lt;code&gt;eval()&lt;/code&gt;函数。假如在你的代码中存在该函数的调用，那么一定要确保你使用了正确的方式去实现你想要做的事情。例如，&lt;code&gt;eval&lt;/code&gt;经常会被一些不知道方括号使用规则的程序员调用。&lt;/p&gt;

&lt;p&gt;规则是：&lt;strong&gt;“eval是邪恶的”&lt;/strong&gt;。不要使用它，除非你是一个经验丰富的开发人员，知道使用&lt;code&gt;eval&lt;/code&gt;对你来说只是一个例外的情况。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;5.正确引用表单及表单中的元素&lt;/h3&gt;

&lt;p&gt;在html的表单元素中，所有的表单元素都有一个&lt;code&gt;name&lt;/code&gt;属性。但对于xhtml文档，name属性不是必须的。取而代之的是对于表单标签应该有一个id属性并可以通过&lt;code&gt;document.getElementById&lt;/code&gt;获取该表单对象。虽然可以通过索引获取表单，但几乎在所有的情况下使用&lt;code&gt;document.forms[0]&lt;/code&gt;却是一个不好的实践方式。一些浏览器会把表单可见做为文档自有属性来访问表单的名称。这是不可靠并且不应该被使用的。&lt;/p&gt;

&lt;p&gt;下面的例子使用方括号和正确的对象引用来展示如何万无一失的获取表单输入框属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 正确引用到表单中的input对象
document.forms[&quot;formname&quot;].elements[&quot;inputname&quot;]
// 坏的实践
document.formname.inputname
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如你想通过函数调用获取多表单元素，最好先把表单对象作为一个变量存储起来。这样可以避免在获取表单中的元素时重复获取表单对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var formElements = document.forms[&quot;mainForm&quot;].elements;
formElements[&quot;input1&quot;].value=&quot;a&quot;;
formElements[&quot;input2&quot;].value=&quot;b&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当用&lt;code&gt;onChange&lt;/code&gt;事件或是相似事件验证一个输入栏时，将待验证对象本身的引用传递给验证函数将是一个好的方式。表单内部的每一个&lt;code&gt;input&lt;/code&gt;元素都有一个表单对象引用来作为参考。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&quot;text&quot; name=&quot;address&quot; onChange=&quot;validate(this)&quot;&amp;gt;
function validate(input_obj) {
// Get a reference to the form which contains this element
var theform = input_obj.form;
// Now you can check other inputs in the same form without
// hard-coding a reference to the form itself
    if (theform.elements[&quot;city&quot;].value==&quot;&quot;) {
        alert(&quot;Error&quot;);
    }
} 通过引用到一个表单对象并通过该引用表单对象访问其属性，你可以写一个不需要在页面上指定包含任何引用表单参数的函数。这种方式经常被作为一种避免多次引用表单对象的习惯性用法使用。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;with&quot;&gt;6.避免使用&lt;em&gt;with&lt;/em&gt;语句&lt;/h3&gt;

&lt;p&gt;javascript中&lt;code&gt;with&lt;/code&gt;语句将在作用域链之前插入一个对象，因此任何对属性/变量的引用将会忽略对象本身的属性/变量而首先检测本地的属性/变量作用域。这种方法经常被看作是一种避免较长引用的捷径。&lt;/p&gt;

&lt;p&gt;使用with的举例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with (document.forms[&quot;mainForm&quot;].elements) {
    input1.value = &quot;junk&quot;;
    input2.value = &quot;junk&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出上面这段代码的问题是程序员无法验证 input1/input2 是作为表单元素数组的属性被使用的。解释程序会先把用这些名称当作属性来检测，假如不能被找到，那么解释程序将继续查找顶层的作用域链。最终解释程序将试图把input1/input2当作全局变量去寻找其value属性，如果没有则返回一个错误。相反，创建一个引用指向重新使用的对象并且用引用去解决其他引用。&lt;/p&gt;

&lt;p&gt;使用一个引用替代&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var elements = document.forms[&quot;mainForm&quot;].elements;
elements.input1.value = &quot;junk&quot;;
elements.input2.value = &quot;junk&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;onclickjavascript&quot;&gt;7.在锚上使用&lt;em&gt;onclick&lt;/em&gt;事件替代javascript伪协议&lt;/h3&gt;

&lt;p&gt;当你想通过&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;标签触发javascript代码时，使用&lt;code&gt;onclick&lt;/code&gt;处理器优于使用javascript伪协议。通过&lt;code&gt;onclick&lt;/code&gt;处理器运行的javascript代码必须返回true或false （或者返回的表达式等价于true或false）给调用该js代码的标签。假如返回true，那么&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;标签的HREF属性将被当作一般的超链接使用；假如返回false，那么HREF属性将被忽略。这就是为什么经常在&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;标签中使用&lt;code&gt;onclick&lt;/code&gt;处理器调用js代码时会在代码最后出现”return false”的原因。&lt;/p&gt;

&lt;p&gt;正确的语法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&quot;javascript_required.html&quot; mce_href=&quot;javascript_required.html&quot; onclick=&quot;doSomething(); return false;&quot;&amp;gt;go&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这段示例代码中，当超链接被点击时&lt;code&gt;doSomething()&lt;/code&gt;函数（用户在页面某处定义）将被调用并返回false。href将不会指向浏览器。然而，假如浏览器没有启用javascirpt ，那么javascript_required.html文件将被加载，你可以通过提示用户启用javascript解决该问题。通常情况下当你确认用户浏览器启用了javascript时，链接只需要使用&lt;code&gt;href=&quot;#&quot;&lt;/code&gt;这种简单形式。但这是一种猥琐的方式。一个好的解决方式是链接一个用户浏览器没有开启javascript时的备用页面。&lt;/p&gt;

&lt;p&gt;有时，你想有条件的提交一个链接。例如，如果用户浏览远离你的表单页面，你首先要验证这一切都没有改变。在这种情况下，您的点击会调用一个函数，它将返回一个值去说明是否该提交本链接。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&quot;/&quot; onClick=&quot;return validate();&quot;&amp;gt;Home&amp;lt;/a&amp;gt;
function validate() {
    return prompt(&quot;Are you sure you want to exit this page?&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，&lt;code&gt;validate()&lt;/code&gt;函数总是返回true或是false。true意味着用户被允许返回到首页，而false意味着不被允许链接到首页的。这个例子提示用户确认信息，依赖用户点击ok或是cancel来返回true或false;&lt;/p&gt;

&lt;p&gt;下面是一些无法正常工作的例子。假如在你的页面上看到这些代码，那么他们是不正确的应该被更正的。&lt;/p&gt;

&lt;p&gt;什么是不该做的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&quot;javascript:doSomething()&quot;&amp;gt;link&amp;lt;/a&amp;gt;
&amp;lt;a href=&quot;#&quot; onClick=&quot;doSomething()&quot;&amp;gt;link&amp;lt;/a&amp;gt;
&amp;lt;a href=&quot;#&quot; onClick=&quot;javascript:doSomething();&quot;&amp;gt;link&amp;lt;/a&amp;gt;
&amp;lt;a href=&quot;#&quot; onClick=&quot;javascript:doSomething(); return false;&quot;&amp;gt;link&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;8.用一元+操作进行数字类型转换&lt;/h3&gt;
&lt;p&gt;在javascript中，加号操作符被当作加法或是字符连接符来使用。比如，由于javascript是一种弱类型语言，当将表单域值加起来时这可能会导致一些问题。表单域值将被当作字符串对待，假如你用+将他们放在一起，javascript将视为连接它，而不是加法。&lt;/p&gt;

&lt;p&gt;有问题的例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form name=&quot;myform&quot; action=&quot;[url]&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; name=&quot;val1&quot; value=&quot;1&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; name=&quot;val2&quot; value=&quot;2&quot;&amp;gt;
&amp;lt;/form&amp;gt;

function total() {
    var theform = document.forms[&quot;myform&quot;];
    var total = theform.elements[&quot;val1&quot;].value + theform.elements[&quot;val2&quot;].value;
    alert(total); // This will alert &quot;12&quot;, but what you wanted was 3!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了更正这个问题，需要给javascript一个暗示，告诉它将值当作数字而不是字符串。你可以使用一元加号操作符将字符串转换为数字类型。使用加号前缀修饰一个变量或者一个表达式将强转该变量或表达式的返回值为数字类型，使其可以成功的使用在一个数学操作中。&lt;/p&gt;

&lt;p&gt;更正后的例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function total() {
    var theform = document.forms[&quot;myform&quot;];
    var total = (+theform.elements[&quot;val1&quot;].value) + (+theform.elements[&quot;val2&quot;].value);
    alert(total); // This will alert 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;documentall&quot;&gt;9.避免使用&lt;em&gt;document.all&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;document.all&lt;/code&gt;是微软在IE中介绍的，它不是一个标准的javascript DOM属性。虽然许多最新的浏览器通过支持它去兼容依赖于它的蹩脚脚本，但仍有许多浏览器不支持它。&lt;/p&gt;

&lt;p&gt;在javascript中除过将&lt;code&gt;document.all&lt;/code&gt;作为另外一些方法不被支持时的备份及IE5.0以前的浏览器使用外，是没有任何理由使用&lt;code&gt;document.all&lt;/code&gt;的。你不应该通过判断是否支持&lt;code&gt;doucment.all&lt;/code&gt;来确定你的浏览器是否为IE，因为现在其他的浏览器也支持这个方法。&lt;/p&gt;

&lt;p&gt;仅仅把document.all作为最后的补救方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (document.getElementById) {
    var obj = document.getElementById(&quot;myId&quot;);
} else if (document.all) {
    var obj = document.all(&quot;myId&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一些使用&lt;code&gt;document.all&lt;/code&gt;的规则是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;总是首先尝试使用其他标准方法&lt;/li&gt;
  &lt;li&gt;仅把&lt;code&gt;doucment.all&lt;/code&gt;作为最后的补救方法使用&lt;/li&gt;
  &lt;li&gt;仅使用他在你需要支持IE5.0以前的版本中&lt;/li&gt;
  &lt;li&gt;当你在使用&lt;code&gt;document.all&lt;/code&gt;时，总是用&lt;code&gt;if(document.all)&lt;/code&gt;来检查它是否被支持&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;javascripthtml&quot;&gt;10.不要在javascript代码块中使用HTML注解&lt;/h3&gt;

&lt;p&gt;在早期的javascript中（1995），一些像Netscape1.0的浏览器是不支持&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签的。因此当javascript第一次被发布的时候，面临的问题是需要隐藏老版本浏览器对其不支持而把它们作为文本显示在页面上的问题。”hack”使用HTML的注释包裹script块来隐藏代码。&lt;br /&gt;
在script中使用HTML注释是不好的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script language=&quot;javascript&quot;&amp;gt;
    &amp;lt;!--
        // code here
    //--&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在今天是没有那个浏览器会忽略&lt;code&gt;&amp;lt;scrpit&amp;gt;&lt;/code&gt;标签的，因此隐藏javascript代码已经不再需要。事实上，在script中使用HTML注释是无益的，原因如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在XHTML文档中，js源代码实际将在所有的浏览器中被隐藏。&lt;/li&gt;
  &lt;li&gt;在HTML注释中&lt;code&gt;--&lt;/code&gt;是不被解析的，因此这将会导致任何在脚本中的递减操作是无效的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;11.避免杂乱的全局命名空间&lt;/h3&gt;

&lt;p&gt;全局变量和函数是很少用到的。使用全局变量可能会导致命名冲突（ Using globals may cause naming conflicts between javascript source files and cause code to break. ）出于这种结果，一个好的实践方式是通过单一全局命名空间将这些全局变量封装起来。&lt;/p&gt;

&lt;p&gt;有几个不同的方式可以完成这个任务，其中一些比起另外一些结构是相对比较复杂的。简单的方式是创建一个单一的全局对象，并且分配属性和方法给这个对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MyLib = {}; // global Object cointainer
MyLib.value = 1;
MyLib.increment = function() { 
    MyLib.value++; 
}
MyLib.show = function() { 
    alert(MyLib.value); 
}
MyLib.value=6;
MyLib.increment();
MyLib.show(); // alerts 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命名空间也可以通过&lt;a href=&quot;http://www.jibbering.com/faq/faq_notes/closures.html&quot; title=&quot;Closures&quot;&gt;闭包&lt;/a&gt;创建，并且在javascript中私有成员变量 也能被模拟。&lt;/p&gt;

&lt;h3 id=&quot;ajax&quot;&gt;12.避免使用同步ajax调用&lt;/h3&gt;

&lt;p&gt;当使用Ajax请求时，你可以选择使用同步模式或者异步模式。异步模式在后台处理请求的同时其他浏览器的请求可以继续被处理，而同步模式将等待请求结果返回后才继续执行下一次请求。&lt;/p&gt;

&lt;p&gt;同步请求模式应避免使用。同步请求将造成浏览器被锁住直到请求结果返回。这种情况下，服务器将处于忙碌状态，响应也需要一段时间，用户的浏览器（也许是操作系统）将不允许其他任何事情被做。同时也可能是，响应没有正确的被接收到，浏览器将一直保持锁住状态直到请求超时。&lt;/p&gt;

&lt;p&gt;假如你需要使用同步模式，那么你可能需要花大部分时间去重新考虑你的设计。实际需要同步模式的&lt;a href=&quot;http://www.ajaxtoolbox.com/&quot; title=&quot;Ajax&quot;&gt;Ajax&lt;/a&gt;请求如果有也是很少的。&lt;/p&gt;

&lt;h3 id=&quot;json&quot;&gt;13.使用json&lt;/h3&gt;

&lt;p&gt;当通过&lt;a href=&quot;http://www.ajaxtoolbox.com/&quot; title=&quot;Ajax&quot;&gt;Ajax&lt;/a&gt;存储文本格式数据或发送/接收数据时，在能使用&lt;a href=&quot;http://www.json.org/&quot; title=&quot;JavaScript Object Notation&quot;&gt;JSON&lt;/a&gt;的情况下尽量使用json替代xml。json是一个更紧凑更高效的数据格式并且是语言中性的。&lt;/p&gt;

&lt;h3 id=&quot;script&quot;&gt;14.正确使用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签是没有 LANGUAGE 属性的。正确的方式是创建如下的javascript代码块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt; // code here &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

</description>
      <pubDate>Wed, 07 Apr 2010 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2010/04/07/javascript-best-practices</guid>
      <dc:date>2010-04-07T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>屏蔽window.close方法在IE中的二次确认</title>
      <link>http://leeyee.github.io/blog/2009/08/24/javascript-window-close-notconfirm</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ie7&quot;&gt;IE7及其以上版本&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ie6&quot;&gt;IE6及其以下版本&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#chromesafarifirefox&quot;&gt;Chrome,Safari和Firefox&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在实际的开发过程中遇到当调用javascript中&lt;code&gt;window.close()&lt;/code&gt;方法时，IE会在页面关闭前询问用户是否要关闭的二次确认对话框。为了避免这个问题，需要在调用&lt;code&gt;window&lt;/code&gt;对象的&lt;code&gt;close&lt;/code&gt;方法前做一些处理&lt;/p&gt;

&lt;p&gt;针对IE的不同版本，处理方式是不同的。因此在处理之前应先判断IE浏览器的版本。&lt;/p&gt;

&lt;p&gt;浏览器及其版本的判断可以使用jQuery1.9版本之前的&lt;a href=&quot;http://api.jquery.com/jQuery.browser/&quot;&gt;$.browser&lt;/a&gt;方法或者&lt;a href=&quot;/blog/2009/08/24/javacript-broswer-check/&quot;&gt;使用javascript检测浏览器版本&lt;/a&gt;中提到的方式检测，这里不在赘述直接给出相关代码。&lt;/p&gt;

&lt;h3 id=&quot;ie7&quot;&gt;IE7及其以上版本&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if(isMinIE7||isMinIE8){ // IE7以上  
    window.open('','_top');  
    window.top.close();  
    return ;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;ie6&quot;&gt;IE6及其以下版本&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if(isMinIE6){//IE6   
    window.opener=null;  
    window.close();  
    return ;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;chromesafarifirefox&quot;&gt;Chrome,Safari和Firefox&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; window.close(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;alert alert-error&quot;&gt;
&lt;h4&gt;Notes: &lt;/h4&gt; 针对FireFox浏览器时，除了使用&lt;code&gt;window.close()&lt;/code&gt;，为了达到直接关节而无需提示的效果都需要在FireFox的地址栏中输入&lt;code&gt;about:config&lt;/code&gt;，然后将&lt;code&gt;dom.allow_script_to_close_windows&lt;/code&gt;改为true才能达到想要的效果。
&lt;/div&gt;
</description>
      <pubDate>Mon, 24 Aug 2009 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2009/08/24/javascript-window-close-notconfirm</guid>
      <dc:date>2009-08-24T00:00:00+08:00</dc:date>
    </item>
    <item>
      <title>使用javascript检测浏览器版本</title>
      <link>http://leeyee.github.io/blog/2009/08/24/javacript-broswer-check</link>
      <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#opera&quot;&gt;Opera浏览器检测&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#google-chrome&quot;&gt;Google Chrome浏览器检测&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ie&quot;&gt;IE浏览器检测&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#konquerorsafari-&quot;&gt;Konqueror/Safari 浏览器检测&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#mozilla-firefox&quot;&gt;Mozilla FireFox浏览器检测&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;完整的代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下浏览器版本的判断方法参考了《JavaScript 高级程序设计》第八章。&lt;/p&gt;

&lt;p&gt;总体上我们验证浏览器及其版本是通过浏览器的&lt;strong&gt;user-agent&lt;/strong&gt;字符串来检测的。常见的有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Safari： Mozilla/5.0 (Windows NT 5.1) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2
Chrome： Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.64 Safari/537.31
IE：     Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; InfoPath.2; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)
Firefox：Mozilla/5.0 (Windows NT 5.1; rv:19.0) Gecko/20100101 Firefox/19.0 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此对浏览器的版本分析都是基于该字符串中所包含的信息进行的。可以通过如下代码获取&lt;strong&gt;user-agent&lt;/strong&gt;信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var sUserAgent = navigator.userAgent;    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;opera&quot;&gt;Opera浏览器检测&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var isOpera = sUserAgent.indexOf(&quot;Opera&quot;) &amp;gt; -1;
if (isOpera) {
	//检测是否进行了伪装
	if (navigator.appName == 'Opera') {
		version = parseFloat(navigator.appVersion);//没有伪装，直接获取版本号
	} else {
		var reOperaVersion = new RegExp(&quot;Opera (\\d+.\\d+)&quot;);
        //使用正则表达式的test方法测试并将版本号保存在RegExp.$1中
		reOperaVersion.test(sUserAgent);
		version = parseFloat(RegExp['$1']);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;google-chrome&quot;&gt;Google Chrome浏览器检测&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var isChrome = sUserAgent.indexOf(&quot;Chrome&quot;) &amp;gt; -1;
if (isChrome) {
	var reChorme = new RegExp(&quot;Chrome/(\\d+\\.\\d+(?:\\.\\d+\\.\\d+))?&quot;);
	reChorme.test(sUserAgent);
    version = parseFloat(RegExp['$1']);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;ie&quot;&gt;IE浏览器检测&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// !isOpera 避免是由Opera伪装成的IE  
var isIE = sUserAgent.indexOf(&quot;compatible&quot;) &amp;gt; -1
		&amp;amp;&amp;amp; sUserAgent.indexOf(&quot;MSIE&quot;) &amp;gt; -1 &amp;amp;&amp;amp; !isOpera;
if (isIE) {
	var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;);
	reIE.test(sUserAgent);
	version = parseFloat(RegExp['$1']);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;konquerorsafari-&quot;&gt;Konqueror/Safari 浏览器检测&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//排除Chrome信息，因为在Chrome的user-agent字符串中会出现Konqueror/Safari的关键字
var isKHTML = (sUserAgent.indexOf(&quot;KHTML&quot;) &amp;gt; -1
		|| sUserAgent.indexOf(&quot;Konqueror&quot;) &amp;gt; -1 || sUserAgent
		.indexOf(&quot;AppleWebKit&quot;) &amp;gt; -1)
		&amp;amp;&amp;amp; !isChrome;

if (isKHTML) {//判断是否基于KHTML，如果是的话在继续判断属于何种KHTML浏览器
	var isSafari = sUserAgent.indexOf(&quot;AppleWebKit&quot;) &amp;gt; -1;
	var isKonq = sUserAgent.indexOf(&quot;Konqueror&quot;) &amp;gt; -1;

	if (isSafari) {
		var reAppleWebKit = new RegExp(&quot;Version/(\\d+(?:\\.\\d*)?)&quot;);
		reAppleWebKit.test(sUserAgent);
		var fAppleWebKitVersion = parseFloat(RegExp[&quot;$1&quot;]);
		version = parseFloat(RegExp['$1']);
	} else if (isKonq) {
		var reKong = new RegExp(
				&quot;Konqueror/(\\d+(?:\\.\\d+(?\\.\\d)?)?)&quot;);
		reKong.test(sUserAgent);
		version = parseFloat(RegExp['$1']);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;mozilla-firefox&quot;&gt;Mozilla FireFox浏览器检测&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//排除Chrome 及Konqueror/Safari的伪装
var isMoz = sUserAgent.indexOf(&quot;Gecko&quot;) &amp;gt; -1 &amp;amp;&amp;amp; !isChrome &amp;amp;&amp;amp; !isKHTML;
if (isMoz) {
	var reMoz = new RegExp(&quot;rv:(\\d+\\.\\d+(?:\\.\\d+)?)&quot;);
	reMoz.test(sUserAgent);
	version = parseFloat(RegExp['$1']);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本上浏览器的判断就到此为止，其他浏览器不做说明。可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.info(navigator.userAgent);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提示的信息具体分析相应浏览器的&lt;strong&gt;user-agent&lt;/strong&gt;，然后进行过处理获取浏览器个性信息及版本。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;完整的代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var broswer = function() {
	var _broswer = {};
	var sUserAgent = navigator.userAgent;
	console.info(&quot;useragent: &quot;, sUserAgent);

	var isOpera = sUserAgent.indexOf(&quot;Opera&quot;) &amp;gt; -1;
	if (isOpera) {
		//首先检测Opera是否进行了伪装
		if (navigator.appName == 'Opera') {
            //如果没有进行伪装，则直接后去版本号
			_broswer.version = parseFloat(navigator.appVersion);
		} else {
			var reOperaVersion = new RegExp(&quot;Opera (\\d+.\\d+)&quot;);
            //使用正则表达式的test方法测试并将版本号保存在RegExp.$1中
			reOperaVersion.test(sUserAgent);
			_broswer.version = parseFloat(RegExp['$1']);
		}
		_broswer.opera = true;
	}

	var isChrome = sUserAgent.indexOf(&quot;Chrome&quot;) &amp;gt; -1;
	if (isChrome) {
		var reChorme = new RegExp(&quot;Chrome/(\\d+\\.\\d+(?:\\.\\d+\\.\\d+))?&quot;);
		reChorme.test(sUserAgent);
		_broswer.version = parseFloat(RegExp['$1']);
		_broswer.chrome = true;
	}

	//排除Chrome信息，因为在Chrome的user-agent字符串中会出现Konqueror/Safari的关键字
	var isKHTML = (sUserAgent.indexOf(&quot;KHTML&quot;) &amp;gt; -1
			|| sUserAgent.indexOf(&quot;Konqueror&quot;) &amp;gt; -1 || sUserAgent
			.indexOf(&quot;AppleWebKit&quot;) &amp;gt; -1)
			&amp;amp;&amp;amp; !isChrome;

	if (isKHTML) {//判断是否基于KHTML，如果时的话在继续判断属于何种KHTML浏览器
		var isSafari = sUserAgent.indexOf(&quot;AppleWebKit&quot;) &amp;gt; -1;
		var isKonq = sUserAgent.indexOf(&quot;Konqueror&quot;) &amp;gt; -1;

		if (isSafari) {
			var reAppleWebKit = new RegExp(&quot;Version/(\\d+(?:\\.\\d*)?)&quot;);
			reAppleWebKit.test(sUserAgent);
			var fAppleWebKitVersion = parseFloat(RegExp[&quot;$1&quot;]);
			_broswer.version = parseFloat(RegExp['$1']);
			_broswer.safari = true;
		} else if (isKonq) {
			var reKong = new RegExp(
					&quot;Konqueror/(\\d+(?:\\.\\d+(?\\.\\d)?)?)&quot;);
			reKong.test(sUserAgent);
			_broswer.version = parseFloat(RegExp['$1']);
			_broswer.konqueror = true;
		}
	}

	// !isOpera 避免是由Opera伪装成的IE  
	var isIE = sUserAgent.indexOf(&quot;compatible&quot;) &amp;gt; -1
			&amp;amp;&amp;amp; sUserAgent.indexOf(&quot;MSIE&quot;) &amp;gt; -1 &amp;amp;&amp;amp; !isOpera;
	if (isIE) {
		var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;);
		reIE.test(sUserAgent);
		_broswer.version = parseFloat(RegExp['$1']);
		_broswer.msie = true;
	}

	// 排除Chrome 及 Konqueror/Safari 的伪装
	var isMoz = sUserAgent.indexOf(&quot;Gecko&quot;) &amp;gt; -1 &amp;amp;&amp;amp; !isChrome &amp;amp;&amp;amp; !isKHTML;
	if (isMoz) {
		var reMoz = new RegExp(&quot;rv:(\\d+\\.\\d+(?:\\.\\d+)?)&quot;);
		reMoz.test(sUserAgent);
		_broswer.version = parseFloat(RegExp['$1']);
		_broswer.mozilla = true;
	}
	return _broswer;
}

// 调用
var broswer = broswer();
console.info(&quot;broswer.version: &quot;, broswer.version);
console.info(&quot;broswer.msie is &quot;, broswer.msie);
console.info(&quot;broswer.safari is &quot;, broswer.safari);
console.info(&quot;broswer.opera is &quot;, broswer.opera);
console.info(&quot;broswer.mozilla is &quot;, broswer.mozilla);
console.info(&quot;broswer.chrome is &quot;, broswer.chrome);
console.info(&quot;broswer.konqueror is &quot;, broswer.konqueror);
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Mon, 24 Aug 2009 00:00:00 +0800</pubDate>
      <guid>http://leeyee.github.io/blog/2009/08/24/javacript-broswer-check</guid>
      <dc:date>2009-08-24T00:00:00+08:00</dc:date>
    </item>
    <dc:date>2016-01-17T00:00:00+08:00</dc:date>
  </channel>
</rss>